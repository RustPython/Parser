// File automatically generated by ast/asdl_rs.py.

impl ToPyo3Ast for crate::located::Mod {
    fn to_pyo3_ast(&self, _py: Python) -> PyResult<Py<PyAny>> {
        let instance = match &self {
            crate::Mod::Module(cons) => cons.to_pyo3_ast(_py)?,
            crate::Mod::Interactive(cons) => cons.to_pyo3_ast(_py)?,
            crate::Mod::Expression(cons) => cons.to_pyo3_ast(_py)?,
            crate::Mod::FunctionType(cons) => cons.to_pyo3_ast(_py)?,
        };
        Ok(instance)
    }
}

// constructor
impl ToPyo3Ast for crate::located::ModModule {
    fn to_pyo3_ast(&self, _py: Python) -> PyResult<Py<PyAny>> {
        let class = ranged::ModModule::py_type_cell().get().unwrap();
        let instance = class.call1(
            _py,
            (
                self.body.to_pyo3_ast(_py)?,
                self.type_ignores.to_pyo3_ast(_py)?,
            ),
        )?;
        Ok(instance.into())
    }
}

// constructor
impl ToPyo3Ast for crate::located::ModInteractive {
    fn to_pyo3_ast(&self, _py: Python) -> PyResult<Py<PyAny>> {
        let class = ranged::ModInteractive::py_type_cell().get().unwrap();
        let instance = class.call1(_py, (self.body.to_pyo3_ast(_py)?,))?;
        Ok(instance.into())
    }
}

// constructor
impl ToPyo3Ast for crate::located::ModExpression {
    fn to_pyo3_ast(&self, _py: Python) -> PyResult<Py<PyAny>> {
        let class = ranged::ModExpression::py_type_cell().get().unwrap();
        let instance = class.call1(_py, (self.body.to_pyo3_ast(_py)?,))?;
        Ok(instance.into())
    }
}

// constructor
impl ToPyo3Ast for crate::located::ModFunctionType {
    fn to_pyo3_ast(&self, _py: Python) -> PyResult<Py<PyAny>> {
        let class = ranged::ModFunctionType::py_type_cell().get().unwrap();
        let instance = class.call1(
            _py,
            (
                self.argtypes.to_pyo3_ast(_py)?,
                self.returns.to_pyo3_ast(_py)?,
            ),
        )?;
        Ok(instance.into())
    }
}

impl ToPyo3Ast for crate::located::Stmt {
    fn to_pyo3_ast(&self, _py: Python) -> PyResult<Py<PyAny>> {
        let instance = match &self {
            crate::Stmt::FunctionDef(cons) => cons.to_pyo3_ast(_py)?,
            crate::Stmt::AsyncFunctionDef(cons) => cons.to_pyo3_ast(_py)?,
            crate::Stmt::ClassDef(cons) => cons.to_pyo3_ast(_py)?,
            crate::Stmt::Return(cons) => cons.to_pyo3_ast(_py)?,
            crate::Stmt::Delete(cons) => cons.to_pyo3_ast(_py)?,
            crate::Stmt::Assign(cons) => cons.to_pyo3_ast(_py)?,
            crate::Stmt::AugAssign(cons) => cons.to_pyo3_ast(_py)?,
            crate::Stmt::AnnAssign(cons) => cons.to_pyo3_ast(_py)?,
            crate::Stmt::For(cons) => cons.to_pyo3_ast(_py)?,
            crate::Stmt::AsyncFor(cons) => cons.to_pyo3_ast(_py)?,
            crate::Stmt::While(cons) => cons.to_pyo3_ast(_py)?,
            crate::Stmt::If(cons) => cons.to_pyo3_ast(_py)?,
            crate::Stmt::With(cons) => cons.to_pyo3_ast(_py)?,
            crate::Stmt::AsyncWith(cons) => cons.to_pyo3_ast(_py)?,
            crate::Stmt::Match(cons) => cons.to_pyo3_ast(_py)?,
            crate::Stmt::Raise(cons) => cons.to_pyo3_ast(_py)?,
            crate::Stmt::Try(cons) => cons.to_pyo3_ast(_py)?,
            crate::Stmt::TryStar(cons) => cons.to_pyo3_ast(_py)?,
            crate::Stmt::Assert(cons) => cons.to_pyo3_ast(_py)?,
            crate::Stmt::Import(cons) => cons.to_pyo3_ast(_py)?,
            crate::Stmt::ImportFrom(cons) => cons.to_pyo3_ast(_py)?,
            crate::Stmt::Global(cons) => cons.to_pyo3_ast(_py)?,
            crate::Stmt::Nonlocal(cons) => cons.to_pyo3_ast(_py)?,
            crate::Stmt::Expr(cons) => cons.to_pyo3_ast(_py)?,
            crate::Stmt::Pass(cons) => cons.to_pyo3_ast(_py)?,
            crate::Stmt::Break(cons) => cons.to_pyo3_ast(_py)?,
            crate::Stmt::Continue(cons) => cons.to_pyo3_ast(_py)?,
        };
        Ok(instance)
    }
}

// constructor
impl ToPyo3Ast for crate::located::StmtFunctionDef {
    fn to_pyo3_ast(&self, _py: Python) -> PyResult<Py<PyAny>> {
        let class = ranged::StmtFunctionDef::py_type_cell().get().unwrap();
        let instance = class.call1(
            _py,
            (
                self.name.to_pyo3_ast(_py)?,
                self.args.to_pyo3_ast(_py)?,
                self.body.to_pyo3_ast(_py)?,
                self.decorator_list.to_pyo3_ast(_py)?,
                self.returns.to_pyo3_ast(_py)?,
                self.type_comment.to_pyo3_ast(_py)?,
            ),
        )?;
        Ok(instance.into())
    }
}

// constructor
impl ToPyo3Ast for crate::located::StmtAsyncFunctionDef {
    fn to_pyo3_ast(&self, _py: Python) -> PyResult<Py<PyAny>> {
        let class = ranged::StmtAsyncFunctionDef::py_type_cell().get().unwrap();
        let instance = class.call1(
            _py,
            (
                self.name.to_pyo3_ast(_py)?,
                self.args.to_pyo3_ast(_py)?,
                self.body.to_pyo3_ast(_py)?,
                self.decorator_list.to_pyo3_ast(_py)?,
                self.returns.to_pyo3_ast(_py)?,
                self.type_comment.to_pyo3_ast(_py)?,
            ),
        )?;
        Ok(instance.into())
    }
}

// constructor
impl ToPyo3Ast for crate::located::StmtClassDef {
    fn to_pyo3_ast(&self, _py: Python) -> PyResult<Py<PyAny>> {
        let class = ranged::StmtClassDef::py_type_cell().get().unwrap();
        let instance = class.call1(
            _py,
            (
                self.name.to_pyo3_ast(_py)?,
                self.bases.to_pyo3_ast(_py)?,
                self.keywords.to_pyo3_ast(_py)?,
                self.body.to_pyo3_ast(_py)?,
                self.decorator_list.to_pyo3_ast(_py)?,
            ),
        )?;
        Ok(instance.into())
    }
}

// constructor
impl ToPyo3Ast for crate::located::StmtReturn {
    fn to_pyo3_ast(&self, _py: Python) -> PyResult<Py<PyAny>> {
        let class = ranged::StmtReturn::py_type_cell().get().unwrap();
        let instance = class.call1(_py, (self.value.to_pyo3_ast(_py)?,))?;
        Ok(instance.into())
    }
}

// constructor
impl ToPyo3Ast for crate::located::StmtDelete {
    fn to_pyo3_ast(&self, _py: Python) -> PyResult<Py<PyAny>> {
        let class = ranged::StmtDelete::py_type_cell().get().unwrap();
        let instance = class.call1(_py, (self.targets.to_pyo3_ast(_py)?,))?;
        Ok(instance.into())
    }
}

// constructor
impl ToPyo3Ast for crate::located::StmtAssign {
    fn to_pyo3_ast(&self, _py: Python) -> PyResult<Py<PyAny>> {
        let class = ranged::StmtAssign::py_type_cell().get().unwrap();
        let instance = class.call1(
            _py,
            (
                self.targets.to_pyo3_ast(_py)?,
                self.value.to_pyo3_ast(_py)?,
                self.type_comment.to_pyo3_ast(_py)?,
            ),
        )?;
        Ok(instance.into())
    }
}

// constructor
impl ToPyo3Ast for crate::located::StmtAugAssign {
    fn to_pyo3_ast(&self, _py: Python) -> PyResult<Py<PyAny>> {
        let class = ranged::StmtAugAssign::py_type_cell().get().unwrap();
        let instance = class.call1(
            _py,
            (
                self.target.to_pyo3_ast(_py)?,
                self.op.to_pyo3_ast(_py)?,
                self.value.to_pyo3_ast(_py)?,
            ),
        )?;
        Ok(instance.into())
    }
}

// constructor
impl ToPyo3Ast for crate::located::StmtAnnAssign {
    fn to_pyo3_ast(&self, _py: Python) -> PyResult<Py<PyAny>> {
        let class = ranged::StmtAnnAssign::py_type_cell().get().unwrap();
        let instance = class.call1(
            _py,
            (
                self.target.to_pyo3_ast(_py)?,
                self.annotation.to_pyo3_ast(_py)?,
                self.value.to_pyo3_ast(_py)?,
                self.simple.to_pyo3_ast(_py)?,
            ),
        )?;
        Ok(instance.into())
    }
}

// constructor
impl ToPyo3Ast for crate::located::StmtFor {
    fn to_pyo3_ast(&self, _py: Python) -> PyResult<Py<PyAny>> {
        let class = ranged::StmtFor::py_type_cell().get().unwrap();
        let instance = class.call1(
            _py,
            (
                self.target.to_pyo3_ast(_py)?,
                self.iter.to_pyo3_ast(_py)?,
                self.body.to_pyo3_ast(_py)?,
                self.orelse.to_pyo3_ast(_py)?,
                self.type_comment.to_pyo3_ast(_py)?,
            ),
        )?;
        Ok(instance.into())
    }
}

// constructor
impl ToPyo3Ast for crate::located::StmtAsyncFor {
    fn to_pyo3_ast(&self, _py: Python) -> PyResult<Py<PyAny>> {
        let class = ranged::StmtAsyncFor::py_type_cell().get().unwrap();
        let instance = class.call1(
            _py,
            (
                self.target.to_pyo3_ast(_py)?,
                self.iter.to_pyo3_ast(_py)?,
                self.body.to_pyo3_ast(_py)?,
                self.orelse.to_pyo3_ast(_py)?,
                self.type_comment.to_pyo3_ast(_py)?,
            ),
        )?;
        Ok(instance.into())
    }
}

// constructor
impl ToPyo3Ast for crate::located::StmtWhile {
    fn to_pyo3_ast(&self, _py: Python) -> PyResult<Py<PyAny>> {
        let class = ranged::StmtWhile::py_type_cell().get().unwrap();
        let instance = class.call1(
            _py,
            (
                self.test.to_pyo3_ast(_py)?,
                self.body.to_pyo3_ast(_py)?,
                self.orelse.to_pyo3_ast(_py)?,
            ),
        )?;
        Ok(instance.into())
    }
}

// constructor
impl ToPyo3Ast for crate::located::StmtIf {
    fn to_pyo3_ast(&self, _py: Python) -> PyResult<Py<PyAny>> {
        let class = ranged::StmtIf::py_type_cell().get().unwrap();
        let instance = class.call1(
            _py,
            (
                self.test.to_pyo3_ast(_py)?,
                self.body.to_pyo3_ast(_py)?,
                self.orelse.to_pyo3_ast(_py)?,
            ),
        )?;
        Ok(instance.into())
    }
}

// constructor
impl ToPyo3Ast for crate::located::StmtWith {
    fn to_pyo3_ast(&self, _py: Python) -> PyResult<Py<PyAny>> {
        let class = ranged::StmtWith::py_type_cell().get().unwrap();
        let instance = class.call1(
            _py,
            (
                self.items.to_pyo3_ast(_py)?,
                self.body.to_pyo3_ast(_py)?,
                self.type_comment.to_pyo3_ast(_py)?,
            ),
        )?;
        Ok(instance.into())
    }
}

// constructor
impl ToPyo3Ast for crate::located::StmtAsyncWith {
    fn to_pyo3_ast(&self, _py: Python) -> PyResult<Py<PyAny>> {
        let class = ranged::StmtAsyncWith::py_type_cell().get().unwrap();
        let instance = class.call1(
            _py,
            (
                self.items.to_pyo3_ast(_py)?,
                self.body.to_pyo3_ast(_py)?,
                self.type_comment.to_pyo3_ast(_py)?,
            ),
        )?;
        Ok(instance.into())
    }
}

// constructor
impl ToPyo3Ast for crate::located::StmtMatch {
    fn to_pyo3_ast(&self, _py: Python) -> PyResult<Py<PyAny>> {
        let class = ranged::StmtMatch::py_type_cell().get().unwrap();
        let instance = class.call1(
            _py,
            (self.subject.to_pyo3_ast(_py)?, self.cases.to_pyo3_ast(_py)?),
        )?;
        Ok(instance.into())
    }
}

// constructor
impl ToPyo3Ast for crate::located::StmtRaise {
    fn to_pyo3_ast(&self, _py: Python) -> PyResult<Py<PyAny>> {
        let class = ranged::StmtRaise::py_type_cell().get().unwrap();
        let instance = class.call1(
            _py,
            (self.exc.to_pyo3_ast(_py)?, self.cause.to_pyo3_ast(_py)?),
        )?;
        Ok(instance.into())
    }
}

// constructor
impl ToPyo3Ast for crate::located::StmtTry {
    fn to_pyo3_ast(&self, _py: Python) -> PyResult<Py<PyAny>> {
        let class = ranged::StmtTry::py_type_cell().get().unwrap();
        let instance = class.call1(
            _py,
            (
                self.body.to_pyo3_ast(_py)?,
                self.handlers.to_pyo3_ast(_py)?,
                self.orelse.to_pyo3_ast(_py)?,
                self.finalbody.to_pyo3_ast(_py)?,
            ),
        )?;
        Ok(instance.into())
    }
}

// constructor
impl ToPyo3Ast for crate::located::StmtTryStar {
    fn to_pyo3_ast(&self, _py: Python) -> PyResult<Py<PyAny>> {
        let class = ranged::StmtTryStar::py_type_cell().get().unwrap();
        let instance = class.call1(
            _py,
            (
                self.body.to_pyo3_ast(_py)?,
                self.handlers.to_pyo3_ast(_py)?,
                self.orelse.to_pyo3_ast(_py)?,
                self.finalbody.to_pyo3_ast(_py)?,
            ),
        )?;
        Ok(instance.into())
    }
}

// constructor
impl ToPyo3Ast for crate::located::StmtAssert {
    fn to_pyo3_ast(&self, _py: Python) -> PyResult<Py<PyAny>> {
        let class = ranged::StmtAssert::py_type_cell().get().unwrap();
        let instance = class.call1(
            _py,
            (self.test.to_pyo3_ast(_py)?, self.msg.to_pyo3_ast(_py)?),
        )?;
        Ok(instance.into())
    }
}

// constructor
impl ToPyo3Ast for crate::located::StmtImport {
    fn to_pyo3_ast(&self, _py: Python) -> PyResult<Py<PyAny>> {
        let class = ranged::StmtImport::py_type_cell().get().unwrap();
        let instance = class.call1(_py, (self.names.to_pyo3_ast(_py)?,))?;
        Ok(instance.into())
    }
}

// constructor
impl ToPyo3Ast for crate::located::StmtImportFrom {
    fn to_pyo3_ast(&self, _py: Python) -> PyResult<Py<PyAny>> {
        let class = ranged::StmtImportFrom::py_type_cell().get().unwrap();
        let instance = class.call1(
            _py,
            (
                self.module.to_pyo3_ast(_py)?,
                self.names.to_pyo3_ast(_py)?,
                self.level.to_pyo3_ast(_py)?,
            ),
        )?;
        Ok(instance.into())
    }
}

// constructor
impl ToPyo3Ast for crate::located::StmtGlobal {
    fn to_pyo3_ast(&self, _py: Python) -> PyResult<Py<PyAny>> {
        let class = ranged::StmtGlobal::py_type_cell().get().unwrap();
        let instance = class.call1(_py, (self.names.to_pyo3_ast(_py)?,))?;
        Ok(instance.into())
    }
}

// constructor
impl ToPyo3Ast for crate::located::StmtNonlocal {
    fn to_pyo3_ast(&self, _py: Python) -> PyResult<Py<PyAny>> {
        let class = ranged::StmtNonlocal::py_type_cell().get().unwrap();
        let instance = class.call1(_py, (self.names.to_pyo3_ast(_py)?,))?;
        Ok(instance.into())
    }
}

// constructor
impl ToPyo3Ast for crate::located::StmtExpr {
    fn to_pyo3_ast(&self, _py: Python) -> PyResult<Py<PyAny>> {
        let class = ranged::StmtExpr::py_type_cell().get().unwrap();
        let instance = class.call1(_py, (self.value.to_pyo3_ast(_py)?,))?;
        Ok(instance.into())
    }
}

// constructor
impl ToPyo3Ast for crate::located::StmtPass {
    fn to_pyo3_ast(&self, _py: Python) -> PyResult<Py<PyAny>> {
        let class = ranged::StmtPass::py_type_cell().get().unwrap();
        let instance = class.call1(_py, ())?;
        Ok(instance.into())
    }
}

// constructor
impl ToPyo3Ast for crate::located::StmtBreak {
    fn to_pyo3_ast(&self, _py: Python) -> PyResult<Py<PyAny>> {
        let class = ranged::StmtBreak::py_type_cell().get().unwrap();
        let instance = class.call1(_py, ())?;
        Ok(instance.into())
    }
}

// constructor
impl ToPyo3Ast for crate::located::StmtContinue {
    fn to_pyo3_ast(&self, _py: Python) -> PyResult<Py<PyAny>> {
        let class = ranged::StmtContinue::py_type_cell().get().unwrap();
        let instance = class.call1(_py, ())?;
        Ok(instance.into())
    }
}

impl ToPyo3Ast for crate::located::Expr {
    fn to_pyo3_ast(&self, _py: Python) -> PyResult<Py<PyAny>> {
        let instance = match &self {
            crate::Expr::BoolOp(cons) => cons.to_pyo3_ast(_py)?,
            crate::Expr::NamedExpr(cons) => cons.to_pyo3_ast(_py)?,
            crate::Expr::BinOp(cons) => cons.to_pyo3_ast(_py)?,
            crate::Expr::UnaryOp(cons) => cons.to_pyo3_ast(_py)?,
            crate::Expr::Lambda(cons) => cons.to_pyo3_ast(_py)?,
            crate::Expr::IfExp(cons) => cons.to_pyo3_ast(_py)?,
            crate::Expr::Dict(cons) => cons.to_pyo3_ast(_py)?,
            crate::Expr::Set(cons) => cons.to_pyo3_ast(_py)?,
            crate::Expr::ListComp(cons) => cons.to_pyo3_ast(_py)?,
            crate::Expr::SetComp(cons) => cons.to_pyo3_ast(_py)?,
            crate::Expr::DictComp(cons) => cons.to_pyo3_ast(_py)?,
            crate::Expr::GeneratorExp(cons) => cons.to_pyo3_ast(_py)?,
            crate::Expr::Await(cons) => cons.to_pyo3_ast(_py)?,
            crate::Expr::Yield(cons) => cons.to_pyo3_ast(_py)?,
            crate::Expr::YieldFrom(cons) => cons.to_pyo3_ast(_py)?,
            crate::Expr::Compare(cons) => cons.to_pyo3_ast(_py)?,
            crate::Expr::Call(cons) => cons.to_pyo3_ast(_py)?,
            crate::Expr::FormattedValue(cons) => cons.to_pyo3_ast(_py)?,
            crate::Expr::JoinedStr(cons) => cons.to_pyo3_ast(_py)?,
            crate::Expr::Constant(cons) => cons.to_pyo3_ast(_py)?,
            crate::Expr::Attribute(cons) => cons.to_pyo3_ast(_py)?,
            crate::Expr::Subscript(cons) => cons.to_pyo3_ast(_py)?,
            crate::Expr::Starred(cons) => cons.to_pyo3_ast(_py)?,
            crate::Expr::Name(cons) => cons.to_pyo3_ast(_py)?,
            crate::Expr::List(cons) => cons.to_pyo3_ast(_py)?,
            crate::Expr::Tuple(cons) => cons.to_pyo3_ast(_py)?,
            crate::Expr::Slice(cons) => cons.to_pyo3_ast(_py)?,
        };
        Ok(instance)
    }
}

// constructor
impl ToPyo3Ast for crate::located::ExprBoolOp {
    fn to_pyo3_ast(&self, _py: Python) -> PyResult<Py<PyAny>> {
        let class = ranged::ExprBoolOp::py_type_cell().get().unwrap();
        let instance = class.call1(
            _py,
            (self.op.to_pyo3_ast(_py)?, self.values.to_pyo3_ast(_py)?),
        )?;
        Ok(instance.into())
    }
}

// constructor
impl ToPyo3Ast for crate::located::ExprNamedExpr {
    fn to_pyo3_ast(&self, _py: Python) -> PyResult<Py<PyAny>> {
        let class = ranged::ExprNamedExpr::py_type_cell().get().unwrap();
        let instance = class.call1(
            _py,
            (self.target.to_pyo3_ast(_py)?, self.value.to_pyo3_ast(_py)?),
        )?;
        Ok(instance.into())
    }
}

// constructor
impl ToPyo3Ast for crate::located::ExprBinOp {
    fn to_pyo3_ast(&self, _py: Python) -> PyResult<Py<PyAny>> {
        let class = ranged::ExprBinOp::py_type_cell().get().unwrap();
        let instance = class.call1(
            _py,
            (
                self.left.to_pyo3_ast(_py)?,
                self.op.to_pyo3_ast(_py)?,
                self.right.to_pyo3_ast(_py)?,
            ),
        )?;
        Ok(instance.into())
    }
}

// constructor
impl ToPyo3Ast for crate::located::ExprUnaryOp {
    fn to_pyo3_ast(&self, _py: Python) -> PyResult<Py<PyAny>> {
        let class = ranged::ExprUnaryOp::py_type_cell().get().unwrap();
        let instance = class.call1(
            _py,
            (self.op.to_pyo3_ast(_py)?, self.operand.to_pyo3_ast(_py)?),
        )?;
        Ok(instance.into())
    }
}

// constructor
impl ToPyo3Ast for crate::located::ExprLambda {
    fn to_pyo3_ast(&self, _py: Python) -> PyResult<Py<PyAny>> {
        let class = ranged::ExprLambda::py_type_cell().get().unwrap();
        let instance = class.call1(
            _py,
            (self.args.to_pyo3_ast(_py)?, self.body.to_pyo3_ast(_py)?),
        )?;
        Ok(instance.into())
    }
}

// constructor
impl ToPyo3Ast for crate::located::ExprIfExp {
    fn to_pyo3_ast(&self, _py: Python) -> PyResult<Py<PyAny>> {
        let class = ranged::ExprIfExp::py_type_cell().get().unwrap();
        let instance = class.call1(
            _py,
            (
                self.test.to_pyo3_ast(_py)?,
                self.body.to_pyo3_ast(_py)?,
                self.orelse.to_pyo3_ast(_py)?,
            ),
        )?;
        Ok(instance.into())
    }
}

// constructor
impl ToPyo3Ast for crate::located::ExprDict {
    fn to_pyo3_ast(&self, _py: Python) -> PyResult<Py<PyAny>> {
        let class = ranged::ExprDict::py_type_cell().get().unwrap();
        let instance = class.call1(
            _py,
            (self.keys.to_pyo3_ast(_py)?, self.values.to_pyo3_ast(_py)?),
        )?;
        Ok(instance.into())
    }
}

// constructor
impl ToPyo3Ast for crate::located::ExprSet {
    fn to_pyo3_ast(&self, _py: Python) -> PyResult<Py<PyAny>> {
        let class = ranged::ExprSet::py_type_cell().get().unwrap();
        let instance = class.call1(_py, (self.elts.to_pyo3_ast(_py)?,))?;
        Ok(instance.into())
    }
}

// constructor
impl ToPyo3Ast for crate::located::ExprListComp {
    fn to_pyo3_ast(&self, _py: Python) -> PyResult<Py<PyAny>> {
        let class = ranged::ExprListComp::py_type_cell().get().unwrap();
        let instance = class.call1(
            _py,
            (
                self.elt.to_pyo3_ast(_py)?,
                self.generators.to_pyo3_ast(_py)?,
            ),
        )?;
        Ok(instance.into())
    }
}

// constructor
impl ToPyo3Ast for crate::located::ExprSetComp {
    fn to_pyo3_ast(&self, _py: Python) -> PyResult<Py<PyAny>> {
        let class = ranged::ExprSetComp::py_type_cell().get().unwrap();
        let instance = class.call1(
            _py,
            (
                self.elt.to_pyo3_ast(_py)?,
                self.generators.to_pyo3_ast(_py)?,
            ),
        )?;
        Ok(instance.into())
    }
}

// constructor
impl ToPyo3Ast for crate::located::ExprDictComp {
    fn to_pyo3_ast(&self, _py: Python) -> PyResult<Py<PyAny>> {
        let class = ranged::ExprDictComp::py_type_cell().get().unwrap();
        let instance = class.call1(
            _py,
            (
                self.key.to_pyo3_ast(_py)?,
                self.value.to_pyo3_ast(_py)?,
                self.generators.to_pyo3_ast(_py)?,
            ),
        )?;
        Ok(instance.into())
    }
}

// constructor
impl ToPyo3Ast for crate::located::ExprGeneratorExp {
    fn to_pyo3_ast(&self, _py: Python) -> PyResult<Py<PyAny>> {
        let class = ranged::ExprGeneratorExp::py_type_cell().get().unwrap();
        let instance = class.call1(
            _py,
            (
                self.elt.to_pyo3_ast(_py)?,
                self.generators.to_pyo3_ast(_py)?,
            ),
        )?;
        Ok(instance.into())
    }
}

// constructor
impl ToPyo3Ast for crate::located::ExprAwait {
    fn to_pyo3_ast(&self, _py: Python) -> PyResult<Py<PyAny>> {
        let class = ranged::ExprAwait::py_type_cell().get().unwrap();
        let instance = class.call1(_py, (self.value.to_pyo3_ast(_py)?,))?;
        Ok(instance.into())
    }
}

// constructor
impl ToPyo3Ast for crate::located::ExprYield {
    fn to_pyo3_ast(&self, _py: Python) -> PyResult<Py<PyAny>> {
        let class = ranged::ExprYield::py_type_cell().get().unwrap();
        let instance = class.call1(_py, (self.value.to_pyo3_ast(_py)?,))?;
        Ok(instance.into())
    }
}

// constructor
impl ToPyo3Ast for crate::located::ExprYieldFrom {
    fn to_pyo3_ast(&self, _py: Python) -> PyResult<Py<PyAny>> {
        let class = ranged::ExprYieldFrom::py_type_cell().get().unwrap();
        let instance = class.call1(_py, (self.value.to_pyo3_ast(_py)?,))?;
        Ok(instance.into())
    }
}

// constructor
impl ToPyo3Ast for crate::located::ExprCompare {
    fn to_pyo3_ast(&self, _py: Python) -> PyResult<Py<PyAny>> {
        let class = ranged::ExprCompare::py_type_cell().get().unwrap();
        let instance = class.call1(
            _py,
            (
                self.left.to_pyo3_ast(_py)?,
                self.ops.to_pyo3_ast(_py)?,
                self.comparators.to_pyo3_ast(_py)?,
            ),
        )?;
        Ok(instance.into())
    }
}

// constructor
impl ToPyo3Ast for crate::located::ExprCall {
    fn to_pyo3_ast(&self, _py: Python) -> PyResult<Py<PyAny>> {
        let class = ranged::ExprCall::py_type_cell().get().unwrap();
        let instance = class.call1(
            _py,
            (
                self.func.to_pyo3_ast(_py)?,
                self.args.to_pyo3_ast(_py)?,
                self.keywords.to_pyo3_ast(_py)?,
            ),
        )?;
        Ok(instance.into())
    }
}

// constructor
impl ToPyo3Ast for crate::located::ExprFormattedValue {
    fn to_pyo3_ast(&self, _py: Python) -> PyResult<Py<PyAny>> {
        let class = ranged::ExprFormattedValue::py_type_cell().get().unwrap();
        let instance = class.call1(
            _py,
            (
                self.value.to_pyo3_ast(_py)?,
                self.conversion.to_pyo3_ast(_py)?,
                self.format_spec.to_pyo3_ast(_py)?,
            ),
        )?;
        Ok(instance.into())
    }
}

// constructor
impl ToPyo3Ast for crate::located::ExprJoinedStr {
    fn to_pyo3_ast(&self, _py: Python) -> PyResult<Py<PyAny>> {
        let class = ranged::ExprJoinedStr::py_type_cell().get().unwrap();
        let instance = class.call1(_py, (self.values.to_pyo3_ast(_py)?,))?;
        Ok(instance.into())
    }
}

// constructor
impl ToPyo3Ast for crate::located::ExprConstant {
    fn to_pyo3_ast(&self, _py: Python) -> PyResult<Py<PyAny>> {
        let class = ranged::ExprConstant::py_type_cell().get().unwrap();
        let instance = class.call1(
            _py,
            (self.value.to_pyo3_ast(_py)?, self.kind.to_pyo3_ast(_py)?),
        )?;
        Ok(instance.into())
    }
}

// constructor
impl ToPyo3Ast for crate::located::ExprAttribute {
    fn to_pyo3_ast(&self, _py: Python) -> PyResult<Py<PyAny>> {
        let class = ranged::ExprAttribute::py_type_cell().get().unwrap();
        let instance = class.call1(
            _py,
            (
                self.value.to_pyo3_ast(_py)?,
                self.attr.to_pyo3_ast(_py)?,
                self.ctx.to_pyo3_ast(_py)?,
            ),
        )?;
        Ok(instance.into())
    }
}

// constructor
impl ToPyo3Ast for crate::located::ExprSubscript {
    fn to_pyo3_ast(&self, _py: Python) -> PyResult<Py<PyAny>> {
        let class = ranged::ExprSubscript::py_type_cell().get().unwrap();
        let instance = class.call1(
            _py,
            (
                self.value.to_pyo3_ast(_py)?,
                self.slice.to_pyo3_ast(_py)?,
                self.ctx.to_pyo3_ast(_py)?,
            ),
        )?;
        Ok(instance.into())
    }
}

// constructor
impl ToPyo3Ast for crate::located::ExprStarred {
    fn to_pyo3_ast(&self, _py: Python) -> PyResult<Py<PyAny>> {
        let class = ranged::ExprStarred::py_type_cell().get().unwrap();
        let instance = class.call1(
            _py,
            (self.value.to_pyo3_ast(_py)?, self.ctx.to_pyo3_ast(_py)?),
        )?;
        Ok(instance.into())
    }
}

// constructor
impl ToPyo3Ast for crate::located::ExprName {
    fn to_pyo3_ast(&self, _py: Python) -> PyResult<Py<PyAny>> {
        let class = ranged::ExprName::py_type_cell().get().unwrap();
        let instance = class.call1(_py, (self.id.to_pyo3_ast(_py)?, self.ctx.to_pyo3_ast(_py)?))?;
        Ok(instance.into())
    }
}

// constructor
impl ToPyo3Ast for crate::located::ExprList {
    fn to_pyo3_ast(&self, _py: Python) -> PyResult<Py<PyAny>> {
        let class = ranged::ExprList::py_type_cell().get().unwrap();
        let instance = class.call1(
            _py,
            (self.elts.to_pyo3_ast(_py)?, self.ctx.to_pyo3_ast(_py)?),
        )?;
        Ok(instance.into())
    }
}

// constructor
impl ToPyo3Ast for crate::located::ExprTuple {
    fn to_pyo3_ast(&self, _py: Python) -> PyResult<Py<PyAny>> {
        let class = ranged::ExprTuple::py_type_cell().get().unwrap();
        let instance = class.call1(
            _py,
            (self.elts.to_pyo3_ast(_py)?, self.ctx.to_pyo3_ast(_py)?),
        )?;
        Ok(instance.into())
    }
}

// constructor
impl ToPyo3Ast for crate::located::ExprSlice {
    fn to_pyo3_ast(&self, _py: Python) -> PyResult<Py<PyAny>> {
        let class = ranged::ExprSlice::py_type_cell().get().unwrap();
        let instance = class.call1(
            _py,
            (
                self.lower.to_pyo3_ast(_py)?,
                self.upper.to_pyo3_ast(_py)?,
                self.step.to_pyo3_ast(_py)?,
            ),
        )?;
        Ok(instance.into())
    }
}

impl ToPyo3Ast for crate::located::ExprContext {
    fn to_pyo3_ast(&self, _py: Python) -> PyResult<Py<PyAny>> {
        let instance = match &self {
            crate::ExprContext::Load => ranged::ExprContextLoad::py_type_cell()
                .get()
                .unwrap()
                .clone(),
            crate::ExprContext::Store => ranged::ExprContextStore::py_type_cell()
                .get()
                .unwrap()
                .clone(),
            crate::ExprContext::Del => ranged::ExprContextDel::py_type_cell()
                .get()
                .unwrap()
                .clone(),
        };
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::located::Boolop {
    fn to_pyo3_ast(&self, _py: Python) -> PyResult<Py<PyAny>> {
        let instance = match &self {
            crate::Boolop::And => ranged::BoolopAnd::py_type_cell().get().unwrap().clone(),
            crate::Boolop::Or => ranged::BoolopOr::py_type_cell().get().unwrap().clone(),
        };
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::located::Operator {
    fn to_pyo3_ast(&self, _py: Python) -> PyResult<Py<PyAny>> {
        let instance = match &self {
            crate::Operator::Add => ranged::OperatorAdd::py_type_cell().get().unwrap().clone(),
            crate::Operator::Sub => ranged::OperatorSub::py_type_cell().get().unwrap().clone(),
            crate::Operator::Mult => ranged::OperatorMult::py_type_cell().get().unwrap().clone(),
            crate::Operator::MatMult => ranged::OperatorMatMult::py_type_cell()
                .get()
                .unwrap()
                .clone(),
            crate::Operator::Div => ranged::OperatorDiv::py_type_cell().get().unwrap().clone(),
            crate::Operator::Mod => ranged::OperatorMod::py_type_cell().get().unwrap().clone(),
            crate::Operator::Pow => ranged::OperatorPow::py_type_cell().get().unwrap().clone(),
            crate::Operator::LShift => ranged::OperatorLShift::py_type_cell()
                .get()
                .unwrap()
                .clone(),
            crate::Operator::RShift => ranged::OperatorRShift::py_type_cell()
                .get()
                .unwrap()
                .clone(),
            crate::Operator::BitOr => ranged::OperatorBitOr::py_type_cell().get().unwrap().clone(),
            crate::Operator::BitXor => ranged::OperatorBitXor::py_type_cell()
                .get()
                .unwrap()
                .clone(),
            crate::Operator::BitAnd => ranged::OperatorBitAnd::py_type_cell()
                .get()
                .unwrap()
                .clone(),
            crate::Operator::FloorDiv => ranged::OperatorFloorDiv::py_type_cell()
                .get()
                .unwrap()
                .clone(),
        };
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::located::Unaryop {
    fn to_pyo3_ast(&self, _py: Python) -> PyResult<Py<PyAny>> {
        let instance = match &self {
            crate::Unaryop::Invert => ranged::UnaryopInvert::py_type_cell().get().unwrap().clone(),
            crate::Unaryop::Not => ranged::UnaryopNot::py_type_cell().get().unwrap().clone(),
            crate::Unaryop::UAdd => ranged::UnaryopUAdd::py_type_cell().get().unwrap().clone(),
            crate::Unaryop::USub => ranged::UnaryopUSub::py_type_cell().get().unwrap().clone(),
        };
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::located::Cmpop {
    fn to_pyo3_ast(&self, _py: Python) -> PyResult<Py<PyAny>> {
        let instance = match &self {
            crate::Cmpop::Eq => ranged::CmpopEq::py_type_cell().get().unwrap().clone(),
            crate::Cmpop::NotEq => ranged::CmpopNotEq::py_type_cell().get().unwrap().clone(),
            crate::Cmpop::Lt => ranged::CmpopLt::py_type_cell().get().unwrap().clone(),
            crate::Cmpop::LtE => ranged::CmpopLtE::py_type_cell().get().unwrap().clone(),
            crate::Cmpop::Gt => ranged::CmpopGt::py_type_cell().get().unwrap().clone(),
            crate::Cmpop::GtE => ranged::CmpopGtE::py_type_cell().get().unwrap().clone(),
            crate::Cmpop::Is => ranged::CmpopIs::py_type_cell().get().unwrap().clone(),
            crate::Cmpop::IsNot => ranged::CmpopIsNot::py_type_cell().get().unwrap().clone(),
            crate::Cmpop::In => ranged::CmpopIn::py_type_cell().get().unwrap().clone(),
            crate::Cmpop::NotIn => ranged::CmpopNotIn::py_type_cell().get().unwrap().clone(),
        };
        Ok(instance)
    }
}

// product
impl ToPyo3Ast for crate::located::Comprehension {
    fn to_pyo3_ast(&self, _py: Python) -> PyResult<Py<PyAny>> {
        let class = ranged::Comprehension::py_type_cell().get().unwrap();
        let instance = class.call1(
            _py,
            (
                self.target.to_pyo3_ast(_py)?,
                self.iter.to_pyo3_ast(_py)?,
                self.ifs.to_pyo3_ast(_py)?,
                self.is_async.to_pyo3_ast(_py)?,
            ),
        )?;
        Ok(instance.into())
    }
}

impl ToPyo3Ast for crate::located::Excepthandler {
    fn to_pyo3_ast(&self, _py: Python) -> PyResult<Py<PyAny>> {
        let instance = match &self {
            crate::Excepthandler::ExceptHandler(cons) => cons.to_pyo3_ast(_py)?,
        };
        Ok(instance)
    }
}

// constructor
impl ToPyo3Ast for crate::located::ExcepthandlerExceptHandler {
    fn to_pyo3_ast(&self, _py: Python) -> PyResult<Py<PyAny>> {
        let class = ranged::ExcepthandlerExceptHandler::py_type_cell()
            .get()
            .unwrap();
        let instance = class.call1(
            _py,
            (
                self.type_.to_pyo3_ast(_py)?,
                self.name.to_pyo3_ast(_py)?,
                self.body.to_pyo3_ast(_py)?,
            ),
        )?;
        Ok(instance.into())
    }
}

// product
impl ToPyo3Ast for crate::located::Arguments {
    fn to_pyo3_ast(&self, _py: Python) -> PyResult<Py<PyAny>> {
        let class = ranged::Arguments::py_type_cell().get().unwrap();
        let instance = class.call1(
            _py,
            (
                self.posonlyargs.to_pyo3_ast(_py)?,
                self.args.to_pyo3_ast(_py)?,
                self.vararg.to_pyo3_ast(_py)?,
                self.kwonlyargs.to_pyo3_ast(_py)?,
                self.kw_defaults.to_pyo3_ast(_py)?,
                self.kwarg.to_pyo3_ast(_py)?,
                self.defaults.to_pyo3_ast(_py)?,
            ),
        )?;
        Ok(instance.into())
    }
}

// product
impl ToPyo3Ast for crate::located::Arg {
    fn to_pyo3_ast(&self, _py: Python) -> PyResult<Py<PyAny>> {
        let class = ranged::Arg::py_type_cell().get().unwrap();
        let instance = class.call1(
            _py,
            (
                self.arg.to_pyo3_ast(_py)?,
                self.annotation.to_pyo3_ast(_py)?,
                self.type_comment.to_pyo3_ast(_py)?,
            ),
        )?;
        Ok(instance.into())
    }
}

// product
impl ToPyo3Ast for crate::located::Keyword {
    fn to_pyo3_ast(&self, _py: Python) -> PyResult<Py<PyAny>> {
        let class = ranged::Keyword::py_type_cell().get().unwrap();
        let instance = class.call1(
            _py,
            (self.arg.to_pyo3_ast(_py)?, self.value.to_pyo3_ast(_py)?),
        )?;
        Ok(instance.into())
    }
}

// product
impl ToPyo3Ast for crate::located::Alias {
    fn to_pyo3_ast(&self, _py: Python) -> PyResult<Py<PyAny>> {
        let class = ranged::Alias::py_type_cell().get().unwrap();
        let instance = class.call1(
            _py,
            (self.name.to_pyo3_ast(_py)?, self.asname.to_pyo3_ast(_py)?),
        )?;
        Ok(instance.into())
    }
}

// product
impl ToPyo3Ast for crate::located::Withitem {
    fn to_pyo3_ast(&self, _py: Python) -> PyResult<Py<PyAny>> {
        let class = ranged::Withitem::py_type_cell().get().unwrap();
        let instance = class.call1(
            _py,
            (
                self.context_expr.to_pyo3_ast(_py)?,
                self.optional_vars.to_pyo3_ast(_py)?,
            ),
        )?;
        Ok(instance.into())
    }
}

// product
impl ToPyo3Ast for crate::located::MatchCase {
    fn to_pyo3_ast(&self, _py: Python) -> PyResult<Py<PyAny>> {
        let class = ranged::MatchCase::py_type_cell().get().unwrap();
        let instance = class.call1(
            _py,
            (
                self.pattern.to_pyo3_ast(_py)?,
                self.guard.to_pyo3_ast(_py)?,
                self.body.to_pyo3_ast(_py)?,
            ),
        )?;
        Ok(instance.into())
    }
}

impl ToPyo3Ast for crate::located::Pattern {
    fn to_pyo3_ast(&self, _py: Python) -> PyResult<Py<PyAny>> {
        let instance = match &self {
            crate::Pattern::MatchValue(cons) => cons.to_pyo3_ast(_py)?,
            crate::Pattern::MatchSingleton(cons) => cons.to_pyo3_ast(_py)?,
            crate::Pattern::MatchSequence(cons) => cons.to_pyo3_ast(_py)?,
            crate::Pattern::MatchMapping(cons) => cons.to_pyo3_ast(_py)?,
            crate::Pattern::MatchClass(cons) => cons.to_pyo3_ast(_py)?,
            crate::Pattern::MatchStar(cons) => cons.to_pyo3_ast(_py)?,
            crate::Pattern::MatchAs(cons) => cons.to_pyo3_ast(_py)?,
            crate::Pattern::MatchOr(cons) => cons.to_pyo3_ast(_py)?,
        };
        Ok(instance)
    }
}

// constructor
impl ToPyo3Ast for crate::located::PatternMatchValue {
    fn to_pyo3_ast(&self, _py: Python) -> PyResult<Py<PyAny>> {
        let class = ranged::PatternMatchValue::py_type_cell().get().unwrap();
        let instance = class.call1(_py, (self.value.to_pyo3_ast(_py)?,))?;
        Ok(instance.into())
    }
}

// constructor
impl ToPyo3Ast for crate::located::PatternMatchSingleton {
    fn to_pyo3_ast(&self, _py: Python) -> PyResult<Py<PyAny>> {
        let class = ranged::PatternMatchSingleton::py_type_cell().get().unwrap();
        let instance = class.call1(_py, (self.value.to_pyo3_ast(_py)?,))?;
        Ok(instance.into())
    }
}

// constructor
impl ToPyo3Ast for crate::located::PatternMatchSequence {
    fn to_pyo3_ast(&self, _py: Python) -> PyResult<Py<PyAny>> {
        let class = ranged::PatternMatchSequence::py_type_cell().get().unwrap();
        let instance = class.call1(_py, (self.patterns.to_pyo3_ast(_py)?,))?;
        Ok(instance.into())
    }
}

// constructor
impl ToPyo3Ast for crate::located::PatternMatchMapping {
    fn to_pyo3_ast(&self, _py: Python) -> PyResult<Py<PyAny>> {
        let class = ranged::PatternMatchMapping::py_type_cell().get().unwrap();
        let instance = class.call1(
            _py,
            (
                self.keys.to_pyo3_ast(_py)?,
                self.patterns.to_pyo3_ast(_py)?,
                self.rest.to_pyo3_ast(_py)?,
            ),
        )?;
        Ok(instance.into())
    }
}

// constructor
impl ToPyo3Ast for crate::located::PatternMatchClass {
    fn to_pyo3_ast(&self, _py: Python) -> PyResult<Py<PyAny>> {
        let class = ranged::PatternMatchClass::py_type_cell().get().unwrap();
        let instance = class.call1(
            _py,
            (
                self.cls.to_pyo3_ast(_py)?,
                self.patterns.to_pyo3_ast(_py)?,
                self.kwd_attrs.to_pyo3_ast(_py)?,
                self.kwd_patterns.to_pyo3_ast(_py)?,
            ),
        )?;
        Ok(instance.into())
    }
}

// constructor
impl ToPyo3Ast for crate::located::PatternMatchStar {
    fn to_pyo3_ast(&self, _py: Python) -> PyResult<Py<PyAny>> {
        let class = ranged::PatternMatchStar::py_type_cell().get().unwrap();
        let instance = class.call1(_py, (self.name.to_pyo3_ast(_py)?,))?;
        Ok(instance.into())
    }
}

// constructor
impl ToPyo3Ast for crate::located::PatternMatchAs {
    fn to_pyo3_ast(&self, _py: Python) -> PyResult<Py<PyAny>> {
        let class = ranged::PatternMatchAs::py_type_cell().get().unwrap();
        let instance = class.call1(
            _py,
            (self.pattern.to_pyo3_ast(_py)?, self.name.to_pyo3_ast(_py)?),
        )?;
        Ok(instance.into())
    }
}

// constructor
impl ToPyo3Ast for crate::located::PatternMatchOr {
    fn to_pyo3_ast(&self, _py: Python) -> PyResult<Py<PyAny>> {
        let class = ranged::PatternMatchOr::py_type_cell().get().unwrap();
        let instance = class.call1(_py, (self.patterns.to_pyo3_ast(_py)?,))?;
        Ok(instance.into())
    }
}

impl ToPyo3Ast for crate::located::TypeIgnore {
    fn to_pyo3_ast(&self, _py: Python) -> PyResult<Py<PyAny>> {
        let instance = match &self {
            crate::TypeIgnore::TypeIgnore(cons) => cons.to_pyo3_ast(_py)?,
        };
        Ok(instance)
    }
}

// constructor
impl ToPyo3Ast for crate::located::TypeIgnoreTypeIgnore {
    fn to_pyo3_ast(&self, _py: Python) -> PyResult<Py<PyAny>> {
        let class = ranged::TypeIgnoreTypeIgnore::py_type_cell().get().unwrap();
        let instance = class.call1(
            _py,
            (self.lineno.to_pyo3_ast(_py)?, self.tag.to_pyo3_ast(_py)?),
        )?;
        Ok(instance.into())
    }
}
