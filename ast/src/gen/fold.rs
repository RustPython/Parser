// File automatically generated by ast/asdl_rs.py.

pub trait Fold<U> {
    type TargetU;
    type Error;
    type UserContext;

    fn will_map_user(&mut self, user: &U) -> Self::UserContext;
    #[cfg(feature = "all-nodes-with-ranges")]
    fn will_map_user_cfg(&mut self, user: &U) -> Self::UserContext {
        self.will_map_user(user)
    }
    #[cfg(not(feature = "all-nodes-with-ranges"))]
    fn will_map_user_cfg(
        &mut self,
        _user: &crate::EmptyRange<U>,
    ) -> crate::EmptyRange<Self::TargetU> {
        crate::EmptyRange::default()
    }
    fn map_user(
        &mut self,
        user: U,
        context: Self::UserContext,
    ) -> Result<Self::TargetU, Self::Error>;
    #[cfg(feature = "all-nodes-with-ranges")]
    fn map_user_cfg(
        &mut self,
        user: U,
        context: Self::UserContext,
    ) -> Result<Self::TargetU, Self::Error> {
        self.map_user(user, context)
    }
    #[cfg(not(feature = "all-nodes-with-ranges"))]
    fn map_user_cfg(
        &mut self,
        _user: crate::EmptyRange<U>,
        _context: crate::EmptyRange<Self::TargetU>,
    ) -> Result<crate::EmptyRange<Self::TargetU>, Self::Error> {
        Ok(crate::EmptyRange::default())
    }

    fn fold<X: Foldable<U, Self::TargetU>>(&mut self, node: X) -> Result<X::Mapped, Self::Error> {
        node.fold(self)
    }
    fn fold_mod(&mut self, node: Mod<U>) -> Result<Mod<Self::TargetU>, Self::Error> {
        fold_mod(self, node)
    }
    fn fold_stmt(&mut self, node: Stmt<U>) -> Result<Stmt<Self::TargetU>, Self::Error> {
        fold_stmt(self, node)
    }
    fn fold_expr(&mut self, node: Expr<U>) -> Result<Expr<Self::TargetU>, Self::Error> {
        fold_expr(self, node)
    }
    fn fold_expr_context(&mut self, node: ExprContext) -> Result<ExprContext, Self::Error> {
        fold_expr_context(self, node)
    }
    fn fold_boolop(&mut self, node: Boolop) -> Result<Boolop, Self::Error> {
        fold_boolop(self, node)
    }
    fn fold_operator(&mut self, node: Operator) -> Result<Operator, Self::Error> {
        fold_operator(self, node)
    }
    fn fold_unaryop(&mut self, node: Unaryop) -> Result<Unaryop, Self::Error> {
        fold_unaryop(self, node)
    }
    fn fold_cmpop(&mut self, node: Cmpop) -> Result<Cmpop, Self::Error> {
        fold_cmpop(self, node)
    }
    fn fold_comprehension(
        &mut self,
        node: Comprehension<U>,
    ) -> Result<Comprehension<Self::TargetU>, Self::Error> {
        fold_comprehension(self, node)
    }
    fn fold_excepthandler(
        &mut self,
        node: Excepthandler<U>,
    ) -> Result<Excepthandler<Self::TargetU>, Self::Error> {
        fold_excepthandler(self, node)
    }
    fn fold_arguments(
        &mut self,
        node: Arguments<U>,
    ) -> Result<Arguments<Self::TargetU>, Self::Error> {
        fold_arguments(self, node)
    }
    fn fold_arg(&mut self, node: Arg<U>) -> Result<Arg<Self::TargetU>, Self::Error> {
        fold_arg(self, node)
    }
    fn fold_keyword(&mut self, node: Keyword<U>) -> Result<Keyword<Self::TargetU>, Self::Error> {
        fold_keyword(self, node)
    }
    fn fold_alias(&mut self, node: Alias<U>) -> Result<Alias<Self::TargetU>, Self::Error> {
        fold_alias(self, node)
    }
    fn fold_withitem(&mut self, node: Withitem<U>) -> Result<Withitem<Self::TargetU>, Self::Error> {
        fold_withitem(self, node)
    }
    fn fold_match_case(
        &mut self,
        node: MatchCase<U>,
    ) -> Result<MatchCase<Self::TargetU>, Self::Error> {
        fold_match_case(self, node)
    }
    fn fold_pattern(&mut self, node: Pattern<U>) -> Result<Pattern<Self::TargetU>, Self::Error> {
        fold_pattern(self, node)
    }
    fn fold_type_ignore(
        &mut self,
        node: TypeIgnore<U>,
    ) -> Result<TypeIgnore<Self::TargetU>, Self::Error> {
        fold_type_ignore(self, node)
    }
}
impl<T, U> Foldable<T, U> for Mod<T> {
    type Mapped = Mod<U>;
    fn fold<F: Fold<T, TargetU = U> + ?Sized>(
        self,
        folder: &mut F,
    ) -> Result<Self::Mapped, F::Error> {
        folder.fold_mod(self)
    }
}
pub fn fold_mod<U, F: Fold<U> + ?Sized>(
    #[allow(unused)] folder: &mut F,
    node: Mod<U>,
) -> Result<Mod<F::TargetU>, F::Error> {
    match node {
        Mod::Module(ModModule {
            body,
            type_ignores,
            range,
        }) => {
            let context = folder.will_map_user_cfg(&range);
            let body = Foldable::fold(body, folder)?;
            let type_ignores = Foldable::fold(type_ignores, folder)?;
            let range = folder.map_user_cfg(range, context)?;
            Ok(Mod::Module(ModModule {
                body,
                type_ignores,
                range,
            }))
        }
        Mod::Interactive(ModInteractive { body, range }) => {
            let context = folder.will_map_user_cfg(&range);
            let body = Foldable::fold(body, folder)?;
            let range = folder.map_user_cfg(range, context)?;
            Ok(Mod::Interactive(ModInteractive { body, range }))
        }
        Mod::Expression(ModExpression { body, range }) => {
            let context = folder.will_map_user_cfg(&range);
            let body = Foldable::fold(body, folder)?;
            let range = folder.map_user_cfg(range, context)?;
            Ok(Mod::Expression(ModExpression { body, range }))
        }
        Mod::FunctionType(ModFunctionType {
            argtypes,
            returns,
            range,
        }) => {
            let context = folder.will_map_user_cfg(&range);
            let argtypes = Foldable::fold(argtypes, folder)?;
            let returns = Foldable::fold(returns, folder)?;
            let range = folder.map_user_cfg(range, context)?;
            Ok(Mod::FunctionType(ModFunctionType {
                argtypes,
                returns,
                range,
            }))
        }
    }
}
impl<T, U> Foldable<T, U> for Stmt<T> {
    type Mapped = Stmt<U>;
    fn fold<F: Fold<T, TargetU = U> + ?Sized>(
        self,
        folder: &mut F,
    ) -> Result<Self::Mapped, F::Error> {
        folder.fold_stmt(self)
    }
}
pub fn fold_stmt<U, F: Fold<U> + ?Sized>(
    #[allow(unused)] folder: &mut F,
    node: Stmt<U>,
) -> Result<Stmt<F::TargetU>, F::Error> {
    match node {
        Stmt::FunctionDef(StmtFunctionDef {
            name,
            args,
            body,
            decorator_list,
            returns,
            type_comment,
            range,
        }) => {
            let context = folder.will_map_user(&range);
            let name = Foldable::fold(name, folder)?;
            let args = Foldable::fold(args, folder)?;
            let body = Foldable::fold(body, folder)?;
            let decorator_list = Foldable::fold(decorator_list, folder)?;
            let returns = Foldable::fold(returns, folder)?;
            let type_comment = Foldable::fold(type_comment, folder)?;
            let range = folder.map_user(range, context)?;
            Ok(Stmt::FunctionDef(StmtFunctionDef {
                name,
                args,
                body,
                decorator_list,
                returns,
                type_comment,
                range,
            }))
        }
        Stmt::AsyncFunctionDef(StmtAsyncFunctionDef {
            name,
            args,
            body,
            decorator_list,
            returns,
            type_comment,
            range,
        }) => {
            let context = folder.will_map_user(&range);
            let name = Foldable::fold(name, folder)?;
            let args = Foldable::fold(args, folder)?;
            let body = Foldable::fold(body, folder)?;
            let decorator_list = Foldable::fold(decorator_list, folder)?;
            let returns = Foldable::fold(returns, folder)?;
            let type_comment = Foldable::fold(type_comment, folder)?;
            let range = folder.map_user(range, context)?;
            Ok(Stmt::AsyncFunctionDef(StmtAsyncFunctionDef {
                name,
                args,
                body,
                decorator_list,
                returns,
                type_comment,
                range,
            }))
        }
        Stmt::ClassDef(StmtClassDef {
            name,
            bases,
            keywords,
            body,
            decorator_list,
            range,
        }) => {
            let context = folder.will_map_user(&range);
            let name = Foldable::fold(name, folder)?;
            let bases = Foldable::fold(bases, folder)?;
            let keywords = Foldable::fold(keywords, folder)?;
            let body = Foldable::fold(body, folder)?;
            let decorator_list = Foldable::fold(decorator_list, folder)?;
            let range = folder.map_user(range, context)?;
            Ok(Stmt::ClassDef(StmtClassDef {
                name,
                bases,
                keywords,
                body,
                decorator_list,
                range,
            }))
        }
        Stmt::Return(StmtReturn { value, range }) => {
            let context = folder.will_map_user(&range);
            let value = Foldable::fold(value, folder)?;
            let range = folder.map_user(range, context)?;
            Ok(Stmt::Return(StmtReturn { value, range }))
        }
        Stmt::Delete(StmtDelete { targets, range }) => {
            let context = folder.will_map_user(&range);
            let targets = Foldable::fold(targets, folder)?;
            let range = folder.map_user(range, context)?;
            Ok(Stmt::Delete(StmtDelete { targets, range }))
        }
        Stmt::Assign(StmtAssign {
            targets,
            value,
            type_comment,
            range,
        }) => {
            let context = folder.will_map_user(&range);
            let targets = Foldable::fold(targets, folder)?;
            let value = Foldable::fold(value, folder)?;
            let type_comment = Foldable::fold(type_comment, folder)?;
            let range = folder.map_user(range, context)?;
            Ok(Stmt::Assign(StmtAssign {
                targets,
                value,
                type_comment,
                range,
            }))
        }
        Stmt::AugAssign(StmtAugAssign {
            target,
            op,
            value,
            range,
        }) => {
            let context = folder.will_map_user(&range);
            let target = Foldable::fold(target, folder)?;
            let op = Foldable::fold(op, folder)?;
            let value = Foldable::fold(value, folder)?;
            let range = folder.map_user(range, context)?;
            Ok(Stmt::AugAssign(StmtAugAssign {
                target,
                op,
                value,
                range,
            }))
        }
        Stmt::AnnAssign(StmtAnnAssign {
            target,
            annotation,
            value,
            simple,
            range,
        }) => {
            let context = folder.will_map_user(&range);
            let target = Foldable::fold(target, folder)?;
            let annotation = Foldable::fold(annotation, folder)?;
            let value = Foldable::fold(value, folder)?;
            let simple = Foldable::fold(simple, folder)?;
            let range = folder.map_user(range, context)?;
            Ok(Stmt::AnnAssign(StmtAnnAssign {
                target,
                annotation,
                value,
                simple,
                range,
            }))
        }
        Stmt::For(StmtFor {
            target,
            iter,
            body,
            orelse,
            type_comment,
            range,
        }) => {
            let context = folder.will_map_user(&range);
            let target = Foldable::fold(target, folder)?;
            let iter = Foldable::fold(iter, folder)?;
            let body = Foldable::fold(body, folder)?;
            let orelse = Foldable::fold(orelse, folder)?;
            let type_comment = Foldable::fold(type_comment, folder)?;
            let range = folder.map_user(range, context)?;
            Ok(Stmt::For(StmtFor {
                target,
                iter,
                body,
                orelse,
                type_comment,
                range,
            }))
        }
        Stmt::AsyncFor(StmtAsyncFor {
            target,
            iter,
            body,
            orelse,
            type_comment,
            range,
        }) => {
            let context = folder.will_map_user(&range);
            let target = Foldable::fold(target, folder)?;
            let iter = Foldable::fold(iter, folder)?;
            let body = Foldable::fold(body, folder)?;
            let orelse = Foldable::fold(orelse, folder)?;
            let type_comment = Foldable::fold(type_comment, folder)?;
            let range = folder.map_user(range, context)?;
            Ok(Stmt::AsyncFor(StmtAsyncFor {
                target,
                iter,
                body,
                orelse,
                type_comment,
                range,
            }))
        }
        Stmt::While(StmtWhile {
            test,
            body,
            orelse,
            range,
        }) => {
            let context = folder.will_map_user(&range);
            let test = Foldable::fold(test, folder)?;
            let body = Foldable::fold(body, folder)?;
            let orelse = Foldable::fold(orelse, folder)?;
            let range = folder.map_user(range, context)?;
            Ok(Stmt::While(StmtWhile {
                test,
                body,
                orelse,
                range,
            }))
        }
        Stmt::If(StmtIf {
            test,
            body,
            orelse,
            range,
        }) => {
            let context = folder.will_map_user(&range);
            let test = Foldable::fold(test, folder)?;
            let body = Foldable::fold(body, folder)?;
            let orelse = Foldable::fold(orelse, folder)?;
            let range = folder.map_user(range, context)?;
            Ok(Stmt::If(StmtIf {
                test,
                body,
                orelse,
                range,
            }))
        }
        Stmt::With(StmtWith {
            items,
            body,
            type_comment,
            range,
        }) => {
            let context = folder.will_map_user(&range);
            let items = Foldable::fold(items, folder)?;
            let body = Foldable::fold(body, folder)?;
            let type_comment = Foldable::fold(type_comment, folder)?;
            let range = folder.map_user(range, context)?;
            Ok(Stmt::With(StmtWith {
                items,
                body,
                type_comment,
                range,
            }))
        }
        Stmt::AsyncWith(StmtAsyncWith {
            items,
            body,
            type_comment,
            range,
        }) => {
            let context = folder.will_map_user(&range);
            let items = Foldable::fold(items, folder)?;
            let body = Foldable::fold(body, folder)?;
            let type_comment = Foldable::fold(type_comment, folder)?;
            let range = folder.map_user(range, context)?;
            Ok(Stmt::AsyncWith(StmtAsyncWith {
                items,
                body,
                type_comment,
                range,
            }))
        }
        Stmt::Match(StmtMatch {
            subject,
            cases,
            range,
        }) => {
            let context = folder.will_map_user(&range);
            let subject = Foldable::fold(subject, folder)?;
            let cases = Foldable::fold(cases, folder)?;
            let range = folder.map_user(range, context)?;
            Ok(Stmt::Match(StmtMatch {
                subject,
                cases,
                range,
            }))
        }
        Stmt::Raise(StmtRaise { exc, cause, range }) => {
            let context = folder.will_map_user(&range);
            let exc = Foldable::fold(exc, folder)?;
            let cause = Foldable::fold(cause, folder)?;
            let range = folder.map_user(range, context)?;
            Ok(Stmt::Raise(StmtRaise { exc, cause, range }))
        }
        Stmt::Try(StmtTry {
            body,
            handlers,
            orelse,
            finalbody,
            range,
        }) => {
            let context = folder.will_map_user(&range);
            let body = Foldable::fold(body, folder)?;
            let handlers = Foldable::fold(handlers, folder)?;
            let orelse = Foldable::fold(orelse, folder)?;
            let finalbody = Foldable::fold(finalbody, folder)?;
            let range = folder.map_user(range, context)?;
            Ok(Stmt::Try(StmtTry {
                body,
                handlers,
                orelse,
                finalbody,
                range,
            }))
        }
        Stmt::TryStar(StmtTryStar {
            body,
            handlers,
            orelse,
            finalbody,
            range,
        }) => {
            let context = folder.will_map_user(&range);
            let body = Foldable::fold(body, folder)?;
            let handlers = Foldable::fold(handlers, folder)?;
            let orelse = Foldable::fold(orelse, folder)?;
            let finalbody = Foldable::fold(finalbody, folder)?;
            let range = folder.map_user(range, context)?;
            Ok(Stmt::TryStar(StmtTryStar {
                body,
                handlers,
                orelse,
                finalbody,
                range,
            }))
        }
        Stmt::Assert(StmtAssert { test, msg, range }) => {
            let context = folder.will_map_user(&range);
            let test = Foldable::fold(test, folder)?;
            let msg = Foldable::fold(msg, folder)?;
            let range = folder.map_user(range, context)?;
            Ok(Stmt::Assert(StmtAssert { test, msg, range }))
        }
        Stmt::Import(StmtImport { names, range }) => {
            let context = folder.will_map_user(&range);
            let names = Foldable::fold(names, folder)?;
            let range = folder.map_user(range, context)?;
            Ok(Stmt::Import(StmtImport { names, range }))
        }
        Stmt::ImportFrom(StmtImportFrom {
            module,
            names,
            level,
            range,
        }) => {
            let context = folder.will_map_user(&range);
            let module = Foldable::fold(module, folder)?;
            let names = Foldable::fold(names, folder)?;
            let level = Foldable::fold(level, folder)?;
            let range = folder.map_user(range, context)?;
            Ok(Stmt::ImportFrom(StmtImportFrom {
                module,
                names,
                level,
                range,
            }))
        }
        Stmt::Global(StmtGlobal { names, range }) => {
            let context = folder.will_map_user(&range);
            let names = Foldable::fold(names, folder)?;
            let range = folder.map_user(range, context)?;
            Ok(Stmt::Global(StmtGlobal { names, range }))
        }
        Stmt::Nonlocal(StmtNonlocal { names, range }) => {
            let context = folder.will_map_user(&range);
            let names = Foldable::fold(names, folder)?;
            let range = folder.map_user(range, context)?;
            Ok(Stmt::Nonlocal(StmtNonlocal { names, range }))
        }
        Stmt::Expr(StmtExpr { value, range }) => {
            let context = folder.will_map_user(&range);
            let value = Foldable::fold(value, folder)?;
            let range = folder.map_user(range, context)?;
            Ok(Stmt::Expr(StmtExpr { value, range }))
        }
        Stmt::Pass(StmtPass { range }) => {
            let context = folder.will_map_user(&range);
            let range = folder.map_user(range, context)?;
            Ok(Stmt::Pass(StmtPass { range }))
        }
        Stmt::Break(StmtBreak { range }) => {
            let context = folder.will_map_user(&range);
            let range = folder.map_user(range, context)?;
            Ok(Stmt::Break(StmtBreak { range }))
        }
        Stmt::Continue(StmtContinue { range }) => {
            let context = folder.will_map_user(&range);
            let range = folder.map_user(range, context)?;
            Ok(Stmt::Continue(StmtContinue { range }))
        }
    }
}
impl<T, U> Foldable<T, U> for Expr<T> {
    type Mapped = Expr<U>;
    fn fold<F: Fold<T, TargetU = U> + ?Sized>(
        self,
        folder: &mut F,
    ) -> Result<Self::Mapped, F::Error> {
        folder.fold_expr(self)
    }
}
pub fn fold_expr<U, F: Fold<U> + ?Sized>(
    #[allow(unused)] folder: &mut F,
    node: Expr<U>,
) -> Result<Expr<F::TargetU>, F::Error> {
    match node {
        Expr::BoolOp(ExprBoolOp { op, values, range }) => {
            let context = folder.will_map_user(&range);
            let op = Foldable::fold(op, folder)?;
            let values = Foldable::fold(values, folder)?;
            let range = folder.map_user(range, context)?;
            Ok(Expr::BoolOp(ExprBoolOp { op, values, range }))
        }
        Expr::NamedExpr(ExprNamedExpr {
            target,
            value,
            range,
        }) => {
            let context = folder.will_map_user(&range);
            let target = Foldable::fold(target, folder)?;
            let value = Foldable::fold(value, folder)?;
            let range = folder.map_user(range, context)?;
            Ok(Expr::NamedExpr(ExprNamedExpr {
                target,
                value,
                range,
            }))
        }
        Expr::BinOp(ExprBinOp {
            left,
            op,
            right,
            range,
        }) => {
            let context = folder.will_map_user(&range);
            let left = Foldable::fold(left, folder)?;
            let op = Foldable::fold(op, folder)?;
            let right = Foldable::fold(right, folder)?;
            let range = folder.map_user(range, context)?;
            Ok(Expr::BinOp(ExprBinOp {
                left,
                op,
                right,
                range,
            }))
        }
        Expr::UnaryOp(ExprUnaryOp { op, operand, range }) => {
            let context = folder.will_map_user(&range);
            let op = Foldable::fold(op, folder)?;
            let operand = Foldable::fold(operand, folder)?;
            let range = folder.map_user(range, context)?;
            Ok(Expr::UnaryOp(ExprUnaryOp { op, operand, range }))
        }
        Expr::Lambda(ExprLambda { args, body, range }) => {
            let context = folder.will_map_user(&range);
            let args = Foldable::fold(args, folder)?;
            let body = Foldable::fold(body, folder)?;
            let range = folder.map_user(range, context)?;
            Ok(Expr::Lambda(ExprLambda { args, body, range }))
        }
        Expr::IfExp(ExprIfExp {
            test,
            body,
            orelse,
            range,
        }) => {
            let context = folder.will_map_user(&range);
            let test = Foldable::fold(test, folder)?;
            let body = Foldable::fold(body, folder)?;
            let orelse = Foldable::fold(orelse, folder)?;
            let range = folder.map_user(range, context)?;
            Ok(Expr::IfExp(ExprIfExp {
                test,
                body,
                orelse,
                range,
            }))
        }
        Expr::Dict(ExprDict {
            keys,
            values,
            range,
        }) => {
            let context = folder.will_map_user(&range);
            let keys = Foldable::fold(keys, folder)?;
            let values = Foldable::fold(values, folder)?;
            let range = folder.map_user(range, context)?;
            Ok(Expr::Dict(ExprDict {
                keys,
                values,
                range,
            }))
        }
        Expr::Set(ExprSet { elts, range }) => {
            let context = folder.will_map_user(&range);
            let elts = Foldable::fold(elts, folder)?;
            let range = folder.map_user(range, context)?;
            Ok(Expr::Set(ExprSet { elts, range }))
        }
        Expr::ListComp(ExprListComp {
            elt,
            generators,
            range,
        }) => {
            let context = folder.will_map_user(&range);
            let elt = Foldable::fold(elt, folder)?;
            let generators = Foldable::fold(generators, folder)?;
            let range = folder.map_user(range, context)?;
            Ok(Expr::ListComp(ExprListComp {
                elt,
                generators,
                range,
            }))
        }
        Expr::SetComp(ExprSetComp {
            elt,
            generators,
            range,
        }) => {
            let context = folder.will_map_user(&range);
            let elt = Foldable::fold(elt, folder)?;
            let generators = Foldable::fold(generators, folder)?;
            let range = folder.map_user(range, context)?;
            Ok(Expr::SetComp(ExprSetComp {
                elt,
                generators,
                range,
            }))
        }
        Expr::DictComp(ExprDictComp {
            key,
            value,
            generators,
            range,
        }) => {
            let context = folder.will_map_user(&range);
            let key = Foldable::fold(key, folder)?;
            let value = Foldable::fold(value, folder)?;
            let generators = Foldable::fold(generators, folder)?;
            let range = folder.map_user(range, context)?;
            Ok(Expr::DictComp(ExprDictComp {
                key,
                value,
                generators,
                range,
            }))
        }
        Expr::GeneratorExp(ExprGeneratorExp {
            elt,
            generators,
            range,
        }) => {
            let context = folder.will_map_user(&range);
            let elt = Foldable::fold(elt, folder)?;
            let generators = Foldable::fold(generators, folder)?;
            let range = folder.map_user(range, context)?;
            Ok(Expr::GeneratorExp(ExprGeneratorExp {
                elt,
                generators,
                range,
            }))
        }
        Expr::Await(ExprAwait { value, range }) => {
            let context = folder.will_map_user(&range);
            let value = Foldable::fold(value, folder)?;
            let range = folder.map_user(range, context)?;
            Ok(Expr::Await(ExprAwait { value, range }))
        }
        Expr::Yield(ExprYield { value, range }) => {
            let context = folder.will_map_user(&range);
            let value = Foldable::fold(value, folder)?;
            let range = folder.map_user(range, context)?;
            Ok(Expr::Yield(ExprYield { value, range }))
        }
        Expr::YieldFrom(ExprYieldFrom { value, range }) => {
            let context = folder.will_map_user(&range);
            let value = Foldable::fold(value, folder)?;
            let range = folder.map_user(range, context)?;
            Ok(Expr::YieldFrom(ExprYieldFrom { value, range }))
        }
        Expr::Compare(ExprCompare {
            left,
            ops,
            comparators,
            range,
        }) => {
            let context = folder.will_map_user(&range);
            let left = Foldable::fold(left, folder)?;
            let ops = Foldable::fold(ops, folder)?;
            let comparators = Foldable::fold(comparators, folder)?;
            let range = folder.map_user(range, context)?;
            Ok(Expr::Compare(ExprCompare {
                left,
                ops,
                comparators,
                range,
            }))
        }
        Expr::Call(ExprCall {
            func,
            args,
            keywords,
            range,
        }) => {
            let context = folder.will_map_user(&range);
            let func = Foldable::fold(func, folder)?;
            let args = Foldable::fold(args, folder)?;
            let keywords = Foldable::fold(keywords, folder)?;
            let range = folder.map_user(range, context)?;
            Ok(Expr::Call(ExprCall {
                func,
                args,
                keywords,
                range,
            }))
        }
        Expr::FormattedValue(ExprFormattedValue {
            value,
            conversion,
            format_spec,
            range,
        }) => {
            let context = folder.will_map_user(&range);
            let value = Foldable::fold(value, folder)?;
            let conversion = Foldable::fold(conversion, folder)?;
            let format_spec = Foldable::fold(format_spec, folder)?;
            let range = folder.map_user(range, context)?;
            Ok(Expr::FormattedValue(ExprFormattedValue {
                value,
                conversion,
                format_spec,
                range,
            }))
        }
        Expr::JoinedStr(ExprJoinedStr { values, range }) => {
            let context = folder.will_map_user(&range);
            let values = Foldable::fold(values, folder)?;
            let range = folder.map_user(range, context)?;
            Ok(Expr::JoinedStr(ExprJoinedStr { values, range }))
        }
        Expr::Constant(ExprConstant { value, kind, range }) => {
            let context = folder.will_map_user(&range);
            let value = Foldable::fold(value, folder)?;
            let kind = Foldable::fold(kind, folder)?;
            let range = folder.map_user(range, context)?;
            Ok(Expr::Constant(ExprConstant { value, kind, range }))
        }
        Expr::Attribute(ExprAttribute {
            value,
            attr,
            ctx,
            range,
        }) => {
            let context = folder.will_map_user(&range);
            let value = Foldable::fold(value, folder)?;
            let attr = Foldable::fold(attr, folder)?;
            let ctx = Foldable::fold(ctx, folder)?;
            let range = folder.map_user(range, context)?;
            Ok(Expr::Attribute(ExprAttribute {
                value,
                attr,
                ctx,
                range,
            }))
        }
        Expr::Subscript(ExprSubscript {
            value,
            slice,
            ctx,
            range,
        }) => {
            let context = folder.will_map_user(&range);
            let value = Foldable::fold(value, folder)?;
            let slice = Foldable::fold(slice, folder)?;
            let ctx = Foldable::fold(ctx, folder)?;
            let range = folder.map_user(range, context)?;
            Ok(Expr::Subscript(ExprSubscript {
                value,
                slice,
                ctx,
                range,
            }))
        }
        Expr::Starred(ExprStarred { value, ctx, range }) => {
            let context = folder.will_map_user(&range);
            let value = Foldable::fold(value, folder)?;
            let ctx = Foldable::fold(ctx, folder)?;
            let range = folder.map_user(range, context)?;
            Ok(Expr::Starred(ExprStarred { value, ctx, range }))
        }
        Expr::Name(ExprName { id, ctx, range }) => {
            let context = folder.will_map_user(&range);
            let id = Foldable::fold(id, folder)?;
            let ctx = Foldable::fold(ctx, folder)?;
            let range = folder.map_user(range, context)?;
            Ok(Expr::Name(ExprName { id, ctx, range }))
        }
        Expr::List(ExprList { elts, ctx, range }) => {
            let context = folder.will_map_user(&range);
            let elts = Foldable::fold(elts, folder)?;
            let ctx = Foldable::fold(ctx, folder)?;
            let range = folder.map_user(range, context)?;
            Ok(Expr::List(ExprList { elts, ctx, range }))
        }
        Expr::Tuple(ExprTuple { elts, ctx, range }) => {
            let context = folder.will_map_user(&range);
            let elts = Foldable::fold(elts, folder)?;
            let ctx = Foldable::fold(ctx, folder)?;
            let range = folder.map_user(range, context)?;
            Ok(Expr::Tuple(ExprTuple { elts, ctx, range }))
        }
        Expr::Slice(ExprSlice {
            lower,
            upper,
            step,
            range,
        }) => {
            let context = folder.will_map_user(&range);
            let lower = Foldable::fold(lower, folder)?;
            let upper = Foldable::fold(upper, folder)?;
            let step = Foldable::fold(step, folder)?;
            let range = folder.map_user(range, context)?;
            Ok(Expr::Slice(ExprSlice {
                lower,
                upper,
                step,
                range,
            }))
        }
    }
}
impl<T, U> Foldable<T, U> for ExprContext {
    type Mapped = ExprContext;
    fn fold<F: Fold<T, TargetU = U> + ?Sized>(
        self,
        folder: &mut F,
    ) -> Result<Self::Mapped, F::Error> {
        folder.fold_expr_context(self)
    }
}
pub fn fold_expr_context<U, F: Fold<U> + ?Sized>(
    #[allow(unused)] folder: &mut F,
    node: ExprContext,
) -> Result<ExprContext, F::Error> {
    Ok(node)
}
impl<T, U> Foldable<T, U> for Boolop {
    type Mapped = Boolop;
    fn fold<F: Fold<T, TargetU = U> + ?Sized>(
        self,
        folder: &mut F,
    ) -> Result<Self::Mapped, F::Error> {
        folder.fold_boolop(self)
    }
}
pub fn fold_boolop<U, F: Fold<U> + ?Sized>(
    #[allow(unused)] folder: &mut F,
    node: Boolop,
) -> Result<Boolop, F::Error> {
    Ok(node)
}
impl<T, U> Foldable<T, U> for Operator {
    type Mapped = Operator;
    fn fold<F: Fold<T, TargetU = U> + ?Sized>(
        self,
        folder: &mut F,
    ) -> Result<Self::Mapped, F::Error> {
        folder.fold_operator(self)
    }
}
pub fn fold_operator<U, F: Fold<U> + ?Sized>(
    #[allow(unused)] folder: &mut F,
    node: Operator,
) -> Result<Operator, F::Error> {
    Ok(node)
}
impl<T, U> Foldable<T, U> for Unaryop {
    type Mapped = Unaryop;
    fn fold<F: Fold<T, TargetU = U> + ?Sized>(
        self,
        folder: &mut F,
    ) -> Result<Self::Mapped, F::Error> {
        folder.fold_unaryop(self)
    }
}
pub fn fold_unaryop<U, F: Fold<U> + ?Sized>(
    #[allow(unused)] folder: &mut F,
    node: Unaryop,
) -> Result<Unaryop, F::Error> {
    Ok(node)
}
impl<T, U> Foldable<T, U> for Cmpop {
    type Mapped = Cmpop;
    fn fold<F: Fold<T, TargetU = U> + ?Sized>(
        self,
        folder: &mut F,
    ) -> Result<Self::Mapped, F::Error> {
        folder.fold_cmpop(self)
    }
}
pub fn fold_cmpop<U, F: Fold<U> + ?Sized>(
    #[allow(unused)] folder: &mut F,
    node: Cmpop,
) -> Result<Cmpop, F::Error> {
    Ok(node)
}
impl<T, U> Foldable<T, U> for Comprehension<T> {
    type Mapped = Comprehension<U>;
    fn fold<F: Fold<T, TargetU = U> + ?Sized>(
        self,
        folder: &mut F,
    ) -> Result<Self::Mapped, F::Error> {
        folder.fold_comprehension(self)
    }
}
pub fn fold_comprehension<U, F: Fold<U> + ?Sized>(
    #[allow(unused)] folder: &mut F,
    node: Comprehension<U>,
) -> Result<Comprehension<F::TargetU>, F::Error> {
    let Comprehension {
        target,
        iter,
        ifs,
        is_async,
        range,
    } = node;
    let context = folder.will_map_user_cfg(&range);
    let target = Foldable::fold(target, folder)?;
    let iter = Foldable::fold(iter, folder)?;
    let ifs = Foldable::fold(ifs, folder)?;
    let is_async = Foldable::fold(is_async, folder)?;
    let range = folder.map_user_cfg(range, context)?;
    Ok(Comprehension {
        target,
        iter,
        ifs,
        is_async,
        range,
    })
}
impl<T, U> Foldable<T, U> for Excepthandler<T> {
    type Mapped = Excepthandler<U>;
    fn fold<F: Fold<T, TargetU = U> + ?Sized>(
        self,
        folder: &mut F,
    ) -> Result<Self::Mapped, F::Error> {
        folder.fold_excepthandler(self)
    }
}
pub fn fold_excepthandler<U, F: Fold<U> + ?Sized>(
    #[allow(unused)] folder: &mut F,
    node: Excepthandler<U>,
) -> Result<Excepthandler<F::TargetU>, F::Error> {
    match node {
        Excepthandler::ExceptHandler(ExcepthandlerExceptHandler {
            type_,
            name,
            body,
            range,
        }) => {
            let context = folder.will_map_user(&range);
            let type_ = Foldable::fold(type_, folder)?;
            let name = Foldable::fold(name, folder)?;
            let body = Foldable::fold(body, folder)?;
            let range = folder.map_user(range, context)?;
            Ok(Excepthandler::ExceptHandler(ExcepthandlerExceptHandler {
                type_,
                name,
                body,
                range,
            }))
        }
    }
}
impl<T, U> Foldable<T, U> for Arguments<T> {
    type Mapped = Arguments<U>;
    fn fold<F: Fold<T, TargetU = U> + ?Sized>(
        self,
        folder: &mut F,
    ) -> Result<Self::Mapped, F::Error> {
        folder.fold_arguments(self)
    }
}
pub fn fold_arguments<U, F: Fold<U> + ?Sized>(
    #[allow(unused)] folder: &mut F,
    node: Arguments<U>,
) -> Result<Arguments<F::TargetU>, F::Error> {
    let Arguments {
        posonlyargs,
        args,
        vararg,
        kwonlyargs,
        kw_defaults,
        kwarg,
        defaults,
        range,
    } = node;
    let context = folder.will_map_user_cfg(&range);
    let posonlyargs = Foldable::fold(posonlyargs, folder)?;
    let args = Foldable::fold(args, folder)?;
    let vararg = Foldable::fold(vararg, folder)?;
    let kwonlyargs = Foldable::fold(kwonlyargs, folder)?;
    let kw_defaults = Foldable::fold(kw_defaults, folder)?;
    let kwarg = Foldable::fold(kwarg, folder)?;
    let defaults = Foldable::fold(defaults, folder)?;
    let range = folder.map_user_cfg(range, context)?;
    Ok(Arguments {
        posonlyargs,
        args,
        vararg,
        kwonlyargs,
        kw_defaults,
        kwarg,
        defaults,
        range,
    })
}
impl<T, U> Foldable<T, U> for Arg<T> {
    type Mapped = Arg<U>;
    fn fold<F: Fold<T, TargetU = U> + ?Sized>(
        self,
        folder: &mut F,
    ) -> Result<Self::Mapped, F::Error> {
        folder.fold_arg(self)
    }
}
pub fn fold_arg<U, F: Fold<U> + ?Sized>(
    #[allow(unused)] folder: &mut F,
    node: Arg<U>,
) -> Result<Arg<F::TargetU>, F::Error> {
    let Arg {
        arg,
        annotation,
        type_comment,
        range,
    } = node;
    let context = folder.will_map_user(&range);
    let arg = Foldable::fold(arg, folder)?;
    let annotation = Foldable::fold(annotation, folder)?;
    let type_comment = Foldable::fold(type_comment, folder)?;
    let range = folder.map_user(range, context)?;
    Ok(Arg {
        arg,
        annotation,
        type_comment,
        range,
    })
}
impl<T, U> Foldable<T, U> for Keyword<T> {
    type Mapped = Keyword<U>;
    fn fold<F: Fold<T, TargetU = U> + ?Sized>(
        self,
        folder: &mut F,
    ) -> Result<Self::Mapped, F::Error> {
        folder.fold_keyword(self)
    }
}
pub fn fold_keyword<U, F: Fold<U> + ?Sized>(
    #[allow(unused)] folder: &mut F,
    node: Keyword<U>,
) -> Result<Keyword<F::TargetU>, F::Error> {
    let Keyword { arg, value, range } = node;
    let context = folder.will_map_user(&range);
    let arg = Foldable::fold(arg, folder)?;
    let value = Foldable::fold(value, folder)?;
    let range = folder.map_user(range, context)?;
    Ok(Keyword { arg, value, range })
}
impl<T, U> Foldable<T, U> for Alias<T> {
    type Mapped = Alias<U>;
    fn fold<F: Fold<T, TargetU = U> + ?Sized>(
        self,
        folder: &mut F,
    ) -> Result<Self::Mapped, F::Error> {
        folder.fold_alias(self)
    }
}
pub fn fold_alias<U, F: Fold<U> + ?Sized>(
    #[allow(unused)] folder: &mut F,
    node: Alias<U>,
) -> Result<Alias<F::TargetU>, F::Error> {
    let Alias {
        name,
        asname,
        range,
    } = node;
    let context = folder.will_map_user(&range);
    let name = Foldable::fold(name, folder)?;
    let asname = Foldable::fold(asname, folder)?;
    let range = folder.map_user(range, context)?;
    Ok(Alias {
        name,
        asname,
        range,
    })
}
impl<T, U> Foldable<T, U> for Withitem<T> {
    type Mapped = Withitem<U>;
    fn fold<F: Fold<T, TargetU = U> + ?Sized>(
        self,
        folder: &mut F,
    ) -> Result<Self::Mapped, F::Error> {
        folder.fold_withitem(self)
    }
}
pub fn fold_withitem<U, F: Fold<U> + ?Sized>(
    #[allow(unused)] folder: &mut F,
    node: Withitem<U>,
) -> Result<Withitem<F::TargetU>, F::Error> {
    let Withitem {
        context_expr,
        optional_vars,
        range,
    } = node;
    let context = folder.will_map_user_cfg(&range);
    let context_expr = Foldable::fold(context_expr, folder)?;
    let optional_vars = Foldable::fold(optional_vars, folder)?;
    let range = folder.map_user_cfg(range, context)?;
    Ok(Withitem {
        context_expr,
        optional_vars,
        range,
    })
}
impl<T, U> Foldable<T, U> for MatchCase<T> {
    type Mapped = MatchCase<U>;
    fn fold<F: Fold<T, TargetU = U> + ?Sized>(
        self,
        folder: &mut F,
    ) -> Result<Self::Mapped, F::Error> {
        folder.fold_match_case(self)
    }
}
pub fn fold_match_case<U, F: Fold<U> + ?Sized>(
    #[allow(unused)] folder: &mut F,
    node: MatchCase<U>,
) -> Result<MatchCase<F::TargetU>, F::Error> {
    let MatchCase {
        pattern,
        guard,
        body,
        range,
    } = node;
    let context = folder.will_map_user_cfg(&range);
    let pattern = Foldable::fold(pattern, folder)?;
    let guard = Foldable::fold(guard, folder)?;
    let body = Foldable::fold(body, folder)?;
    let range = folder.map_user_cfg(range, context)?;
    Ok(MatchCase {
        pattern,
        guard,
        body,
        range,
    })
}
impl<T, U> Foldable<T, U> for Pattern<T> {
    type Mapped = Pattern<U>;
    fn fold<F: Fold<T, TargetU = U> + ?Sized>(
        self,
        folder: &mut F,
    ) -> Result<Self::Mapped, F::Error> {
        folder.fold_pattern(self)
    }
}
pub fn fold_pattern<U, F: Fold<U> + ?Sized>(
    #[allow(unused)] folder: &mut F,
    node: Pattern<U>,
) -> Result<Pattern<F::TargetU>, F::Error> {
    match node {
        Pattern::MatchValue(PatternMatchValue { value, range }) => {
            let context = folder.will_map_user(&range);
            let value = Foldable::fold(value, folder)?;
            let range = folder.map_user(range, context)?;
            Ok(Pattern::MatchValue(PatternMatchValue { value, range }))
        }
        Pattern::MatchSingleton(PatternMatchSingleton { value, range }) => {
            let context = folder.will_map_user(&range);
            let value = Foldable::fold(value, folder)?;
            let range = folder.map_user(range, context)?;
            Ok(Pattern::MatchSingleton(PatternMatchSingleton {
                value,
                range,
            }))
        }
        Pattern::MatchSequence(PatternMatchSequence { patterns, range }) => {
            let context = folder.will_map_user(&range);
            let patterns = Foldable::fold(patterns, folder)?;
            let range = folder.map_user(range, context)?;
            Ok(Pattern::MatchSequence(PatternMatchSequence {
                patterns,
                range,
            }))
        }
        Pattern::MatchMapping(PatternMatchMapping {
            keys,
            patterns,
            rest,
            range,
        }) => {
            let context = folder.will_map_user(&range);
            let keys = Foldable::fold(keys, folder)?;
            let patterns = Foldable::fold(patterns, folder)?;
            let rest = Foldable::fold(rest, folder)?;
            let range = folder.map_user(range, context)?;
            Ok(Pattern::MatchMapping(PatternMatchMapping {
                keys,
                patterns,
                rest,
                range,
            }))
        }
        Pattern::MatchClass(PatternMatchClass {
            cls,
            patterns,
            kwd_attrs,
            kwd_patterns,
            range,
        }) => {
            let context = folder.will_map_user(&range);
            let cls = Foldable::fold(cls, folder)?;
            let patterns = Foldable::fold(patterns, folder)?;
            let kwd_attrs = Foldable::fold(kwd_attrs, folder)?;
            let kwd_patterns = Foldable::fold(kwd_patterns, folder)?;
            let range = folder.map_user(range, context)?;
            Ok(Pattern::MatchClass(PatternMatchClass {
                cls,
                patterns,
                kwd_attrs,
                kwd_patterns,
                range,
            }))
        }
        Pattern::MatchStar(PatternMatchStar { name, range }) => {
            let context = folder.will_map_user(&range);
            let name = Foldable::fold(name, folder)?;
            let range = folder.map_user(range, context)?;
            Ok(Pattern::MatchStar(PatternMatchStar { name, range }))
        }
        Pattern::MatchAs(PatternMatchAs {
            pattern,
            name,
            range,
        }) => {
            let context = folder.will_map_user(&range);
            let pattern = Foldable::fold(pattern, folder)?;
            let name = Foldable::fold(name, folder)?;
            let range = folder.map_user(range, context)?;
            Ok(Pattern::MatchAs(PatternMatchAs {
                pattern,
                name,
                range,
            }))
        }
        Pattern::MatchOr(PatternMatchOr { patterns, range }) => {
            let context = folder.will_map_user(&range);
            let patterns = Foldable::fold(patterns, folder)?;
            let range = folder.map_user(range, context)?;
            Ok(Pattern::MatchOr(PatternMatchOr { patterns, range }))
        }
    }
}
impl<T, U> Foldable<T, U> for TypeIgnore<T> {
    type Mapped = TypeIgnore<U>;
    fn fold<F: Fold<T, TargetU = U> + ?Sized>(
        self,
        folder: &mut F,
    ) -> Result<Self::Mapped, F::Error> {
        folder.fold_type_ignore(self)
    }
}
pub fn fold_type_ignore<U, F: Fold<U> + ?Sized>(
    #[allow(unused)] folder: &mut F,
    node: TypeIgnore<U>,
) -> Result<TypeIgnore<F::TargetU>, F::Error> {
    match node {
        TypeIgnore::TypeIgnore(TypeIgnoreTypeIgnore { lineno, tag, range }) => {
            let context = folder.will_map_user_cfg(&range);
            let lineno = Foldable::fold(lineno, folder)?;
            let tag = Foldable::fold(tag, folder)?;
            let range = folder.map_user_cfg(range, context)?;
            Ok(TypeIgnore::TypeIgnore(TypeIgnoreTypeIgnore {
                lineno,
                tag,
                range,
            }))
        }
    }
}
