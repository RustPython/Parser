// File automatically generated by ast/asdl_rs.py.

#[derive(Clone, Debug, PartialEq)]
pub struct ModModule<U> {
    pub body: Vec<Stmt<U>>,
    pub type_ignores: Vec<TypeIgnore<U>>,
    #[cfg(feature = "more-attributes")]
    pub custom: U,
    #[cfg(not(feature = "more-attributes"))]
    pub custom: std::marker::PhantomData<U>,
}

impl<U> From<ModModule<U>> for Mod<U> {
    fn from(payload: ModModule<U>) -> Self {
        Mod::Module(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct ModInteractive<U> {
    pub body: Vec<Stmt<U>>,
    #[cfg(feature = "more-attributes")]
    pub custom: U,
    #[cfg(not(feature = "more-attributes"))]
    pub custom: std::marker::PhantomData<U>,
}

impl<U> From<ModInteractive<U>> for Mod<U> {
    fn from(payload: ModInteractive<U>) -> Self {
        Mod::Interactive(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct ModExpression<U> {
    pub body: Box<Expr<U>>,
    #[cfg(feature = "more-attributes")]
    pub custom: U,
    #[cfg(not(feature = "more-attributes"))]
    pub custom: std::marker::PhantomData<U>,
}

impl<U> From<ModExpression<U>> for Mod<U> {
    fn from(payload: ModExpression<U>) -> Self {
        Mod::Expression(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct ModFunctionType<U> {
    pub argtypes: Vec<Expr<U>>,
    pub returns: Box<Expr<U>>,
    #[cfg(feature = "more-attributes")]
    pub custom: U,
    #[cfg(not(feature = "more-attributes"))]
    pub custom: std::marker::PhantomData<U>,
}

impl<U> From<ModFunctionType<U>> for Mod<U> {
    fn from(payload: ModFunctionType<U>) -> Self {
        Mod::FunctionType(payload)
    }
}

#[derive(Clone, Debug, PartialEq, is_macro::Is)]
pub enum Mod<U> {
    Module(ModModule<U>),
    Interactive(ModInteractive<U>),
    Expression(ModExpression<U>),
    FunctionType(ModFunctionType<U>),
}

#[derive(Clone, Debug, PartialEq)]
pub struct StmtFunctionDef<U> {
    pub name: Identifier,
    pub args: Box<Arguments<U>>,
    pub body: Vec<Stmt<U>>,
    pub decorator_list: Vec<Expr<U>>,
    pub returns: Option<Box<Expr<U>>>,
    pub type_comment: Option<String>,
    pub custom: U,
}

impl<U> From<StmtFunctionDef<U>> for Stmt<U> {
    fn from(payload: StmtFunctionDef<U>) -> Self {
        Stmt::FunctionDef(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct StmtAsyncFunctionDef<U> {
    pub name: Identifier,
    pub args: Box<Arguments<U>>,
    pub body: Vec<Stmt<U>>,
    pub decorator_list: Vec<Expr<U>>,
    pub returns: Option<Box<Expr<U>>>,
    pub type_comment: Option<String>,
    pub custom: U,
}

impl<U> From<StmtAsyncFunctionDef<U>> for Stmt<U> {
    fn from(payload: StmtAsyncFunctionDef<U>) -> Self {
        Stmt::AsyncFunctionDef(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct StmtClassDef<U> {
    pub name: Identifier,
    pub bases: Vec<Expr<U>>,
    pub keywords: Vec<Keyword<U>>,
    pub body: Vec<Stmt<U>>,
    pub decorator_list: Vec<Expr<U>>,
    pub custom: U,
}

impl<U> From<StmtClassDef<U>> for Stmt<U> {
    fn from(payload: StmtClassDef<U>) -> Self {
        Stmt::ClassDef(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct StmtReturn<U> {
    pub value: Option<Box<Expr<U>>>,
    pub custom: U,
}

impl<U> From<StmtReturn<U>> for Stmt<U> {
    fn from(payload: StmtReturn<U>) -> Self {
        Stmt::Return(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct StmtDelete<U> {
    pub targets: Vec<Expr<U>>,
    pub custom: U,
}

impl<U> From<StmtDelete<U>> for Stmt<U> {
    fn from(payload: StmtDelete<U>) -> Self {
        Stmt::Delete(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct StmtAssign<U> {
    pub targets: Vec<Expr<U>>,
    pub value: Box<Expr<U>>,
    pub type_comment: Option<String>,
    pub custom: U,
}

impl<U> From<StmtAssign<U>> for Stmt<U> {
    fn from(payload: StmtAssign<U>) -> Self {
        Stmt::Assign(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct StmtAugAssign<U> {
    pub target: Box<Expr<U>>,
    pub op: Operator,
    pub value: Box<Expr<U>>,
    pub custom: U,
}

impl<U> From<StmtAugAssign<U>> for Stmt<U> {
    fn from(payload: StmtAugAssign<U>) -> Self {
        Stmt::AugAssign(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct StmtAnnAssign<U> {
    pub target: Box<Expr<U>>,
    pub annotation: Box<Expr<U>>,
    pub value: Option<Box<Expr<U>>>,
    pub simple: bool,
    pub custom: U,
}

impl<U> From<StmtAnnAssign<U>> for Stmt<U> {
    fn from(payload: StmtAnnAssign<U>) -> Self {
        Stmt::AnnAssign(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct StmtFor<U> {
    pub target: Box<Expr<U>>,
    pub iter: Box<Expr<U>>,
    pub body: Vec<Stmt<U>>,
    pub orelse: Vec<Stmt<U>>,
    pub type_comment: Option<String>,
    pub custom: U,
}

impl<U> From<StmtFor<U>> for Stmt<U> {
    fn from(payload: StmtFor<U>) -> Self {
        Stmt::For(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct StmtAsyncFor<U> {
    pub target: Box<Expr<U>>,
    pub iter: Box<Expr<U>>,
    pub body: Vec<Stmt<U>>,
    pub orelse: Vec<Stmt<U>>,
    pub type_comment: Option<String>,
    pub custom: U,
}

impl<U> From<StmtAsyncFor<U>> for Stmt<U> {
    fn from(payload: StmtAsyncFor<U>) -> Self {
        Stmt::AsyncFor(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct StmtWhile<U> {
    pub test: Box<Expr<U>>,
    pub body: Vec<Stmt<U>>,
    pub orelse: Vec<Stmt<U>>,
    pub custom: U,
}

impl<U> From<StmtWhile<U>> for Stmt<U> {
    fn from(payload: StmtWhile<U>) -> Self {
        Stmt::While(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct StmtIf<U> {
    pub test: Box<Expr<U>>,
    pub body: Vec<Stmt<U>>,
    pub orelse: Vec<Stmt<U>>,
    pub custom: U,
}

impl<U> From<StmtIf<U>> for Stmt<U> {
    fn from(payload: StmtIf<U>) -> Self {
        Stmt::If(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct StmtWith<U> {
    pub items: Vec<Withitem<U>>,
    pub body: Vec<Stmt<U>>,
    pub type_comment: Option<String>,
    pub custom: U,
}

impl<U> From<StmtWith<U>> for Stmt<U> {
    fn from(payload: StmtWith<U>) -> Self {
        Stmt::With(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct StmtAsyncWith<U> {
    pub items: Vec<Withitem<U>>,
    pub body: Vec<Stmt<U>>,
    pub type_comment: Option<String>,
    pub custom: U,
}

impl<U> From<StmtAsyncWith<U>> for Stmt<U> {
    fn from(payload: StmtAsyncWith<U>) -> Self {
        Stmt::AsyncWith(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct StmtMatch<U> {
    pub subject: Box<Expr<U>>,
    pub cases: Vec<MatchCase<U>>,
    pub custom: U,
}

impl<U> From<StmtMatch<U>> for Stmt<U> {
    fn from(payload: StmtMatch<U>) -> Self {
        Stmt::Match(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct StmtRaise<U> {
    pub exc: Option<Box<Expr<U>>>,
    pub cause: Option<Box<Expr<U>>>,
    pub custom: U,
}

impl<U> From<StmtRaise<U>> for Stmt<U> {
    fn from(payload: StmtRaise<U>) -> Self {
        Stmt::Raise(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct StmtTry<U> {
    pub body: Vec<Stmt<U>>,
    pub handlers: Vec<Excepthandler<U>>,
    pub orelse: Vec<Stmt<U>>,
    pub finalbody: Vec<Stmt<U>>,
    pub custom: U,
}

impl<U> From<StmtTry<U>> for Stmt<U> {
    fn from(payload: StmtTry<U>) -> Self {
        Stmt::Try(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct StmtTryStar<U> {
    pub body: Vec<Stmt<U>>,
    pub handlers: Vec<Excepthandler<U>>,
    pub orelse: Vec<Stmt<U>>,
    pub finalbody: Vec<Stmt<U>>,
    pub custom: U,
}

impl<U> From<StmtTryStar<U>> for Stmt<U> {
    fn from(payload: StmtTryStar<U>) -> Self {
        Stmt::TryStar(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct StmtAssert<U> {
    pub test: Box<Expr<U>>,
    pub msg: Option<Box<Expr<U>>>,
    pub custom: U,
}

impl<U> From<StmtAssert<U>> for Stmt<U> {
    fn from(payload: StmtAssert<U>) -> Self {
        Stmt::Assert(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct StmtImport<U> {
    pub names: Vec<Alias<U>>,
    pub custom: U,
}

impl<U> From<StmtImport<U>> for Stmt<U> {
    fn from(payload: StmtImport<U>) -> Self {
        Stmt::Import(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct StmtImportFrom<U> {
    pub module: Option<Identifier>,
    pub names: Vec<Alias<U>>,
    pub level: Option<Int>,
    pub custom: U,
}

impl<U> From<StmtImportFrom<U>> for Stmt<U> {
    fn from(payload: StmtImportFrom<U>) -> Self {
        Stmt::ImportFrom(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct StmtGlobal<U> {
    pub names: Vec<Identifier>,
    pub custom: U,
}

impl<U> From<StmtGlobal<U>> for Stmt<U> {
    fn from(payload: StmtGlobal<U>) -> Self {
        Stmt::Global(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct StmtNonlocal<U> {
    pub names: Vec<Identifier>,
    pub custom: U,
}

impl<U> From<StmtNonlocal<U>> for Stmt<U> {
    fn from(payload: StmtNonlocal<U>) -> Self {
        Stmt::Nonlocal(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct StmtExpr<U> {
    pub value: Box<Expr<U>>,
    pub custom: U,
}

impl<U> From<StmtExpr<U>> for Stmt<U> {
    fn from(payload: StmtExpr<U>) -> Self {
        Stmt::Expr(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct StmtPass<U> {
    pub custom: U,
}

impl<U> From<StmtPass<U>> for Stmt<U> {
    fn from(payload: StmtPass<U>) -> Self {
        Stmt::Pass(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct StmtBreak<U> {
    pub custom: U,
}

impl<U> From<StmtBreak<U>> for Stmt<U> {
    fn from(payload: StmtBreak<U>) -> Self {
        Stmt::Break(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct StmtContinue<U> {
    pub custom: U,
}

impl<U> From<StmtContinue<U>> for Stmt<U> {
    fn from(payload: StmtContinue<U>) -> Self {
        Stmt::Continue(payload)
    }
}

#[derive(Clone, Debug, PartialEq, is_macro::Is)]
pub enum Stmt<U> {
    #[is(name = "function_def_stmt")]
    FunctionDef(StmtFunctionDef<U>),
    #[is(name = "async_function_def_stmt")]
    AsyncFunctionDef(StmtAsyncFunctionDef<U>),
    #[is(name = "class_def_stmt")]
    ClassDef(StmtClassDef<U>),
    #[is(name = "return_stmt")]
    Return(StmtReturn<U>),
    #[is(name = "delete_stmt")]
    Delete(StmtDelete<U>),
    #[is(name = "assign_stmt")]
    Assign(StmtAssign<U>),
    #[is(name = "aug_assign_stmt")]
    AugAssign(StmtAugAssign<U>),
    #[is(name = "ann_assign_stmt")]
    AnnAssign(StmtAnnAssign<U>),
    #[is(name = "for_stmt")]
    For(StmtFor<U>),
    #[is(name = "async_for_stmt")]
    AsyncFor(StmtAsyncFor<U>),
    #[is(name = "while_stmt")]
    While(StmtWhile<U>),
    #[is(name = "if_stmt")]
    If(StmtIf<U>),
    #[is(name = "with_stmt")]
    With(StmtWith<U>),
    #[is(name = "async_with_stmt")]
    AsyncWith(StmtAsyncWith<U>),
    #[is(name = "match_stmt")]
    Match(StmtMatch<U>),
    #[is(name = "raise_stmt")]
    Raise(StmtRaise<U>),
    #[is(name = "try_stmt")]
    Try(StmtTry<U>),
    #[is(name = "try_star_stmt")]
    TryStar(StmtTryStar<U>),
    #[is(name = "assert_stmt")]
    Assert(StmtAssert<U>),
    #[is(name = "import_stmt")]
    Import(StmtImport<U>),
    #[is(name = "import_from_stmt")]
    ImportFrom(StmtImportFrom<U>),
    #[is(name = "global_stmt")]
    Global(StmtGlobal<U>),
    #[is(name = "nonlocal_stmt")]
    Nonlocal(StmtNonlocal<U>),
    #[is(name = "expr_stmt")]
    Expr(StmtExpr<U>),
    #[is(name = "pass_stmt")]
    Pass(StmtPass<U>),
    #[is(name = "break_stmt")]
    Break(StmtBreak<U>),
    #[is(name = "continue_stmt")]
    Continue(StmtContinue<U>),
}

#[derive(Clone, Debug, PartialEq)]
pub struct ExprBoolOp<U> {
    pub op: Boolop,
    pub values: Vec<Expr<U>>,
    pub custom: U,
}

impl<U> From<ExprBoolOp<U>> for Expr<U> {
    fn from(payload: ExprBoolOp<U>) -> Self {
        Expr::BoolOp(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct ExprNamedExpr<U> {
    pub target: Box<Expr<U>>,
    pub value: Box<Expr<U>>,
    pub custom: U,
}

impl<U> From<ExprNamedExpr<U>> for Expr<U> {
    fn from(payload: ExprNamedExpr<U>) -> Self {
        Expr::NamedExpr(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct ExprBinOp<U> {
    pub left: Box<Expr<U>>,
    pub op: Operator,
    pub right: Box<Expr<U>>,
    pub custom: U,
}

impl<U> From<ExprBinOp<U>> for Expr<U> {
    fn from(payload: ExprBinOp<U>) -> Self {
        Expr::BinOp(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct ExprUnaryOp<U> {
    pub op: Unaryop,
    pub operand: Box<Expr<U>>,
    pub custom: U,
}

impl<U> From<ExprUnaryOp<U>> for Expr<U> {
    fn from(payload: ExprUnaryOp<U>) -> Self {
        Expr::UnaryOp(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct ExprLambda<U> {
    pub args: Box<Arguments<U>>,
    pub body: Box<Expr<U>>,
    pub custom: U,
}

impl<U> From<ExprLambda<U>> for Expr<U> {
    fn from(payload: ExprLambda<U>) -> Self {
        Expr::Lambda(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct ExprIfExp<U> {
    pub test: Box<Expr<U>>,
    pub body: Box<Expr<U>>,
    pub orelse: Box<Expr<U>>,
    pub custom: U,
}

impl<U> From<ExprIfExp<U>> for Expr<U> {
    fn from(payload: ExprIfExp<U>) -> Self {
        Expr::IfExp(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct ExprDict<U> {
    pub keys: Vec<Option<Expr<U>>>,
    pub values: Vec<Expr<U>>,
    pub custom: U,
}

impl<U> From<ExprDict<U>> for Expr<U> {
    fn from(payload: ExprDict<U>) -> Self {
        Expr::Dict(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct ExprSet<U> {
    pub elts: Vec<Expr<U>>,
    pub custom: U,
}

impl<U> From<ExprSet<U>> for Expr<U> {
    fn from(payload: ExprSet<U>) -> Self {
        Expr::Set(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct ExprListComp<U> {
    pub elt: Box<Expr<U>>,
    pub generators: Vec<Comprehension<U>>,
    pub custom: U,
}

impl<U> From<ExprListComp<U>> for Expr<U> {
    fn from(payload: ExprListComp<U>) -> Self {
        Expr::ListComp(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct ExprSetComp<U> {
    pub elt: Box<Expr<U>>,
    pub generators: Vec<Comprehension<U>>,
    pub custom: U,
}

impl<U> From<ExprSetComp<U>> for Expr<U> {
    fn from(payload: ExprSetComp<U>) -> Self {
        Expr::SetComp(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct ExprDictComp<U> {
    pub key: Box<Expr<U>>,
    pub value: Box<Expr<U>>,
    pub generators: Vec<Comprehension<U>>,
    pub custom: U,
}

impl<U> From<ExprDictComp<U>> for Expr<U> {
    fn from(payload: ExprDictComp<U>) -> Self {
        Expr::DictComp(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct ExprGeneratorExp<U> {
    pub elt: Box<Expr<U>>,
    pub generators: Vec<Comprehension<U>>,
    pub custom: U,
}

impl<U> From<ExprGeneratorExp<U>> for Expr<U> {
    fn from(payload: ExprGeneratorExp<U>) -> Self {
        Expr::GeneratorExp(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct ExprAwait<U> {
    pub value: Box<Expr<U>>,
    pub custom: U,
}

impl<U> From<ExprAwait<U>> for Expr<U> {
    fn from(payload: ExprAwait<U>) -> Self {
        Expr::Await(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct ExprYield<U> {
    pub value: Option<Box<Expr<U>>>,
    pub custom: U,
}

impl<U> From<ExprYield<U>> for Expr<U> {
    fn from(payload: ExprYield<U>) -> Self {
        Expr::Yield(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct ExprYieldFrom<U> {
    pub value: Box<Expr<U>>,
    pub custom: U,
}

impl<U> From<ExprYieldFrom<U>> for Expr<U> {
    fn from(payload: ExprYieldFrom<U>) -> Self {
        Expr::YieldFrom(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct ExprCompare<U> {
    pub left: Box<Expr<U>>,
    pub ops: Vec<Cmpop>,
    pub comparators: Vec<Expr<U>>,
    pub custom: U,
}

impl<U> From<ExprCompare<U>> for Expr<U> {
    fn from(payload: ExprCompare<U>) -> Self {
        Expr::Compare(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct ExprCall<U> {
    pub func: Box<Expr<U>>,
    pub args: Vec<Expr<U>>,
    pub keywords: Vec<Keyword<U>>,
    pub custom: U,
}

impl<U> From<ExprCall<U>> for Expr<U> {
    fn from(payload: ExprCall<U>) -> Self {
        Expr::Call(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct ExprFormattedValue<U> {
    pub value: Box<Expr<U>>,
    pub conversion: Int,
    pub format_spec: Option<Box<Expr<U>>>,
    pub custom: U,
}

impl<U> From<ExprFormattedValue<U>> for Expr<U> {
    fn from(payload: ExprFormattedValue<U>) -> Self {
        Expr::FormattedValue(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct ExprJoinedStr<U> {
    pub values: Vec<Expr<U>>,
    pub custom: U,
}

impl<U> From<ExprJoinedStr<U>> for Expr<U> {
    fn from(payload: ExprJoinedStr<U>) -> Self {
        Expr::JoinedStr(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct ExprConstant<U> {
    pub value: Constant,
    pub kind: Option<String>,
    pub custom: U,
}

impl<U> From<ExprConstant<U>> for Expr<U> {
    fn from(payload: ExprConstant<U>) -> Self {
        Expr::Constant(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct ExprAttribute<U> {
    pub value: Box<Expr<U>>,
    pub attr: Identifier,
    pub ctx: ExprContext,
    pub custom: U,
}

impl<U> From<ExprAttribute<U>> for Expr<U> {
    fn from(payload: ExprAttribute<U>) -> Self {
        Expr::Attribute(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct ExprSubscript<U> {
    pub value: Box<Expr<U>>,
    pub slice: Box<Expr<U>>,
    pub ctx: ExprContext,
    pub custom: U,
}

impl<U> From<ExprSubscript<U>> for Expr<U> {
    fn from(payload: ExprSubscript<U>) -> Self {
        Expr::Subscript(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct ExprStarred<U> {
    pub value: Box<Expr<U>>,
    pub ctx: ExprContext,
    pub custom: U,
}

impl<U> From<ExprStarred<U>> for Expr<U> {
    fn from(payload: ExprStarred<U>) -> Self {
        Expr::Starred(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct ExprName<U> {
    pub id: Identifier,
    pub ctx: ExprContext,
    pub custom: U,
}

impl<U> From<ExprName<U>> for Expr<U> {
    fn from(payload: ExprName<U>) -> Self {
        Expr::Name(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct ExprList<U> {
    pub elts: Vec<Expr<U>>,
    pub ctx: ExprContext,
    pub custom: U,
}

impl<U> From<ExprList<U>> for Expr<U> {
    fn from(payload: ExprList<U>) -> Self {
        Expr::List(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct ExprTuple<U> {
    pub elts: Vec<Expr<U>>,
    pub ctx: ExprContext,
    pub custom: U,
}

impl<U> From<ExprTuple<U>> for Expr<U> {
    fn from(payload: ExprTuple<U>) -> Self {
        Expr::Tuple(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct ExprSlice<U> {
    pub lower: Option<Box<Expr<U>>>,
    pub upper: Option<Box<Expr<U>>>,
    pub step: Option<Box<Expr<U>>>,
    pub custom: U,
}

impl<U> From<ExprSlice<U>> for Expr<U> {
    fn from(payload: ExprSlice<U>) -> Self {
        Expr::Slice(payload)
    }
}

#[derive(Clone, Debug, PartialEq, is_macro::Is)]
pub enum Expr<U> {
    #[is(name = "bool_op_expr")]
    BoolOp(ExprBoolOp<U>),
    #[is(name = "named_expr_expr")]
    NamedExpr(ExprNamedExpr<U>),
    #[is(name = "bin_op_expr")]
    BinOp(ExprBinOp<U>),
    #[is(name = "unary_op_expr")]
    UnaryOp(ExprUnaryOp<U>),
    #[is(name = "lambda_expr")]
    Lambda(ExprLambda<U>),
    #[is(name = "if_exp_expr")]
    IfExp(ExprIfExp<U>),
    #[is(name = "dict_expr")]
    Dict(ExprDict<U>),
    #[is(name = "set_expr")]
    Set(ExprSet<U>),
    #[is(name = "list_comp_expr")]
    ListComp(ExprListComp<U>),
    #[is(name = "set_comp_expr")]
    SetComp(ExprSetComp<U>),
    #[is(name = "dict_comp_expr")]
    DictComp(ExprDictComp<U>),
    #[is(name = "generator_exp_expr")]
    GeneratorExp(ExprGeneratorExp<U>),
    #[is(name = "await_expr")]
    Await(ExprAwait<U>),
    #[is(name = "yield_expr")]
    Yield(ExprYield<U>),
    #[is(name = "yield_from_expr")]
    YieldFrom(ExprYieldFrom<U>),
    #[is(name = "compare_expr")]
    Compare(ExprCompare<U>),
    #[is(name = "call_expr")]
    Call(ExprCall<U>),
    #[is(name = "formatted_value_expr")]
    FormattedValue(ExprFormattedValue<U>),
    #[is(name = "joined_str_expr")]
    JoinedStr(ExprJoinedStr<U>),
    #[is(name = "constant_expr")]
    Constant(ExprConstant<U>),
    #[is(name = "attribute_expr")]
    Attribute(ExprAttribute<U>),
    #[is(name = "subscript_expr")]
    Subscript(ExprSubscript<U>),
    #[is(name = "starred_expr")]
    Starred(ExprStarred<U>),
    #[is(name = "name_expr")]
    Name(ExprName<U>),
    #[is(name = "list_expr")]
    List(ExprList<U>),
    #[is(name = "tuple_expr")]
    Tuple(ExprTuple<U>),
    #[is(name = "slice_expr")]
    Slice(ExprSlice<U>),
}

#[derive(Clone, Debug, PartialEq, is_macro::Is)]
pub enum ExprContext {
    Load,
    Store,
    Del,
}

#[derive(Clone, Debug, PartialEq, is_macro::Is)]
pub enum Boolop {
    And,
    Or,
}

#[derive(Clone, Debug, PartialEq, is_macro::Is)]
pub enum Operator {
    Add,
    Sub,
    Mult,
    MatMult,
    Div,
    Mod,
    Pow,
    LShift,
    RShift,
    BitOr,
    BitXor,
    BitAnd,
    FloorDiv,
}

#[derive(Clone, Debug, PartialEq, is_macro::Is)]
pub enum Unaryop {
    Invert,
    Not,
    UAdd,
    USub,
}

#[derive(Clone, Debug, PartialEq, is_macro::Is)]
pub enum Cmpop {
    Eq,
    NotEq,
    Lt,
    LtE,
    Gt,
    GtE,
    Is,
    IsNot,
    In,
    NotIn,
}

#[derive(Clone, Debug, PartialEq)]
pub struct Comprehension<U> {
    pub target: Expr<U>,
    pub iter: Expr<U>,
    pub ifs: Vec<Expr<U>>,
    pub is_async: bool,
    #[cfg(feature = "more-attributes")]
    pub custom: U,
    #[cfg(not(feature = "more-attributes"))]
    pub custom: std::marker::PhantomData<U>,
}

#[derive(Clone, Debug, PartialEq)]
pub struct ExcepthandlerExceptHandler<U> {
    pub type_: Option<Box<Expr<U>>>,
    pub name: Option<Identifier>,
    pub body: Vec<Stmt<U>>,
    pub custom: U,
}

impl<U> From<ExcepthandlerExceptHandler<U>> for Excepthandler<U> {
    fn from(payload: ExcepthandlerExceptHandler<U>) -> Self {
        Excepthandler::ExceptHandler(payload)
    }
}

#[derive(Clone, Debug, PartialEq, is_macro::Is)]
pub enum Excepthandler<U> {
    ExceptHandler(ExcepthandlerExceptHandler<U>),
}

#[derive(Clone, Debug, PartialEq)]
pub struct Arguments<U> {
    pub posonlyargs: Vec<Arg<U>>,
    pub args: Vec<Arg<U>>,
    pub vararg: Option<Box<Arg<U>>>,
    pub kwonlyargs: Vec<Arg<U>>,
    pub kw_defaults: Vec<Expr<U>>,
    pub kwarg: Option<Box<Arg<U>>>,
    pub defaults: Vec<Expr<U>>,
    #[cfg(feature = "more-attributes")]
    pub custom: U,
    #[cfg(not(feature = "more-attributes"))]
    pub custom: std::marker::PhantomData<U>,
}

#[derive(Clone, Debug, PartialEq)]
pub struct Arg<U> {
    pub arg: Identifier,
    pub annotation: Option<Box<Expr<U>>>,
    pub type_comment: Option<String>,
    pub custom: U,
}

#[derive(Clone, Debug, PartialEq)]
pub struct Keyword<U> {
    pub arg: Option<Identifier>,
    pub value: Expr<U>,
    pub custom: U,
}

#[derive(Clone, Debug, PartialEq)]
pub struct Alias<U> {
    pub name: Identifier,
    pub asname: Option<Identifier>,
    pub custom: U,
}

#[derive(Clone, Debug, PartialEq)]
pub struct Withitem<U> {
    pub context_expr: Expr<U>,
    pub optional_vars: Option<Box<Expr<U>>>,
    #[cfg(feature = "more-attributes")]
    pub custom: U,
    #[cfg(not(feature = "more-attributes"))]
    pub custom: std::marker::PhantomData<U>,
}

#[derive(Clone, Debug, PartialEq)]
pub struct MatchCase<U> {
    pub pattern: Pattern<U>,
    pub guard: Option<Box<Expr<U>>>,
    pub body: Vec<Stmt<U>>,
    #[cfg(feature = "more-attributes")]
    pub custom: U,
    #[cfg(not(feature = "more-attributes"))]
    pub custom: std::marker::PhantomData<U>,
}

#[derive(Clone, Debug, PartialEq)]
pub struct PatternMatchValue<U> {
    pub value: Box<Expr<U>>,
    pub custom: U,
}

impl<U> From<PatternMatchValue<U>> for Pattern<U> {
    fn from(payload: PatternMatchValue<U>) -> Self {
        Pattern::MatchValue(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct PatternMatchSingleton<U> {
    pub value: Constant,
    pub custom: U,
}

impl<U> From<PatternMatchSingleton<U>> for Pattern<U> {
    fn from(payload: PatternMatchSingleton<U>) -> Self {
        Pattern::MatchSingleton(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct PatternMatchSequence<U> {
    pub patterns: Vec<Pattern<U>>,
    pub custom: U,
}

impl<U> From<PatternMatchSequence<U>> for Pattern<U> {
    fn from(payload: PatternMatchSequence<U>) -> Self {
        Pattern::MatchSequence(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct PatternMatchMapping<U> {
    pub keys: Vec<Expr<U>>,
    pub patterns: Vec<Pattern<U>>,
    pub rest: Option<Identifier>,
    pub custom: U,
}

impl<U> From<PatternMatchMapping<U>> for Pattern<U> {
    fn from(payload: PatternMatchMapping<U>) -> Self {
        Pattern::MatchMapping(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct PatternMatchClass<U> {
    pub cls: Box<Expr<U>>,
    pub patterns: Vec<Pattern<U>>,
    pub kwd_attrs: Vec<Identifier>,
    pub kwd_patterns: Vec<Pattern<U>>,
    pub custom: U,
}

impl<U> From<PatternMatchClass<U>> for Pattern<U> {
    fn from(payload: PatternMatchClass<U>) -> Self {
        Pattern::MatchClass(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct PatternMatchStar<U> {
    pub name: Option<Identifier>,
    pub custom: U,
}

impl<U> From<PatternMatchStar<U>> for Pattern<U> {
    fn from(payload: PatternMatchStar<U>) -> Self {
        Pattern::MatchStar(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct PatternMatchAs<U> {
    pub pattern: Option<Box<Pattern<U>>>,
    pub name: Option<Identifier>,
    pub custom: U,
}

impl<U> From<PatternMatchAs<U>> for Pattern<U> {
    fn from(payload: PatternMatchAs<U>) -> Self {
        Pattern::MatchAs(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct PatternMatchOr<U> {
    pub patterns: Vec<Pattern<U>>,
    pub custom: U,
}

impl<U> From<PatternMatchOr<U>> for Pattern<U> {
    fn from(payload: PatternMatchOr<U>) -> Self {
        Pattern::MatchOr(payload)
    }
}

#[derive(Clone, Debug, PartialEq, is_macro::Is)]
pub enum Pattern<U> {
    MatchValue(PatternMatchValue<U>),
    MatchSingleton(PatternMatchSingleton<U>),
    MatchSequence(PatternMatchSequence<U>),
    MatchMapping(PatternMatchMapping<U>),
    MatchClass(PatternMatchClass<U>),
    MatchStar(PatternMatchStar<U>),
    MatchAs(PatternMatchAs<U>),
    MatchOr(PatternMatchOr<U>),
}

#[derive(Clone, Debug, PartialEq)]
pub struct TypeIgnoreTypeIgnore<U> {
    pub lineno: Int,
    pub tag: String,
    #[cfg(feature = "more-attributes")]
    pub custom: U,
    #[cfg(not(feature = "more-attributes"))]
    pub custom: std::marker::PhantomData<U>,
}

impl<U> From<TypeIgnoreTypeIgnore<U>> for TypeIgnore<U> {
    fn from(payload: TypeIgnoreTypeIgnore<U>) -> Self {
        TypeIgnore::TypeIgnore(payload)
    }
}

#[derive(Clone, Debug, PartialEq, is_macro::Is)]
pub enum TypeIgnore<U> {
    TypeIgnore(TypeIgnoreTypeIgnore<U>),
}
