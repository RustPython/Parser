// File automatically generated by ast/asdl_rs.py.

impl<R> Pyo3Node for crate::generic::Mod<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::ModModule<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::ModInteractive<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::ModExpression<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::ModFunctionType<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::Stmt<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::StmtFunctionDef<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::StmtAsyncFunctionDef<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::StmtClassDef<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::StmtReturn<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::StmtDelete<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::StmtAssign<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::StmtAugAssign<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::StmtAnnAssign<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::StmtFor<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::StmtAsyncFor<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::StmtWhile<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::StmtIf<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::StmtWith<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::StmtAsyncWith<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::StmtMatch<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::StmtRaise<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::StmtTry<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::StmtTryStar<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::StmtAssert<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::StmtImport<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::StmtImportFrom<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::StmtGlobal<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::StmtNonlocal<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::StmtExpr<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::StmtPass<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::StmtBreak<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::StmtContinue<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::Expr<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::ExprBoolOp<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::ExprNamedExpr<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::ExprBinOp<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::ExprUnaryOp<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::ExprLambda<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::ExprIfExp<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::ExprDict<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::ExprSet<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::ExprListComp<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::ExprSetComp<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::ExprDictComp<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::ExprGeneratorExp<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::ExprAwait<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::ExprYield<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::ExprYieldFrom<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::ExprCompare<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::ExprCall<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::ExprFormattedValue<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::ExprJoinedStr<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::ExprConstant<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::ExprAttribute<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::ExprSubscript<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::ExprStarred<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::ExprName<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::ExprList<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::ExprTuple<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::ExprSlice<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl Pyo3Node for crate::generic::ExprContext {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl Pyo3Node for crate::generic::ExprContextLoad {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl Pyo3Node for crate::generic::ExprContextStore {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl Pyo3Node for crate::generic::ExprContextDel {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl Pyo3Node for crate::generic::Boolop {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl Pyo3Node for crate::generic::BoolopAnd {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl Pyo3Node for crate::generic::BoolopOr {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl Pyo3Node for crate::generic::Operator {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl Pyo3Node for crate::generic::OperatorAdd {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl Pyo3Node for crate::generic::OperatorSub {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl Pyo3Node for crate::generic::OperatorMult {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl Pyo3Node for crate::generic::OperatorMatMult {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl Pyo3Node for crate::generic::OperatorDiv {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl Pyo3Node for crate::generic::OperatorMod {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl Pyo3Node for crate::generic::OperatorPow {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl Pyo3Node for crate::generic::OperatorLShift {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl Pyo3Node for crate::generic::OperatorRShift {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl Pyo3Node for crate::generic::OperatorBitOr {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl Pyo3Node for crate::generic::OperatorBitXor {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl Pyo3Node for crate::generic::OperatorBitAnd {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl Pyo3Node for crate::generic::OperatorFloorDiv {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl Pyo3Node for crate::generic::Unaryop {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl Pyo3Node for crate::generic::UnaryopInvert {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl Pyo3Node for crate::generic::UnaryopNot {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl Pyo3Node for crate::generic::UnaryopUAdd {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl Pyo3Node for crate::generic::UnaryopUSub {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl Pyo3Node for crate::generic::Cmpop {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl Pyo3Node for crate::generic::CmpopEq {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl Pyo3Node for crate::generic::CmpopNotEq {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl Pyo3Node for crate::generic::CmpopLt {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl Pyo3Node for crate::generic::CmpopLtE {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl Pyo3Node for crate::generic::CmpopGt {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl Pyo3Node for crate::generic::CmpopGtE {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl Pyo3Node for crate::generic::CmpopIs {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl Pyo3Node for crate::generic::CmpopIsNot {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl Pyo3Node for crate::generic::CmpopIn {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl Pyo3Node for crate::generic::CmpopNotIn {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::Comprehension<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::Excepthandler<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::ExcepthandlerExceptHandler<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::Arguments<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::Arg<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::Keyword<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::Alias<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::Withitem<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::MatchCase<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::Pattern<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::PatternMatchValue<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::PatternMatchSingleton<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::PatternMatchSequence<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::PatternMatchMapping<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::PatternMatchClass<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::PatternMatchStar<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::PatternMatchAs<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::PatternMatchOr<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::TypeIgnore<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::TypeIgnoreTypeIgnore<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl ToPyo3Ast for crate::generic::ExprContext {
    #[inline]
    fn to_pyo3_ast(&self, _py: Python) -> PyResult<Py<PyAny>> {
        let cell = match &self {
            crate::ExprContext::Load => crate::ExprContextLoad::py_type_cache(),
            crate::ExprContext::Store => crate::ExprContextStore::py_type_cache(),
            crate::ExprContext::Del => crate::ExprContextDel::py_type_cache(),
        };
        Ok(cell.get().unwrap().1.clone())
    }
}

impl ToPyo3Ast for crate::generic::Boolop {
    #[inline]
    fn to_pyo3_ast(&self, _py: Python) -> PyResult<Py<PyAny>> {
        let cell = match &self {
            crate::Boolop::And => crate::BoolopAnd::py_type_cache(),
            crate::Boolop::Or => crate::BoolopOr::py_type_cache(),
        };
        Ok(cell.get().unwrap().1.clone())
    }
}

impl ToPyo3Ast for crate::generic::Operator {
    #[inline]
    fn to_pyo3_ast(&self, _py: Python) -> PyResult<Py<PyAny>> {
        let cell = match &self {
            crate::Operator::Add => crate::OperatorAdd::py_type_cache(),
            crate::Operator::Sub => crate::OperatorSub::py_type_cache(),
            crate::Operator::Mult => crate::OperatorMult::py_type_cache(),
            crate::Operator::MatMult => crate::OperatorMatMult::py_type_cache(),
            crate::Operator::Div => crate::OperatorDiv::py_type_cache(),
            crate::Operator::Mod => crate::OperatorMod::py_type_cache(),
            crate::Operator::Pow => crate::OperatorPow::py_type_cache(),
            crate::Operator::LShift => crate::OperatorLShift::py_type_cache(),
            crate::Operator::RShift => crate::OperatorRShift::py_type_cache(),
            crate::Operator::BitOr => crate::OperatorBitOr::py_type_cache(),
            crate::Operator::BitXor => crate::OperatorBitXor::py_type_cache(),
            crate::Operator::BitAnd => crate::OperatorBitAnd::py_type_cache(),
            crate::Operator::FloorDiv => crate::OperatorFloorDiv::py_type_cache(),
        };
        Ok(cell.get().unwrap().1.clone())
    }
}

impl ToPyo3Ast for crate::generic::Unaryop {
    #[inline]
    fn to_pyo3_ast(&self, _py: Python) -> PyResult<Py<PyAny>> {
        let cell = match &self {
            crate::Unaryop::Invert => crate::UnaryopInvert::py_type_cache(),
            crate::Unaryop::Not => crate::UnaryopNot::py_type_cache(),
            crate::Unaryop::UAdd => crate::UnaryopUAdd::py_type_cache(),
            crate::Unaryop::USub => crate::UnaryopUSub::py_type_cache(),
        };
        Ok(cell.get().unwrap().1.clone())
    }
}

impl ToPyo3Ast for crate::generic::Cmpop {
    #[inline]
    fn to_pyo3_ast(&self, _py: Python) -> PyResult<Py<PyAny>> {
        let cell = match &self {
            crate::Cmpop::Eq => crate::CmpopEq::py_type_cache(),
            crate::Cmpop::NotEq => crate::CmpopNotEq::py_type_cache(),
            crate::Cmpop::Lt => crate::CmpopLt::py_type_cache(),
            crate::Cmpop::LtE => crate::CmpopLtE::py_type_cache(),
            crate::Cmpop::Gt => crate::CmpopGt::py_type_cache(),
            crate::Cmpop::GtE => crate::CmpopGtE::py_type_cache(),
            crate::Cmpop::Is => crate::CmpopIs::py_type_cache(),
            crate::Cmpop::IsNot => crate::CmpopIsNot::py_type_cache(),
            crate::Cmpop::In => crate::CmpopIn::py_type_cache(),
            crate::Cmpop::NotIn => crate::CmpopNotIn::py_type_cache(),
        };
        Ok(cell.get().unwrap().1.clone())
    }
}

impl ToPyo3Ast for crate::generic::Mod<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let instance = match &self {
            crate::Mod::Module(cons) => cons.to_pyo3_ast(py)?,
            crate::Mod::Interactive(cons) => cons.to_pyo3_ast(py)?,
            crate::Mod::Expression(cons) => cons.to_pyo3_ast(py)?,
            crate::Mod::FunctionType(cons) => cons.to_pyo3_ast(py)?,
        };
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ModModule<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(
            py,
            (
                self.body.to_pyo3_ast(py)?,
                self.type_ignores.to_pyo3_ast(py)?,
            ),
        )?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ModInteractive<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(py, (self.body.to_pyo3_ast(py)?,))?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ModExpression<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(py, (self.body.to_pyo3_ast(py)?,))?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ModFunctionType<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(
            py,
            (
                self.argtypes.to_pyo3_ast(py)?,
                self.returns.to_pyo3_ast(py)?,
            ),
        )?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::generic::Stmt<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let instance = match &self {
            crate::Stmt::FunctionDef(cons) => cons.to_pyo3_ast(py)?,
            crate::Stmt::AsyncFunctionDef(cons) => cons.to_pyo3_ast(py)?,
            crate::Stmt::ClassDef(cons) => cons.to_pyo3_ast(py)?,
            crate::Stmt::Return(cons) => cons.to_pyo3_ast(py)?,
            crate::Stmt::Delete(cons) => cons.to_pyo3_ast(py)?,
            crate::Stmt::Assign(cons) => cons.to_pyo3_ast(py)?,
            crate::Stmt::AugAssign(cons) => cons.to_pyo3_ast(py)?,
            crate::Stmt::AnnAssign(cons) => cons.to_pyo3_ast(py)?,
            crate::Stmt::For(cons) => cons.to_pyo3_ast(py)?,
            crate::Stmt::AsyncFor(cons) => cons.to_pyo3_ast(py)?,
            crate::Stmt::While(cons) => cons.to_pyo3_ast(py)?,
            crate::Stmt::If(cons) => cons.to_pyo3_ast(py)?,
            crate::Stmt::With(cons) => cons.to_pyo3_ast(py)?,
            crate::Stmt::AsyncWith(cons) => cons.to_pyo3_ast(py)?,
            crate::Stmt::Match(cons) => cons.to_pyo3_ast(py)?,
            crate::Stmt::Raise(cons) => cons.to_pyo3_ast(py)?,
            crate::Stmt::Try(cons) => cons.to_pyo3_ast(py)?,
            crate::Stmt::TryStar(cons) => cons.to_pyo3_ast(py)?,
            crate::Stmt::Assert(cons) => cons.to_pyo3_ast(py)?,
            crate::Stmt::Import(cons) => cons.to_pyo3_ast(py)?,
            crate::Stmt::ImportFrom(cons) => cons.to_pyo3_ast(py)?,
            crate::Stmt::Global(cons) => cons.to_pyo3_ast(py)?,
            crate::Stmt::Nonlocal(cons) => cons.to_pyo3_ast(py)?,
            crate::Stmt::Expr(cons) => cons.to_pyo3_ast(py)?,
            crate::Stmt::Pass(cons) => cons.to_pyo3_ast(py)?,
            crate::Stmt::Break(cons) => cons.to_pyo3_ast(py)?,
            crate::Stmt::Continue(cons) => cons.to_pyo3_ast(py)?,
        };
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::StmtFunctionDef<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(
            py,
            (
                self.name.to_pyo3_ast(py)?,
                self.args.to_pyo3_ast(py)?,
                self.body.to_pyo3_ast(py)?,
                self.decorator_list.to_pyo3_ast(py)?,
                self.returns.to_pyo3_ast(py)?,
                self.type_comment.to_pyo3_ast(py)?,
            ),
        )?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::StmtAsyncFunctionDef<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(
            py,
            (
                self.name.to_pyo3_ast(py)?,
                self.args.to_pyo3_ast(py)?,
                self.body.to_pyo3_ast(py)?,
                self.decorator_list.to_pyo3_ast(py)?,
                self.returns.to_pyo3_ast(py)?,
                self.type_comment.to_pyo3_ast(py)?,
            ),
        )?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::StmtClassDef<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(
            py,
            (
                self.name.to_pyo3_ast(py)?,
                self.bases.to_pyo3_ast(py)?,
                self.keywords.to_pyo3_ast(py)?,
                self.body.to_pyo3_ast(py)?,
                self.decorator_list.to_pyo3_ast(py)?,
            ),
        )?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::StmtReturn<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(py, (self.value.to_pyo3_ast(py)?,))?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::StmtDelete<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(py, (self.targets.to_pyo3_ast(py)?,))?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::StmtAssign<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(
            py,
            (
                self.targets.to_pyo3_ast(py)?,
                self.value.to_pyo3_ast(py)?,
                self.type_comment.to_pyo3_ast(py)?,
            ),
        )?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::StmtAugAssign<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(
            py,
            (
                self.target.to_pyo3_ast(py)?,
                self.op.to_pyo3_ast(py)?,
                self.value.to_pyo3_ast(py)?,
            ),
        )?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::StmtAnnAssign<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(
            py,
            (
                self.target.to_pyo3_ast(py)?,
                self.annotation.to_pyo3_ast(py)?,
                self.value.to_pyo3_ast(py)?,
                self.simple.to_pyo3_ast(py)?,
            ),
        )?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::StmtFor<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(
            py,
            (
                self.target.to_pyo3_ast(py)?,
                self.iter.to_pyo3_ast(py)?,
                self.body.to_pyo3_ast(py)?,
                self.orelse.to_pyo3_ast(py)?,
                self.type_comment.to_pyo3_ast(py)?,
            ),
        )?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::StmtAsyncFor<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(
            py,
            (
                self.target.to_pyo3_ast(py)?,
                self.iter.to_pyo3_ast(py)?,
                self.body.to_pyo3_ast(py)?,
                self.orelse.to_pyo3_ast(py)?,
                self.type_comment.to_pyo3_ast(py)?,
            ),
        )?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::StmtWhile<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(
            py,
            (
                self.test.to_pyo3_ast(py)?,
                self.body.to_pyo3_ast(py)?,
                self.orelse.to_pyo3_ast(py)?,
            ),
        )?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::StmtIf<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(
            py,
            (
                self.test.to_pyo3_ast(py)?,
                self.body.to_pyo3_ast(py)?,
                self.orelse.to_pyo3_ast(py)?,
            ),
        )?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::StmtWith<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(
            py,
            (
                self.items.to_pyo3_ast(py)?,
                self.body.to_pyo3_ast(py)?,
                self.type_comment.to_pyo3_ast(py)?,
            ),
        )?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::StmtAsyncWith<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(
            py,
            (
                self.items.to_pyo3_ast(py)?,
                self.body.to_pyo3_ast(py)?,
                self.type_comment.to_pyo3_ast(py)?,
            ),
        )?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::StmtMatch<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(
            py,
            (self.subject.to_pyo3_ast(py)?, self.cases.to_pyo3_ast(py)?),
        )?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::StmtRaise<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache
            .0
            .call1(py, (self.exc.to_pyo3_ast(py)?, self.cause.to_pyo3_ast(py)?))?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::StmtTry<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(
            py,
            (
                self.body.to_pyo3_ast(py)?,
                self.handlers.to_pyo3_ast(py)?,
                self.orelse.to_pyo3_ast(py)?,
                self.finalbody.to_pyo3_ast(py)?,
            ),
        )?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::StmtTryStar<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(
            py,
            (
                self.body.to_pyo3_ast(py)?,
                self.handlers.to_pyo3_ast(py)?,
                self.orelse.to_pyo3_ast(py)?,
                self.finalbody.to_pyo3_ast(py)?,
            ),
        )?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::StmtAssert<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache
            .0
            .call1(py, (self.test.to_pyo3_ast(py)?, self.msg.to_pyo3_ast(py)?))?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::StmtImport<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(py, (self.names.to_pyo3_ast(py)?,))?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::StmtImportFrom<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(
            py,
            (
                self.module.to_pyo3_ast(py)?,
                self.names.to_pyo3_ast(py)?,
                self.level.to_pyo3_ast(py)?,
            ),
        )?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::StmtGlobal<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(py, (self.names.to_pyo3_ast(py)?,))?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::StmtNonlocal<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(py, (self.names.to_pyo3_ast(py)?,))?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::StmtExpr<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(py, (self.value.to_pyo3_ast(py)?,))?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::StmtPass<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call0(py)?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::StmtBreak<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call0(py)?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::StmtContinue<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call0(py)?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::generic::Expr<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let instance = match &self {
            crate::Expr::BoolOp(cons) => cons.to_pyo3_ast(py)?,
            crate::Expr::NamedExpr(cons) => cons.to_pyo3_ast(py)?,
            crate::Expr::BinOp(cons) => cons.to_pyo3_ast(py)?,
            crate::Expr::UnaryOp(cons) => cons.to_pyo3_ast(py)?,
            crate::Expr::Lambda(cons) => cons.to_pyo3_ast(py)?,
            crate::Expr::IfExp(cons) => cons.to_pyo3_ast(py)?,
            crate::Expr::Dict(cons) => cons.to_pyo3_ast(py)?,
            crate::Expr::Set(cons) => cons.to_pyo3_ast(py)?,
            crate::Expr::ListComp(cons) => cons.to_pyo3_ast(py)?,
            crate::Expr::SetComp(cons) => cons.to_pyo3_ast(py)?,
            crate::Expr::DictComp(cons) => cons.to_pyo3_ast(py)?,
            crate::Expr::GeneratorExp(cons) => cons.to_pyo3_ast(py)?,
            crate::Expr::Await(cons) => cons.to_pyo3_ast(py)?,
            crate::Expr::Yield(cons) => cons.to_pyo3_ast(py)?,
            crate::Expr::YieldFrom(cons) => cons.to_pyo3_ast(py)?,
            crate::Expr::Compare(cons) => cons.to_pyo3_ast(py)?,
            crate::Expr::Call(cons) => cons.to_pyo3_ast(py)?,
            crate::Expr::FormattedValue(cons) => cons.to_pyo3_ast(py)?,
            crate::Expr::JoinedStr(cons) => cons.to_pyo3_ast(py)?,
            crate::Expr::Constant(cons) => cons.to_pyo3_ast(py)?,
            crate::Expr::Attribute(cons) => cons.to_pyo3_ast(py)?,
            crate::Expr::Subscript(cons) => cons.to_pyo3_ast(py)?,
            crate::Expr::Starred(cons) => cons.to_pyo3_ast(py)?,
            crate::Expr::Name(cons) => cons.to_pyo3_ast(py)?,
            crate::Expr::List(cons) => cons.to_pyo3_ast(py)?,
            crate::Expr::Tuple(cons) => cons.to_pyo3_ast(py)?,
            crate::Expr::Slice(cons) => cons.to_pyo3_ast(py)?,
        };
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ExprBoolOp<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache
            .0
            .call1(py, (self.op.to_pyo3_ast(py)?, self.values.to_pyo3_ast(py)?))?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ExprNamedExpr<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(
            py,
            (self.target.to_pyo3_ast(py)?, self.value.to_pyo3_ast(py)?),
        )?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ExprBinOp<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(
            py,
            (
                self.left.to_pyo3_ast(py)?,
                self.op.to_pyo3_ast(py)?,
                self.right.to_pyo3_ast(py)?,
            ),
        )?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ExprUnaryOp<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(
            py,
            (self.op.to_pyo3_ast(py)?, self.operand.to_pyo3_ast(py)?),
        )?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ExprLambda<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache
            .0
            .call1(py, (self.args.to_pyo3_ast(py)?, self.body.to_pyo3_ast(py)?))?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ExprIfExp<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(
            py,
            (
                self.test.to_pyo3_ast(py)?,
                self.body.to_pyo3_ast(py)?,
                self.orelse.to_pyo3_ast(py)?,
            ),
        )?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ExprDict<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(
            py,
            (self.keys.to_pyo3_ast(py)?, self.values.to_pyo3_ast(py)?),
        )?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ExprSet<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(py, (self.elts.to_pyo3_ast(py)?,))?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ExprListComp<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(
            py,
            (self.elt.to_pyo3_ast(py)?, self.generators.to_pyo3_ast(py)?),
        )?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ExprSetComp<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(
            py,
            (self.elt.to_pyo3_ast(py)?, self.generators.to_pyo3_ast(py)?),
        )?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ExprDictComp<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(
            py,
            (
                self.key.to_pyo3_ast(py)?,
                self.value.to_pyo3_ast(py)?,
                self.generators.to_pyo3_ast(py)?,
            ),
        )?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ExprGeneratorExp<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(
            py,
            (self.elt.to_pyo3_ast(py)?, self.generators.to_pyo3_ast(py)?),
        )?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ExprAwait<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(py, (self.value.to_pyo3_ast(py)?,))?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ExprYield<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(py, (self.value.to_pyo3_ast(py)?,))?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ExprYieldFrom<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(py, (self.value.to_pyo3_ast(py)?,))?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ExprCompare<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(
            py,
            (
                self.left.to_pyo3_ast(py)?,
                self.ops.to_pyo3_ast(py)?,
                self.comparators.to_pyo3_ast(py)?,
            ),
        )?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ExprCall<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(
            py,
            (
                self.func.to_pyo3_ast(py)?,
                self.args.to_pyo3_ast(py)?,
                self.keywords.to_pyo3_ast(py)?,
            ),
        )?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ExprFormattedValue<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(
            py,
            (
                self.value.to_pyo3_ast(py)?,
                self.conversion.to_pyo3_ast(py)?,
                self.format_spec.to_pyo3_ast(py)?,
            ),
        )?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ExprJoinedStr<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(py, (self.values.to_pyo3_ast(py)?,))?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ExprConstant<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(
            py,
            (self.value.to_pyo3_ast(py)?, self.kind.to_pyo3_ast(py)?),
        )?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ExprAttribute<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(
            py,
            (
                self.value.to_pyo3_ast(py)?,
                self.attr.to_pyo3_ast(py)?,
                self.ctx.to_pyo3_ast(py)?,
            ),
        )?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ExprSubscript<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(
            py,
            (
                self.value.to_pyo3_ast(py)?,
                self.slice.to_pyo3_ast(py)?,
                self.ctx.to_pyo3_ast(py)?,
            ),
        )?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ExprStarred<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache
            .0
            .call1(py, (self.value.to_pyo3_ast(py)?, self.ctx.to_pyo3_ast(py)?))?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ExprName<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache
            .0
            .call1(py, (self.id.to_pyo3_ast(py)?, self.ctx.to_pyo3_ast(py)?))?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ExprList<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache
            .0
            .call1(py, (self.elts.to_pyo3_ast(py)?, self.ctx.to_pyo3_ast(py)?))?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ExprTuple<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache
            .0
            .call1(py, (self.elts.to_pyo3_ast(py)?, self.ctx.to_pyo3_ast(py)?))?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ExprSlice<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(
            py,
            (
                self.lower.to_pyo3_ast(py)?,
                self.upper.to_pyo3_ast(py)?,
                self.step.to_pyo3_ast(py)?,
            ),
        )?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::Comprehension<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(
            py,
            (
                self.target.to_pyo3_ast(py)?,
                self.iter.to_pyo3_ast(py)?,
                self.ifs.to_pyo3_ast(py)?,
                self.is_async.to_pyo3_ast(py)?,
            ),
        )?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::generic::Excepthandler<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let instance = match &self {
            crate::Excepthandler::ExceptHandler(cons) => cons.to_pyo3_ast(py)?,
        };
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ExcepthandlerExceptHandler<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(
            py,
            (
                self.type_.to_pyo3_ast(py)?,
                self.name.to_pyo3_ast(py)?,
                self.body.to_pyo3_ast(py)?,
            ),
        )?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::Arguments<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(
            py,
            (
                self.posonlyargs.to_pyo3_ast(py)?,
                self.args.to_pyo3_ast(py)?,
                self.vararg.to_pyo3_ast(py)?,
                self.kwonlyargs.to_pyo3_ast(py)?,
                self.kw_defaults.to_pyo3_ast(py)?,
                self.kwarg.to_pyo3_ast(py)?,
                self.defaults.to_pyo3_ast(py)?,
            ),
        )?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::Arg<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(
            py,
            (
                self.arg.to_pyo3_ast(py)?,
                self.annotation.to_pyo3_ast(py)?,
                self.type_comment.to_pyo3_ast(py)?,
            ),
        )?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::Keyword<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache
            .0
            .call1(py, (self.arg.to_pyo3_ast(py)?, self.value.to_pyo3_ast(py)?))?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::Alias<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(
            py,
            (self.name.to_pyo3_ast(py)?, self.asname.to_pyo3_ast(py)?),
        )?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::Withitem<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(
            py,
            (
                self.context_expr.to_pyo3_ast(py)?,
                self.optional_vars.to_pyo3_ast(py)?,
            ),
        )?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::MatchCase<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(
            py,
            (
                self.pattern.to_pyo3_ast(py)?,
                self.guard.to_pyo3_ast(py)?,
                self.body.to_pyo3_ast(py)?,
            ),
        )?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::generic::Pattern<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let instance = match &self {
            crate::Pattern::MatchValue(cons) => cons.to_pyo3_ast(py)?,
            crate::Pattern::MatchSingleton(cons) => cons.to_pyo3_ast(py)?,
            crate::Pattern::MatchSequence(cons) => cons.to_pyo3_ast(py)?,
            crate::Pattern::MatchMapping(cons) => cons.to_pyo3_ast(py)?,
            crate::Pattern::MatchClass(cons) => cons.to_pyo3_ast(py)?,
            crate::Pattern::MatchStar(cons) => cons.to_pyo3_ast(py)?,
            crate::Pattern::MatchAs(cons) => cons.to_pyo3_ast(py)?,
            crate::Pattern::MatchOr(cons) => cons.to_pyo3_ast(py)?,
        };
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::PatternMatchValue<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(py, (self.value.to_pyo3_ast(py)?,))?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::PatternMatchSingleton<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(py, (self.value.to_pyo3_ast(py)?,))?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::PatternMatchSequence<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(py, (self.patterns.to_pyo3_ast(py)?,))?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::PatternMatchMapping<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(
            py,
            (
                self.keys.to_pyo3_ast(py)?,
                self.patterns.to_pyo3_ast(py)?,
                self.rest.to_pyo3_ast(py)?,
            ),
        )?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::PatternMatchClass<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(
            py,
            (
                self.cls.to_pyo3_ast(py)?,
                self.patterns.to_pyo3_ast(py)?,
                self.kwd_attrs.to_pyo3_ast(py)?,
                self.kwd_patterns.to_pyo3_ast(py)?,
            ),
        )?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::PatternMatchStar<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(py, (self.name.to_pyo3_ast(py)?,))?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::PatternMatchAs<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(
            py,
            (self.pattern.to_pyo3_ast(py)?, self.name.to_pyo3_ast(py)?),
        )?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::PatternMatchOr<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(py, (self.patterns.to_pyo3_ast(py)?,))?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::generic::TypeIgnore<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let instance = match &self {
            crate::TypeIgnore::TypeIgnore(cons) => cons.to_pyo3_ast(py)?,
        };
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::TypeIgnoreTypeIgnore<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(
            py,
            (self.lineno.to_pyo3_ast(py)?, self.tag.to_pyo3_ast(py)?),
        )?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::generic::Mod<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let instance = match &self {
            crate::Mod::Module(cons) => cons.to_pyo3_ast(py)?,
            crate::Mod::Interactive(cons) => cons.to_pyo3_ast(py)?,
            crate::Mod::Expression(cons) => cons.to_pyo3_ast(py)?,
            crate::Mod::FunctionType(cons) => cons.to_pyo3_ast(py)?,
        };
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ModModule<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(
            py,
            (
                self.body.to_pyo3_ast(py)?,
                self.type_ignores.to_pyo3_ast(py)?,
            ),
        )?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ModInteractive<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(py, (self.body.to_pyo3_ast(py)?,))?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ModExpression<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(py, (self.body.to_pyo3_ast(py)?,))?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ModFunctionType<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(
            py,
            (
                self.argtypes.to_pyo3_ast(py)?,
                self.returns.to_pyo3_ast(py)?,
            ),
        )?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::generic::Stmt<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let instance = match &self {
            crate::Stmt::FunctionDef(cons) => cons.to_pyo3_ast(py)?,
            crate::Stmt::AsyncFunctionDef(cons) => cons.to_pyo3_ast(py)?,
            crate::Stmt::ClassDef(cons) => cons.to_pyo3_ast(py)?,
            crate::Stmt::Return(cons) => cons.to_pyo3_ast(py)?,
            crate::Stmt::Delete(cons) => cons.to_pyo3_ast(py)?,
            crate::Stmt::Assign(cons) => cons.to_pyo3_ast(py)?,
            crate::Stmt::AugAssign(cons) => cons.to_pyo3_ast(py)?,
            crate::Stmt::AnnAssign(cons) => cons.to_pyo3_ast(py)?,
            crate::Stmt::For(cons) => cons.to_pyo3_ast(py)?,
            crate::Stmt::AsyncFor(cons) => cons.to_pyo3_ast(py)?,
            crate::Stmt::While(cons) => cons.to_pyo3_ast(py)?,
            crate::Stmt::If(cons) => cons.to_pyo3_ast(py)?,
            crate::Stmt::With(cons) => cons.to_pyo3_ast(py)?,
            crate::Stmt::AsyncWith(cons) => cons.to_pyo3_ast(py)?,
            crate::Stmt::Match(cons) => cons.to_pyo3_ast(py)?,
            crate::Stmt::Raise(cons) => cons.to_pyo3_ast(py)?,
            crate::Stmt::Try(cons) => cons.to_pyo3_ast(py)?,
            crate::Stmt::TryStar(cons) => cons.to_pyo3_ast(py)?,
            crate::Stmt::Assert(cons) => cons.to_pyo3_ast(py)?,
            crate::Stmt::Import(cons) => cons.to_pyo3_ast(py)?,
            crate::Stmt::ImportFrom(cons) => cons.to_pyo3_ast(py)?,
            crate::Stmt::Global(cons) => cons.to_pyo3_ast(py)?,
            crate::Stmt::Nonlocal(cons) => cons.to_pyo3_ast(py)?,
            crate::Stmt::Expr(cons) => cons.to_pyo3_ast(py)?,
            crate::Stmt::Pass(cons) => cons.to_pyo3_ast(py)?,
            crate::Stmt::Break(cons) => cons.to_pyo3_ast(py)?,
            crate::Stmt::Continue(cons) => cons.to_pyo3_ast(py)?,
        };
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::StmtFunctionDef<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(
            py,
            (
                self.name.to_pyo3_ast(py)?,
                self.args.to_pyo3_ast(py)?,
                self.body.to_pyo3_ast(py)?,
                self.decorator_list.to_pyo3_ast(py)?,
                self.returns.to_pyo3_ast(py)?,
                self.type_comment.to_pyo3_ast(py)?,
            ),
        )?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::StmtAsyncFunctionDef<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(
            py,
            (
                self.name.to_pyo3_ast(py)?,
                self.args.to_pyo3_ast(py)?,
                self.body.to_pyo3_ast(py)?,
                self.decorator_list.to_pyo3_ast(py)?,
                self.returns.to_pyo3_ast(py)?,
                self.type_comment.to_pyo3_ast(py)?,
            ),
        )?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::StmtClassDef<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(
            py,
            (
                self.name.to_pyo3_ast(py)?,
                self.bases.to_pyo3_ast(py)?,
                self.keywords.to_pyo3_ast(py)?,
                self.body.to_pyo3_ast(py)?,
                self.decorator_list.to_pyo3_ast(py)?,
            ),
        )?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::StmtReturn<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(py, (self.value.to_pyo3_ast(py)?,))?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::StmtDelete<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(py, (self.targets.to_pyo3_ast(py)?,))?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::StmtAssign<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(
            py,
            (
                self.targets.to_pyo3_ast(py)?,
                self.value.to_pyo3_ast(py)?,
                self.type_comment.to_pyo3_ast(py)?,
            ),
        )?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::StmtAugAssign<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(
            py,
            (
                self.target.to_pyo3_ast(py)?,
                self.op.to_pyo3_ast(py)?,
                self.value.to_pyo3_ast(py)?,
            ),
        )?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::StmtAnnAssign<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(
            py,
            (
                self.target.to_pyo3_ast(py)?,
                self.annotation.to_pyo3_ast(py)?,
                self.value.to_pyo3_ast(py)?,
                self.simple.to_pyo3_ast(py)?,
            ),
        )?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::StmtFor<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(
            py,
            (
                self.target.to_pyo3_ast(py)?,
                self.iter.to_pyo3_ast(py)?,
                self.body.to_pyo3_ast(py)?,
                self.orelse.to_pyo3_ast(py)?,
                self.type_comment.to_pyo3_ast(py)?,
            ),
        )?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::StmtAsyncFor<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(
            py,
            (
                self.target.to_pyo3_ast(py)?,
                self.iter.to_pyo3_ast(py)?,
                self.body.to_pyo3_ast(py)?,
                self.orelse.to_pyo3_ast(py)?,
                self.type_comment.to_pyo3_ast(py)?,
            ),
        )?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::StmtWhile<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(
            py,
            (
                self.test.to_pyo3_ast(py)?,
                self.body.to_pyo3_ast(py)?,
                self.orelse.to_pyo3_ast(py)?,
            ),
        )?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::StmtIf<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(
            py,
            (
                self.test.to_pyo3_ast(py)?,
                self.body.to_pyo3_ast(py)?,
                self.orelse.to_pyo3_ast(py)?,
            ),
        )?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::StmtWith<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(
            py,
            (
                self.items.to_pyo3_ast(py)?,
                self.body.to_pyo3_ast(py)?,
                self.type_comment.to_pyo3_ast(py)?,
            ),
        )?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::StmtAsyncWith<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(
            py,
            (
                self.items.to_pyo3_ast(py)?,
                self.body.to_pyo3_ast(py)?,
                self.type_comment.to_pyo3_ast(py)?,
            ),
        )?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::StmtMatch<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(
            py,
            (self.subject.to_pyo3_ast(py)?, self.cases.to_pyo3_ast(py)?),
        )?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::StmtRaise<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache
            .0
            .call1(py, (self.exc.to_pyo3_ast(py)?, self.cause.to_pyo3_ast(py)?))?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::StmtTry<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(
            py,
            (
                self.body.to_pyo3_ast(py)?,
                self.handlers.to_pyo3_ast(py)?,
                self.orelse.to_pyo3_ast(py)?,
                self.finalbody.to_pyo3_ast(py)?,
            ),
        )?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::StmtTryStar<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(
            py,
            (
                self.body.to_pyo3_ast(py)?,
                self.handlers.to_pyo3_ast(py)?,
                self.orelse.to_pyo3_ast(py)?,
                self.finalbody.to_pyo3_ast(py)?,
            ),
        )?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::StmtAssert<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache
            .0
            .call1(py, (self.test.to_pyo3_ast(py)?, self.msg.to_pyo3_ast(py)?))?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::StmtImport<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(py, (self.names.to_pyo3_ast(py)?,))?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::StmtImportFrom<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(
            py,
            (
                self.module.to_pyo3_ast(py)?,
                self.names.to_pyo3_ast(py)?,
                self.level.to_pyo3_ast(py)?,
            ),
        )?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::StmtGlobal<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(py, (self.names.to_pyo3_ast(py)?,))?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::StmtNonlocal<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(py, (self.names.to_pyo3_ast(py)?,))?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::StmtExpr<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(py, (self.value.to_pyo3_ast(py)?,))?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::StmtPass<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call0(py)?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::StmtBreak<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call0(py)?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::StmtContinue<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call0(py)?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::generic::Expr<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let instance = match &self {
            crate::Expr::BoolOp(cons) => cons.to_pyo3_ast(py)?,
            crate::Expr::NamedExpr(cons) => cons.to_pyo3_ast(py)?,
            crate::Expr::BinOp(cons) => cons.to_pyo3_ast(py)?,
            crate::Expr::UnaryOp(cons) => cons.to_pyo3_ast(py)?,
            crate::Expr::Lambda(cons) => cons.to_pyo3_ast(py)?,
            crate::Expr::IfExp(cons) => cons.to_pyo3_ast(py)?,
            crate::Expr::Dict(cons) => cons.to_pyo3_ast(py)?,
            crate::Expr::Set(cons) => cons.to_pyo3_ast(py)?,
            crate::Expr::ListComp(cons) => cons.to_pyo3_ast(py)?,
            crate::Expr::SetComp(cons) => cons.to_pyo3_ast(py)?,
            crate::Expr::DictComp(cons) => cons.to_pyo3_ast(py)?,
            crate::Expr::GeneratorExp(cons) => cons.to_pyo3_ast(py)?,
            crate::Expr::Await(cons) => cons.to_pyo3_ast(py)?,
            crate::Expr::Yield(cons) => cons.to_pyo3_ast(py)?,
            crate::Expr::YieldFrom(cons) => cons.to_pyo3_ast(py)?,
            crate::Expr::Compare(cons) => cons.to_pyo3_ast(py)?,
            crate::Expr::Call(cons) => cons.to_pyo3_ast(py)?,
            crate::Expr::FormattedValue(cons) => cons.to_pyo3_ast(py)?,
            crate::Expr::JoinedStr(cons) => cons.to_pyo3_ast(py)?,
            crate::Expr::Constant(cons) => cons.to_pyo3_ast(py)?,
            crate::Expr::Attribute(cons) => cons.to_pyo3_ast(py)?,
            crate::Expr::Subscript(cons) => cons.to_pyo3_ast(py)?,
            crate::Expr::Starred(cons) => cons.to_pyo3_ast(py)?,
            crate::Expr::Name(cons) => cons.to_pyo3_ast(py)?,
            crate::Expr::List(cons) => cons.to_pyo3_ast(py)?,
            crate::Expr::Tuple(cons) => cons.to_pyo3_ast(py)?,
            crate::Expr::Slice(cons) => cons.to_pyo3_ast(py)?,
        };
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ExprBoolOp<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache
            .0
            .call1(py, (self.op.to_pyo3_ast(py)?, self.values.to_pyo3_ast(py)?))?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ExprNamedExpr<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(
            py,
            (self.target.to_pyo3_ast(py)?, self.value.to_pyo3_ast(py)?),
        )?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ExprBinOp<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(
            py,
            (
                self.left.to_pyo3_ast(py)?,
                self.op.to_pyo3_ast(py)?,
                self.right.to_pyo3_ast(py)?,
            ),
        )?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ExprUnaryOp<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(
            py,
            (self.op.to_pyo3_ast(py)?, self.operand.to_pyo3_ast(py)?),
        )?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ExprLambda<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache
            .0
            .call1(py, (self.args.to_pyo3_ast(py)?, self.body.to_pyo3_ast(py)?))?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ExprIfExp<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(
            py,
            (
                self.test.to_pyo3_ast(py)?,
                self.body.to_pyo3_ast(py)?,
                self.orelse.to_pyo3_ast(py)?,
            ),
        )?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ExprDict<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(
            py,
            (self.keys.to_pyo3_ast(py)?, self.values.to_pyo3_ast(py)?),
        )?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ExprSet<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(py, (self.elts.to_pyo3_ast(py)?,))?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ExprListComp<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(
            py,
            (self.elt.to_pyo3_ast(py)?, self.generators.to_pyo3_ast(py)?),
        )?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ExprSetComp<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(
            py,
            (self.elt.to_pyo3_ast(py)?, self.generators.to_pyo3_ast(py)?),
        )?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ExprDictComp<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(
            py,
            (
                self.key.to_pyo3_ast(py)?,
                self.value.to_pyo3_ast(py)?,
                self.generators.to_pyo3_ast(py)?,
            ),
        )?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ExprGeneratorExp<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(
            py,
            (self.elt.to_pyo3_ast(py)?, self.generators.to_pyo3_ast(py)?),
        )?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ExprAwait<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(py, (self.value.to_pyo3_ast(py)?,))?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ExprYield<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(py, (self.value.to_pyo3_ast(py)?,))?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ExprYieldFrom<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(py, (self.value.to_pyo3_ast(py)?,))?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ExprCompare<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(
            py,
            (
                self.left.to_pyo3_ast(py)?,
                self.ops.to_pyo3_ast(py)?,
                self.comparators.to_pyo3_ast(py)?,
            ),
        )?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ExprCall<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(
            py,
            (
                self.func.to_pyo3_ast(py)?,
                self.args.to_pyo3_ast(py)?,
                self.keywords.to_pyo3_ast(py)?,
            ),
        )?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ExprFormattedValue<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(
            py,
            (
                self.value.to_pyo3_ast(py)?,
                self.conversion.to_pyo3_ast(py)?,
                self.format_spec.to_pyo3_ast(py)?,
            ),
        )?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ExprJoinedStr<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(py, (self.values.to_pyo3_ast(py)?,))?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ExprConstant<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(
            py,
            (self.value.to_pyo3_ast(py)?, self.kind.to_pyo3_ast(py)?),
        )?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ExprAttribute<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(
            py,
            (
                self.value.to_pyo3_ast(py)?,
                self.attr.to_pyo3_ast(py)?,
                self.ctx.to_pyo3_ast(py)?,
            ),
        )?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ExprSubscript<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(
            py,
            (
                self.value.to_pyo3_ast(py)?,
                self.slice.to_pyo3_ast(py)?,
                self.ctx.to_pyo3_ast(py)?,
            ),
        )?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ExprStarred<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache
            .0
            .call1(py, (self.value.to_pyo3_ast(py)?, self.ctx.to_pyo3_ast(py)?))?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ExprName<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache
            .0
            .call1(py, (self.id.to_pyo3_ast(py)?, self.ctx.to_pyo3_ast(py)?))?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ExprList<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache
            .0
            .call1(py, (self.elts.to_pyo3_ast(py)?, self.ctx.to_pyo3_ast(py)?))?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ExprTuple<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache
            .0
            .call1(py, (self.elts.to_pyo3_ast(py)?, self.ctx.to_pyo3_ast(py)?))?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ExprSlice<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(
            py,
            (
                self.lower.to_pyo3_ast(py)?,
                self.upper.to_pyo3_ast(py)?,
                self.step.to_pyo3_ast(py)?,
            ),
        )?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::Comprehension<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(
            py,
            (
                self.target.to_pyo3_ast(py)?,
                self.iter.to_pyo3_ast(py)?,
                self.ifs.to_pyo3_ast(py)?,
                self.is_async.to_pyo3_ast(py)?,
            ),
        )?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::generic::Excepthandler<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let instance = match &self {
            crate::Excepthandler::ExceptHandler(cons) => cons.to_pyo3_ast(py)?,
        };
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ExcepthandlerExceptHandler<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(
            py,
            (
                self.type_.to_pyo3_ast(py)?,
                self.name.to_pyo3_ast(py)?,
                self.body.to_pyo3_ast(py)?,
            ),
        )?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::Arguments<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(
            py,
            (
                self.posonlyargs.to_pyo3_ast(py)?,
                self.args.to_pyo3_ast(py)?,
                self.vararg.to_pyo3_ast(py)?,
                self.kwonlyargs.to_pyo3_ast(py)?,
                self.kw_defaults.to_pyo3_ast(py)?,
                self.kwarg.to_pyo3_ast(py)?,
                self.defaults.to_pyo3_ast(py)?,
            ),
        )?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::Arg<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(
            py,
            (
                self.arg.to_pyo3_ast(py)?,
                self.annotation.to_pyo3_ast(py)?,
                self.type_comment.to_pyo3_ast(py)?,
            ),
        )?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::Keyword<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache
            .0
            .call1(py, (self.arg.to_pyo3_ast(py)?, self.value.to_pyo3_ast(py)?))?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::Alias<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(
            py,
            (self.name.to_pyo3_ast(py)?, self.asname.to_pyo3_ast(py)?),
        )?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::Withitem<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(
            py,
            (
                self.context_expr.to_pyo3_ast(py)?,
                self.optional_vars.to_pyo3_ast(py)?,
            ),
        )?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::MatchCase<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(
            py,
            (
                self.pattern.to_pyo3_ast(py)?,
                self.guard.to_pyo3_ast(py)?,
                self.body.to_pyo3_ast(py)?,
            ),
        )?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::generic::Pattern<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let instance = match &self {
            crate::Pattern::MatchValue(cons) => cons.to_pyo3_ast(py)?,
            crate::Pattern::MatchSingleton(cons) => cons.to_pyo3_ast(py)?,
            crate::Pattern::MatchSequence(cons) => cons.to_pyo3_ast(py)?,
            crate::Pattern::MatchMapping(cons) => cons.to_pyo3_ast(py)?,
            crate::Pattern::MatchClass(cons) => cons.to_pyo3_ast(py)?,
            crate::Pattern::MatchStar(cons) => cons.to_pyo3_ast(py)?,
            crate::Pattern::MatchAs(cons) => cons.to_pyo3_ast(py)?,
            crate::Pattern::MatchOr(cons) => cons.to_pyo3_ast(py)?,
        };
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::PatternMatchValue<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(py, (self.value.to_pyo3_ast(py)?,))?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::PatternMatchSingleton<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(py, (self.value.to_pyo3_ast(py)?,))?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::PatternMatchSequence<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(py, (self.patterns.to_pyo3_ast(py)?,))?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::PatternMatchMapping<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(
            py,
            (
                self.keys.to_pyo3_ast(py)?,
                self.patterns.to_pyo3_ast(py)?,
                self.rest.to_pyo3_ast(py)?,
            ),
        )?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::PatternMatchClass<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(
            py,
            (
                self.cls.to_pyo3_ast(py)?,
                self.patterns.to_pyo3_ast(py)?,
                self.kwd_attrs.to_pyo3_ast(py)?,
                self.kwd_patterns.to_pyo3_ast(py)?,
            ),
        )?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::PatternMatchStar<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(py, (self.name.to_pyo3_ast(py)?,))?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::PatternMatchAs<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(
            py,
            (self.pattern.to_pyo3_ast(py)?, self.name.to_pyo3_ast(py)?),
        )?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::PatternMatchOr<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(py, (self.patterns.to_pyo3_ast(py)?,))?;
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::generic::TypeIgnore<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let instance = match &self {
            crate::TypeIgnore::TypeIgnore(cons) => cons.to_pyo3_ast(py)?,
        };
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::TypeIgnoreTypeIgnore<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();
        let instance = cache.0.call1(
            py,
            (self.lineno.to_pyo3_ast(py)?, self.tag.to_pyo3_ast(py)?),
        )?;
        Ok(instance)
    }
}

pub fn init(py: Python) -> PyResult<()> {
    let ast_module = PyModule::import(py, "_ast")?;
    cache_py_type::<crate::generic::Mod>(ast_module)?;
    cache_py_type::<crate::generic::ModModule>(ast_module)?;
    cache_py_type::<crate::generic::ModInteractive>(ast_module)?;
    cache_py_type::<crate::generic::ModExpression>(ast_module)?;
    cache_py_type::<crate::generic::ModFunctionType>(ast_module)?;
    cache_py_type::<crate::generic::Stmt>(ast_module)?;
    cache_py_type::<crate::generic::StmtFunctionDef>(ast_module)?;
    cache_py_type::<crate::generic::StmtAsyncFunctionDef>(ast_module)?;
    cache_py_type::<crate::generic::StmtClassDef>(ast_module)?;
    cache_py_type::<crate::generic::StmtReturn>(ast_module)?;
    cache_py_type::<crate::generic::StmtDelete>(ast_module)?;
    cache_py_type::<crate::generic::StmtAssign>(ast_module)?;
    cache_py_type::<crate::generic::StmtAugAssign>(ast_module)?;
    cache_py_type::<crate::generic::StmtAnnAssign>(ast_module)?;
    cache_py_type::<crate::generic::StmtFor>(ast_module)?;
    cache_py_type::<crate::generic::StmtAsyncFor>(ast_module)?;
    cache_py_type::<crate::generic::StmtWhile>(ast_module)?;
    cache_py_type::<crate::generic::StmtIf>(ast_module)?;
    cache_py_type::<crate::generic::StmtWith>(ast_module)?;
    cache_py_type::<crate::generic::StmtAsyncWith>(ast_module)?;
    cache_py_type::<crate::generic::StmtMatch>(ast_module)?;
    cache_py_type::<crate::generic::StmtRaise>(ast_module)?;
    cache_py_type::<crate::generic::StmtTry>(ast_module)?;
    cache_py_type::<crate::generic::StmtTryStar>(ast_module)?;
    cache_py_type::<crate::generic::StmtAssert>(ast_module)?;
    cache_py_type::<crate::generic::StmtImport>(ast_module)?;
    cache_py_type::<crate::generic::StmtImportFrom>(ast_module)?;
    cache_py_type::<crate::generic::StmtGlobal>(ast_module)?;
    cache_py_type::<crate::generic::StmtNonlocal>(ast_module)?;
    cache_py_type::<crate::generic::StmtExpr>(ast_module)?;
    cache_py_type::<crate::generic::StmtPass>(ast_module)?;
    cache_py_type::<crate::generic::StmtBreak>(ast_module)?;
    cache_py_type::<crate::generic::StmtContinue>(ast_module)?;
    cache_py_type::<crate::generic::Expr>(ast_module)?;
    cache_py_type::<crate::generic::ExprBoolOp>(ast_module)?;
    cache_py_type::<crate::generic::ExprNamedExpr>(ast_module)?;
    cache_py_type::<crate::generic::ExprBinOp>(ast_module)?;
    cache_py_type::<crate::generic::ExprUnaryOp>(ast_module)?;
    cache_py_type::<crate::generic::ExprLambda>(ast_module)?;
    cache_py_type::<crate::generic::ExprIfExp>(ast_module)?;
    cache_py_type::<crate::generic::ExprDict>(ast_module)?;
    cache_py_type::<crate::generic::ExprSet>(ast_module)?;
    cache_py_type::<crate::generic::ExprListComp>(ast_module)?;
    cache_py_type::<crate::generic::ExprSetComp>(ast_module)?;
    cache_py_type::<crate::generic::ExprDictComp>(ast_module)?;
    cache_py_type::<crate::generic::ExprGeneratorExp>(ast_module)?;
    cache_py_type::<crate::generic::ExprAwait>(ast_module)?;
    cache_py_type::<crate::generic::ExprYield>(ast_module)?;
    cache_py_type::<crate::generic::ExprYieldFrom>(ast_module)?;
    cache_py_type::<crate::generic::ExprCompare>(ast_module)?;
    cache_py_type::<crate::generic::ExprCall>(ast_module)?;
    cache_py_type::<crate::generic::ExprFormattedValue>(ast_module)?;
    cache_py_type::<crate::generic::ExprJoinedStr>(ast_module)?;
    cache_py_type::<crate::generic::ExprConstant>(ast_module)?;
    cache_py_type::<crate::generic::ExprAttribute>(ast_module)?;
    cache_py_type::<crate::generic::ExprSubscript>(ast_module)?;
    cache_py_type::<crate::generic::ExprStarred>(ast_module)?;
    cache_py_type::<crate::generic::ExprName>(ast_module)?;
    cache_py_type::<crate::generic::ExprList>(ast_module)?;
    cache_py_type::<crate::generic::ExprTuple>(ast_module)?;
    cache_py_type::<crate::generic::ExprSlice>(ast_module)?;
    cache_py_type::<crate::generic::ExprContext>(ast_module)?;
    cache_py_type::<crate::generic::ExprContextLoad>(ast_module)?;
    cache_py_type::<crate::generic::ExprContextStore>(ast_module)?;
    cache_py_type::<crate::generic::ExprContextDel>(ast_module)?;
    cache_py_type::<crate::generic::Boolop>(ast_module)?;
    cache_py_type::<crate::generic::BoolopAnd>(ast_module)?;
    cache_py_type::<crate::generic::BoolopOr>(ast_module)?;
    cache_py_type::<crate::generic::Operator>(ast_module)?;
    cache_py_type::<crate::generic::OperatorAdd>(ast_module)?;
    cache_py_type::<crate::generic::OperatorSub>(ast_module)?;
    cache_py_type::<crate::generic::OperatorMult>(ast_module)?;
    cache_py_type::<crate::generic::OperatorMatMult>(ast_module)?;
    cache_py_type::<crate::generic::OperatorDiv>(ast_module)?;
    cache_py_type::<crate::generic::OperatorMod>(ast_module)?;
    cache_py_type::<crate::generic::OperatorPow>(ast_module)?;
    cache_py_type::<crate::generic::OperatorLShift>(ast_module)?;
    cache_py_type::<crate::generic::OperatorRShift>(ast_module)?;
    cache_py_type::<crate::generic::OperatorBitOr>(ast_module)?;
    cache_py_type::<crate::generic::OperatorBitXor>(ast_module)?;
    cache_py_type::<crate::generic::OperatorBitAnd>(ast_module)?;
    cache_py_type::<crate::generic::OperatorFloorDiv>(ast_module)?;
    cache_py_type::<crate::generic::Unaryop>(ast_module)?;
    cache_py_type::<crate::generic::UnaryopInvert>(ast_module)?;
    cache_py_type::<crate::generic::UnaryopNot>(ast_module)?;
    cache_py_type::<crate::generic::UnaryopUAdd>(ast_module)?;
    cache_py_type::<crate::generic::UnaryopUSub>(ast_module)?;
    cache_py_type::<crate::generic::Cmpop>(ast_module)?;
    cache_py_type::<crate::generic::CmpopEq>(ast_module)?;
    cache_py_type::<crate::generic::CmpopNotEq>(ast_module)?;
    cache_py_type::<crate::generic::CmpopLt>(ast_module)?;
    cache_py_type::<crate::generic::CmpopLtE>(ast_module)?;
    cache_py_type::<crate::generic::CmpopGt>(ast_module)?;
    cache_py_type::<crate::generic::CmpopGtE>(ast_module)?;
    cache_py_type::<crate::generic::CmpopIs>(ast_module)?;
    cache_py_type::<crate::generic::CmpopIsNot>(ast_module)?;
    cache_py_type::<crate::generic::CmpopIn>(ast_module)?;
    cache_py_type::<crate::generic::CmpopNotIn>(ast_module)?;
    cache_py_type::<crate::generic::Comprehension>(ast_module)?;
    cache_py_type::<crate::generic::Excepthandler>(ast_module)?;
    cache_py_type::<crate::generic::ExcepthandlerExceptHandler>(ast_module)?;
    cache_py_type::<crate::generic::Arguments>(ast_module)?;
    cache_py_type::<crate::generic::Arg>(ast_module)?;
    cache_py_type::<crate::generic::Keyword>(ast_module)?;
    cache_py_type::<crate::generic::Alias>(ast_module)?;
    cache_py_type::<crate::generic::Withitem>(ast_module)?;
    cache_py_type::<crate::generic::MatchCase>(ast_module)?;
    cache_py_type::<crate::generic::Pattern>(ast_module)?;
    cache_py_type::<crate::generic::PatternMatchValue>(ast_module)?;
    cache_py_type::<crate::generic::PatternMatchSingleton>(ast_module)?;
    cache_py_type::<crate::generic::PatternMatchSequence>(ast_module)?;
    cache_py_type::<crate::generic::PatternMatchMapping>(ast_module)?;
    cache_py_type::<crate::generic::PatternMatchClass>(ast_module)?;
    cache_py_type::<crate::generic::PatternMatchStar>(ast_module)?;
    cache_py_type::<crate::generic::PatternMatchAs>(ast_module)?;
    cache_py_type::<crate::generic::PatternMatchOr>(ast_module)?;
    cache_py_type::<crate::generic::TypeIgnore>(ast_module)?;
    cache_py_type::<crate::generic::TypeIgnoreTypeIgnore>(ast_module)?;
    Ok(())
}
