// File automatically generated by ast/asdl_rs.py.

impl<R> Pyo3Node for crate::generic::Mod<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::ModModule<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::ModInteractive<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::ModExpression<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::ModFunctionType<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::Stmt<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::StmtFunctionDef<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::StmtAsyncFunctionDef<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::StmtClassDef<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::StmtReturn<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::StmtDelete<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::StmtAssign<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::StmtAugAssign<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::StmtAnnAssign<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::StmtFor<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::StmtAsyncFor<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::StmtWhile<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::StmtIf<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::StmtWith<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::StmtAsyncWith<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::StmtMatch<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::StmtRaise<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::StmtTry<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::StmtTryStar<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::StmtAssert<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::StmtImport<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::StmtImportFrom<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::StmtGlobal<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::StmtNonlocal<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::StmtExpr<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::StmtPass<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::StmtBreak<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::StmtContinue<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::Expr<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::ExprBoolOp<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::ExprNamedExpr<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::ExprBinOp<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::ExprUnaryOp<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::ExprLambda<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::ExprIfExp<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::ExprDict<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::ExprSet<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::ExprListComp<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::ExprSetComp<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::ExprDictComp<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::ExprGeneratorExp<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::ExprAwait<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::ExprYield<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::ExprYieldFrom<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::ExprCompare<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::ExprCall<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::ExprFormattedValue<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::ExprJoinedStr<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::ExprConstant<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::ExprAttribute<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::ExprSubscript<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::ExprStarred<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::ExprName<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::ExprList<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::ExprTuple<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::ExprSlice<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl Pyo3Node for crate::generic::ExprContext {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl Pyo3Node for crate::generic::ExprContextLoad {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl Pyo3Node for crate::generic::ExprContextStore {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl Pyo3Node for crate::generic::ExprContextDel {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl Pyo3Node for crate::generic::Boolop {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl Pyo3Node for crate::generic::BoolopAnd {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl Pyo3Node for crate::generic::BoolopOr {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl Pyo3Node for crate::generic::Operator {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl Pyo3Node for crate::generic::OperatorAdd {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl Pyo3Node for crate::generic::OperatorSub {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl Pyo3Node for crate::generic::OperatorMult {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl Pyo3Node for crate::generic::OperatorMatMult {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl Pyo3Node for crate::generic::OperatorDiv {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl Pyo3Node for crate::generic::OperatorMod {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl Pyo3Node for crate::generic::OperatorPow {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl Pyo3Node for crate::generic::OperatorLShift {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl Pyo3Node for crate::generic::OperatorRShift {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl Pyo3Node for crate::generic::OperatorBitOr {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl Pyo3Node for crate::generic::OperatorBitXor {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl Pyo3Node for crate::generic::OperatorBitAnd {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl Pyo3Node for crate::generic::OperatorFloorDiv {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl Pyo3Node for crate::generic::Unaryop {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl Pyo3Node for crate::generic::UnaryopInvert {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl Pyo3Node for crate::generic::UnaryopNot {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl Pyo3Node for crate::generic::UnaryopUAdd {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl Pyo3Node for crate::generic::UnaryopUSub {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl Pyo3Node for crate::generic::Cmpop {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl Pyo3Node for crate::generic::CmpopEq {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl Pyo3Node for crate::generic::CmpopNotEq {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl Pyo3Node for crate::generic::CmpopLt {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl Pyo3Node for crate::generic::CmpopLtE {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl Pyo3Node for crate::generic::CmpopGt {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl Pyo3Node for crate::generic::CmpopGtE {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl Pyo3Node for crate::generic::CmpopIs {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl Pyo3Node for crate::generic::CmpopIsNot {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl Pyo3Node for crate::generic::CmpopIn {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl Pyo3Node for crate::generic::CmpopNotIn {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::Comprehension<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::Excepthandler<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::ExcepthandlerExceptHandler<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::Arguments<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::Arg<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::Keyword<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::Alias<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::Withitem<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::MatchCase<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::Pattern<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::PatternMatchValue<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::PatternMatchSingleton<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::PatternMatchSequence<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::PatternMatchMapping<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::PatternMatchClass<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::PatternMatchStar<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::PatternMatchAs<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::PatternMatchOr<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::TypeIgnore<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> Pyo3Node for crate::generic::TypeIgnoreTypeIgnore<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl ToPyo3Ast for crate::generic::ExprContext {
    #[inline]
    fn to_pyo3_ast(&self, _py: Python) -> PyResult<Py<PyAny>> {
        let cell = match &self {
            crate::ExprContext::Load => crate::ExprContextLoad::py_type_cache(),
            crate::ExprContext::Store => crate::ExprContextStore::py_type_cache(),
            crate::ExprContext::Del => crate::ExprContextDel::py_type_cache(),
        };
        Ok(cell.get().unwrap().1.clone())
    }
}

impl ToPyo3Ast for crate::generic::Boolop {
    #[inline]
    fn to_pyo3_ast(&self, _py: Python) -> PyResult<Py<PyAny>> {
        let cell = match &self {
            crate::Boolop::And => crate::BoolopAnd::py_type_cache(),
            crate::Boolop::Or => crate::BoolopOr::py_type_cache(),
        };
        Ok(cell.get().unwrap().1.clone())
    }
}

impl ToPyo3Ast for crate::generic::Operator {
    #[inline]
    fn to_pyo3_ast(&self, _py: Python) -> PyResult<Py<PyAny>> {
        let cell = match &self {
            crate::Operator::Add => crate::OperatorAdd::py_type_cache(),
            crate::Operator::Sub => crate::OperatorSub::py_type_cache(),
            crate::Operator::Mult => crate::OperatorMult::py_type_cache(),
            crate::Operator::MatMult => crate::OperatorMatMult::py_type_cache(),
            crate::Operator::Div => crate::OperatorDiv::py_type_cache(),
            crate::Operator::Mod => crate::OperatorMod::py_type_cache(),
            crate::Operator::Pow => crate::OperatorPow::py_type_cache(),
            crate::Operator::LShift => crate::OperatorLShift::py_type_cache(),
            crate::Operator::RShift => crate::OperatorRShift::py_type_cache(),
            crate::Operator::BitOr => crate::OperatorBitOr::py_type_cache(),
            crate::Operator::BitXor => crate::OperatorBitXor::py_type_cache(),
            crate::Operator::BitAnd => crate::OperatorBitAnd::py_type_cache(),
            crate::Operator::FloorDiv => crate::OperatorFloorDiv::py_type_cache(),
        };
        Ok(cell.get().unwrap().1.clone())
    }
}

impl ToPyo3Ast for crate::generic::Unaryop {
    #[inline]
    fn to_pyo3_ast(&self, _py: Python) -> PyResult<Py<PyAny>> {
        let cell = match &self {
            crate::Unaryop::Invert => crate::UnaryopInvert::py_type_cache(),
            crate::Unaryop::Not => crate::UnaryopNot::py_type_cache(),
            crate::Unaryop::UAdd => crate::UnaryopUAdd::py_type_cache(),
            crate::Unaryop::USub => crate::UnaryopUSub::py_type_cache(),
        };
        Ok(cell.get().unwrap().1.clone())
    }
}

impl ToPyo3Ast for crate::generic::Cmpop {
    #[inline]
    fn to_pyo3_ast(&self, _py: Python) -> PyResult<Py<PyAny>> {
        let cell = match &self {
            crate::Cmpop::Eq => crate::CmpopEq::py_type_cache(),
            crate::Cmpop::NotEq => crate::CmpopNotEq::py_type_cache(),
            crate::Cmpop::Lt => crate::CmpopLt::py_type_cache(),
            crate::Cmpop::LtE => crate::CmpopLtE::py_type_cache(),
            crate::Cmpop::Gt => crate::CmpopGt::py_type_cache(),
            crate::Cmpop::GtE => crate::CmpopGtE::py_type_cache(),
            crate::Cmpop::Is => crate::CmpopIs::py_type_cache(),
            crate::Cmpop::IsNot => crate::CmpopIsNot::py_type_cache(),
            crate::Cmpop::In => crate::CmpopIn::py_type_cache(),
            crate::Cmpop::NotIn => crate::CmpopNotIn::py_type_cache(),
        };
        Ok(cell.get().unwrap().1.clone())
    }
}

impl ToPyo3Ast for crate::generic::Mod<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let instance = match &self {
            crate::Mod::Module(cons) => cons.to_pyo3_ast(py)?,
            crate::Mod::Interactive(cons) => cons.to_pyo3_ast(py)?,
            crate::Mod::Expression(cons) => cons.to_pyo3_ast(py)?,
            crate::Mod::FunctionType(cons) => cons.to_pyo3_ast(py)?,
        };
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ModModule<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            body,
            type_ignores,
            range: _range,
        } = self;
        let instance = cache
            .0
            .call1(py, (body.to_pyo3_ast(py)?, type_ignores.to_pyo3_ast(py)?))?;

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ModInteractive<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            body,
            range: _range,
        } = self;
        let instance = cache.0.call1(py, (body.to_pyo3_ast(py)?,))?;

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ModExpression<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            body,
            range: _range,
        } = self;
        let instance = cache.0.call1(py, (body.to_pyo3_ast(py)?,))?;

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ModFunctionType<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            argtypes,
            returns,
            range: _range,
        } = self;
        let instance = cache
            .0
            .call1(py, (argtypes.to_pyo3_ast(py)?, returns.to_pyo3_ast(py)?))?;

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::generic::Stmt<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let instance = match &self {
            crate::Stmt::FunctionDef(cons) => cons.to_pyo3_ast(py)?,
            crate::Stmt::AsyncFunctionDef(cons) => cons.to_pyo3_ast(py)?,
            crate::Stmt::ClassDef(cons) => cons.to_pyo3_ast(py)?,
            crate::Stmt::Return(cons) => cons.to_pyo3_ast(py)?,
            crate::Stmt::Delete(cons) => cons.to_pyo3_ast(py)?,
            crate::Stmt::Assign(cons) => cons.to_pyo3_ast(py)?,
            crate::Stmt::AugAssign(cons) => cons.to_pyo3_ast(py)?,
            crate::Stmt::AnnAssign(cons) => cons.to_pyo3_ast(py)?,
            crate::Stmt::For(cons) => cons.to_pyo3_ast(py)?,
            crate::Stmt::AsyncFor(cons) => cons.to_pyo3_ast(py)?,
            crate::Stmt::While(cons) => cons.to_pyo3_ast(py)?,
            crate::Stmt::If(cons) => cons.to_pyo3_ast(py)?,
            crate::Stmt::With(cons) => cons.to_pyo3_ast(py)?,
            crate::Stmt::AsyncWith(cons) => cons.to_pyo3_ast(py)?,
            crate::Stmt::Match(cons) => cons.to_pyo3_ast(py)?,
            crate::Stmt::Raise(cons) => cons.to_pyo3_ast(py)?,
            crate::Stmt::Try(cons) => cons.to_pyo3_ast(py)?,
            crate::Stmt::TryStar(cons) => cons.to_pyo3_ast(py)?,
            crate::Stmt::Assert(cons) => cons.to_pyo3_ast(py)?,
            crate::Stmt::Import(cons) => cons.to_pyo3_ast(py)?,
            crate::Stmt::ImportFrom(cons) => cons.to_pyo3_ast(py)?,
            crate::Stmt::Global(cons) => cons.to_pyo3_ast(py)?,
            crate::Stmt::Nonlocal(cons) => cons.to_pyo3_ast(py)?,
            crate::Stmt::Expr(cons) => cons.to_pyo3_ast(py)?,
            crate::Stmt::Pass(cons) => cons.to_pyo3_ast(py)?,
            crate::Stmt::Break(cons) => cons.to_pyo3_ast(py)?,
            crate::Stmt::Continue(cons) => cons.to_pyo3_ast(py)?,
        };
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::StmtFunctionDef<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            name,
            args,
            body,
            decorator_list,
            returns,
            type_comment,
            range: _range,
        } = self;
        let instance = cache.0.call1(
            py,
            (
                name.to_pyo3_ast(py)?,
                args.to_pyo3_ast(py)?,
                body.to_pyo3_ast(py)?,
                decorator_list.to_pyo3_ast(py)?,
                returns.to_pyo3_ast(py)?,
                type_comment.to_pyo3_ast(py)?,
            ),
        )?;

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::StmtAsyncFunctionDef<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            name,
            args,
            body,
            decorator_list,
            returns,
            type_comment,
            range: _range,
        } = self;
        let instance = cache.0.call1(
            py,
            (
                name.to_pyo3_ast(py)?,
                args.to_pyo3_ast(py)?,
                body.to_pyo3_ast(py)?,
                decorator_list.to_pyo3_ast(py)?,
                returns.to_pyo3_ast(py)?,
                type_comment.to_pyo3_ast(py)?,
            ),
        )?;

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::StmtClassDef<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            name,
            bases,
            keywords,
            body,
            decorator_list,
            range: _range,
        } = self;
        let instance = cache.0.call1(
            py,
            (
                name.to_pyo3_ast(py)?,
                bases.to_pyo3_ast(py)?,
                keywords.to_pyo3_ast(py)?,
                body.to_pyo3_ast(py)?,
                decorator_list.to_pyo3_ast(py)?,
            ),
        )?;

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::StmtReturn<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            value,
            range: _range,
        } = self;
        let instance = cache.0.call1(py, (value.to_pyo3_ast(py)?,))?;

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::StmtDelete<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            targets,
            range: _range,
        } = self;
        let instance = cache.0.call1(py, (targets.to_pyo3_ast(py)?,))?;

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::StmtAssign<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            targets,
            value,
            type_comment,
            range: _range,
        } = self;
        let instance = cache.0.call1(
            py,
            (
                targets.to_pyo3_ast(py)?,
                value.to_pyo3_ast(py)?,
                type_comment.to_pyo3_ast(py)?,
            ),
        )?;

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::StmtAugAssign<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            target,
            op,
            value,
            range: _range,
        } = self;
        let instance = cache.0.call1(
            py,
            (
                target.to_pyo3_ast(py)?,
                op.to_pyo3_ast(py)?,
                value.to_pyo3_ast(py)?,
            ),
        )?;

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::StmtAnnAssign<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            target,
            annotation,
            value,
            simple,
            range: _range,
        } = self;
        let instance = cache.0.call1(
            py,
            (
                target.to_pyo3_ast(py)?,
                annotation.to_pyo3_ast(py)?,
                value.to_pyo3_ast(py)?,
                simple.to_pyo3_ast(py)?,
            ),
        )?;

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::StmtFor<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            target,
            iter,
            body,
            orelse,
            type_comment,
            range: _range,
        } = self;
        let instance = cache.0.call1(
            py,
            (
                target.to_pyo3_ast(py)?,
                iter.to_pyo3_ast(py)?,
                body.to_pyo3_ast(py)?,
                orelse.to_pyo3_ast(py)?,
                type_comment.to_pyo3_ast(py)?,
            ),
        )?;

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::StmtAsyncFor<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            target,
            iter,
            body,
            orelse,
            type_comment,
            range: _range,
        } = self;
        let instance = cache.0.call1(
            py,
            (
                target.to_pyo3_ast(py)?,
                iter.to_pyo3_ast(py)?,
                body.to_pyo3_ast(py)?,
                orelse.to_pyo3_ast(py)?,
                type_comment.to_pyo3_ast(py)?,
            ),
        )?;

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::StmtWhile<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            test,
            body,
            orelse,
            range: _range,
        } = self;
        let instance = cache.0.call1(
            py,
            (
                test.to_pyo3_ast(py)?,
                body.to_pyo3_ast(py)?,
                orelse.to_pyo3_ast(py)?,
            ),
        )?;

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::StmtIf<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            test,
            body,
            orelse,
            range: _range,
        } = self;
        let instance = cache.0.call1(
            py,
            (
                test.to_pyo3_ast(py)?,
                body.to_pyo3_ast(py)?,
                orelse.to_pyo3_ast(py)?,
            ),
        )?;

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::StmtWith<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            items,
            body,
            type_comment,
            range: _range,
        } = self;
        let instance = cache.0.call1(
            py,
            (
                items.to_pyo3_ast(py)?,
                body.to_pyo3_ast(py)?,
                type_comment.to_pyo3_ast(py)?,
            ),
        )?;

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::StmtAsyncWith<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            items,
            body,
            type_comment,
            range: _range,
        } = self;
        let instance = cache.0.call1(
            py,
            (
                items.to_pyo3_ast(py)?,
                body.to_pyo3_ast(py)?,
                type_comment.to_pyo3_ast(py)?,
            ),
        )?;

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::StmtMatch<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            subject,
            cases,
            range: _range,
        } = self;
        let instance = cache
            .0
            .call1(py, (subject.to_pyo3_ast(py)?, cases.to_pyo3_ast(py)?))?;

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::StmtRaise<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            exc,
            cause,
            range: _range,
        } = self;
        let instance = cache
            .0
            .call1(py, (exc.to_pyo3_ast(py)?, cause.to_pyo3_ast(py)?))?;

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::StmtTry<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            body,
            handlers,
            orelse,
            finalbody,
            range: _range,
        } = self;
        let instance = cache.0.call1(
            py,
            (
                body.to_pyo3_ast(py)?,
                handlers.to_pyo3_ast(py)?,
                orelse.to_pyo3_ast(py)?,
                finalbody.to_pyo3_ast(py)?,
            ),
        )?;

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::StmtTryStar<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            body,
            handlers,
            orelse,
            finalbody,
            range: _range,
        } = self;
        let instance = cache.0.call1(
            py,
            (
                body.to_pyo3_ast(py)?,
                handlers.to_pyo3_ast(py)?,
                orelse.to_pyo3_ast(py)?,
                finalbody.to_pyo3_ast(py)?,
            ),
        )?;

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::StmtAssert<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            test,
            msg,
            range: _range,
        } = self;
        let instance = cache
            .0
            .call1(py, (test.to_pyo3_ast(py)?, msg.to_pyo3_ast(py)?))?;

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::StmtImport<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            names,
            range: _range,
        } = self;
        let instance = cache.0.call1(py, (names.to_pyo3_ast(py)?,))?;

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::StmtImportFrom<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            module,
            names,
            level,
            range: _range,
        } = self;
        let instance = cache.0.call1(
            py,
            (
                module.to_pyo3_ast(py)?,
                names.to_pyo3_ast(py)?,
                level.to_pyo3_ast(py)?,
            ),
        )?;

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::StmtGlobal<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            names,
            range: _range,
        } = self;
        let instance = cache.0.call1(py, (names.to_pyo3_ast(py)?,))?;

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::StmtNonlocal<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            names,
            range: _range,
        } = self;
        let instance = cache.0.call1(py, (names.to_pyo3_ast(py)?,))?;

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::StmtExpr<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            value,
            range: _range,
        } = self;
        let instance = cache.0.call1(py, (value.to_pyo3_ast(py)?,))?;

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::StmtPass<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let instance = cache.0.call0(py)?;
        let Self { range: _range } = self;

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::StmtBreak<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let instance = cache.0.call0(py)?;
        let Self { range: _range } = self;

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::StmtContinue<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let instance = cache.0.call0(py)?;
        let Self { range: _range } = self;

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::generic::Expr<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let instance = match &self {
            crate::Expr::BoolOp(cons) => cons.to_pyo3_ast(py)?,
            crate::Expr::NamedExpr(cons) => cons.to_pyo3_ast(py)?,
            crate::Expr::BinOp(cons) => cons.to_pyo3_ast(py)?,
            crate::Expr::UnaryOp(cons) => cons.to_pyo3_ast(py)?,
            crate::Expr::Lambda(cons) => cons.to_pyo3_ast(py)?,
            crate::Expr::IfExp(cons) => cons.to_pyo3_ast(py)?,
            crate::Expr::Dict(cons) => cons.to_pyo3_ast(py)?,
            crate::Expr::Set(cons) => cons.to_pyo3_ast(py)?,
            crate::Expr::ListComp(cons) => cons.to_pyo3_ast(py)?,
            crate::Expr::SetComp(cons) => cons.to_pyo3_ast(py)?,
            crate::Expr::DictComp(cons) => cons.to_pyo3_ast(py)?,
            crate::Expr::GeneratorExp(cons) => cons.to_pyo3_ast(py)?,
            crate::Expr::Await(cons) => cons.to_pyo3_ast(py)?,
            crate::Expr::Yield(cons) => cons.to_pyo3_ast(py)?,
            crate::Expr::YieldFrom(cons) => cons.to_pyo3_ast(py)?,
            crate::Expr::Compare(cons) => cons.to_pyo3_ast(py)?,
            crate::Expr::Call(cons) => cons.to_pyo3_ast(py)?,
            crate::Expr::FormattedValue(cons) => cons.to_pyo3_ast(py)?,
            crate::Expr::JoinedStr(cons) => cons.to_pyo3_ast(py)?,
            crate::Expr::Constant(cons) => cons.to_pyo3_ast(py)?,
            crate::Expr::Attribute(cons) => cons.to_pyo3_ast(py)?,
            crate::Expr::Subscript(cons) => cons.to_pyo3_ast(py)?,
            crate::Expr::Starred(cons) => cons.to_pyo3_ast(py)?,
            crate::Expr::Name(cons) => cons.to_pyo3_ast(py)?,
            crate::Expr::List(cons) => cons.to_pyo3_ast(py)?,
            crate::Expr::Tuple(cons) => cons.to_pyo3_ast(py)?,
            crate::Expr::Slice(cons) => cons.to_pyo3_ast(py)?,
        };
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ExprBoolOp<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            op,
            values,
            range: _range,
        } = self;
        let instance = cache
            .0
            .call1(py, (op.to_pyo3_ast(py)?, values.to_pyo3_ast(py)?))?;

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ExprNamedExpr<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            target,
            value,
            range: _range,
        } = self;
        let instance = cache
            .0
            .call1(py, (target.to_pyo3_ast(py)?, value.to_pyo3_ast(py)?))?;

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ExprBinOp<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            left,
            op,
            right,
            range: _range,
        } = self;
        let instance = cache.0.call1(
            py,
            (
                left.to_pyo3_ast(py)?,
                op.to_pyo3_ast(py)?,
                right.to_pyo3_ast(py)?,
            ),
        )?;

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ExprUnaryOp<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            op,
            operand,
            range: _range,
        } = self;
        let instance = cache
            .0
            .call1(py, (op.to_pyo3_ast(py)?, operand.to_pyo3_ast(py)?))?;

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ExprLambda<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            args,
            body,
            range: _range,
        } = self;
        let instance = cache
            .0
            .call1(py, (args.to_pyo3_ast(py)?, body.to_pyo3_ast(py)?))?;

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ExprIfExp<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            test,
            body,
            orelse,
            range: _range,
        } = self;
        let instance = cache.0.call1(
            py,
            (
                test.to_pyo3_ast(py)?,
                body.to_pyo3_ast(py)?,
                orelse.to_pyo3_ast(py)?,
            ),
        )?;

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ExprDict<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            keys,
            values,
            range: _range,
        } = self;
        let instance = cache
            .0
            .call1(py, (keys.to_pyo3_ast(py)?, values.to_pyo3_ast(py)?))?;

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ExprSet<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            elts,
            range: _range,
        } = self;
        let instance = cache.0.call1(py, (elts.to_pyo3_ast(py)?,))?;

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ExprListComp<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            elt,
            generators,
            range: _range,
        } = self;
        let instance = cache
            .0
            .call1(py, (elt.to_pyo3_ast(py)?, generators.to_pyo3_ast(py)?))?;

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ExprSetComp<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            elt,
            generators,
            range: _range,
        } = self;
        let instance = cache
            .0
            .call1(py, (elt.to_pyo3_ast(py)?, generators.to_pyo3_ast(py)?))?;

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ExprDictComp<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            key,
            value,
            generators,
            range: _range,
        } = self;
        let instance = cache.0.call1(
            py,
            (
                key.to_pyo3_ast(py)?,
                value.to_pyo3_ast(py)?,
                generators.to_pyo3_ast(py)?,
            ),
        )?;

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ExprGeneratorExp<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            elt,
            generators,
            range: _range,
        } = self;
        let instance = cache
            .0
            .call1(py, (elt.to_pyo3_ast(py)?, generators.to_pyo3_ast(py)?))?;

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ExprAwait<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            value,
            range: _range,
        } = self;
        let instance = cache.0.call1(py, (value.to_pyo3_ast(py)?,))?;

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ExprYield<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            value,
            range: _range,
        } = self;
        let instance = cache.0.call1(py, (value.to_pyo3_ast(py)?,))?;

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ExprYieldFrom<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            value,
            range: _range,
        } = self;
        let instance = cache.0.call1(py, (value.to_pyo3_ast(py)?,))?;

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ExprCompare<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            left,
            ops,
            comparators,
            range: _range,
        } = self;
        let instance = cache.0.call1(
            py,
            (
                left.to_pyo3_ast(py)?,
                ops.to_pyo3_ast(py)?,
                comparators.to_pyo3_ast(py)?,
            ),
        )?;

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ExprCall<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            func,
            args,
            keywords,
            range: _range,
        } = self;
        let instance = cache.0.call1(
            py,
            (
                func.to_pyo3_ast(py)?,
                args.to_pyo3_ast(py)?,
                keywords.to_pyo3_ast(py)?,
            ),
        )?;

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ExprFormattedValue<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            value,
            conversion,
            format_spec,
            range: _range,
        } = self;
        let instance = cache.0.call1(
            py,
            (
                value.to_pyo3_ast(py)?,
                conversion.to_pyo3_ast(py)?,
                format_spec.to_pyo3_ast(py)?,
            ),
        )?;

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ExprJoinedStr<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            values,
            range: _range,
        } = self;
        let instance = cache.0.call1(py, (values.to_pyo3_ast(py)?,))?;

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ExprConstant<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            value,
            kind,
            range: _range,
        } = self;
        let instance = cache
            .0
            .call1(py, (value.to_pyo3_ast(py)?, kind.to_pyo3_ast(py)?))?;

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ExprAttribute<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            value,
            attr,
            ctx,
            range: _range,
        } = self;
        let instance = cache.0.call1(
            py,
            (
                value.to_pyo3_ast(py)?,
                attr.to_pyo3_ast(py)?,
                ctx.to_pyo3_ast(py)?,
            ),
        )?;

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ExprSubscript<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            value,
            slice,
            ctx,
            range: _range,
        } = self;
        let instance = cache.0.call1(
            py,
            (
                value.to_pyo3_ast(py)?,
                slice.to_pyo3_ast(py)?,
                ctx.to_pyo3_ast(py)?,
            ),
        )?;

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ExprStarred<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            value,
            ctx,
            range: _range,
        } = self;
        let instance = cache
            .0
            .call1(py, (value.to_pyo3_ast(py)?, ctx.to_pyo3_ast(py)?))?;

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ExprName<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            id,
            ctx,
            range: _range,
        } = self;
        let instance = cache
            .0
            .call1(py, (id.to_pyo3_ast(py)?, ctx.to_pyo3_ast(py)?))?;

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ExprList<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            elts,
            ctx,
            range: _range,
        } = self;
        let instance = cache
            .0
            .call1(py, (elts.to_pyo3_ast(py)?, ctx.to_pyo3_ast(py)?))?;

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ExprTuple<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            elts,
            ctx,
            range: _range,
        } = self;
        let instance = cache
            .0
            .call1(py, (elts.to_pyo3_ast(py)?, ctx.to_pyo3_ast(py)?))?;

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ExprSlice<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            lower,
            upper,
            step,
            range: _range,
        } = self;
        let instance = cache.0.call1(
            py,
            (
                lower.to_pyo3_ast(py)?,
                upper.to_pyo3_ast(py)?,
                step.to_pyo3_ast(py)?,
            ),
        )?;

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::Comprehension<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            target,
            iter,
            ifs,
            is_async,
            range: _range,
        } = self;
        let instance = cache.0.call1(
            py,
            (
                target.to_pyo3_ast(py)?,
                iter.to_pyo3_ast(py)?,
                ifs.to_pyo3_ast(py)?,
                is_async.to_pyo3_ast(py)?,
            ),
        )?;

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::generic::Excepthandler<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let instance = match &self {
            crate::Excepthandler::ExceptHandler(cons) => cons.to_pyo3_ast(py)?,
        };
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ExcepthandlerExceptHandler<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            type_,
            name,
            body,
            range: _range,
        } = self;
        let instance = cache.0.call1(
            py,
            (
                type_.to_pyo3_ast(py)?,
                name.to_pyo3_ast(py)?,
                body.to_pyo3_ast(py)?,
            ),
        )?;

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::Arguments<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            posonlyargs,
            args,
            vararg,
            kwonlyargs,
            kw_defaults,
            kwarg,
            defaults,
            range: _range,
        } = self;
        let instance = cache.0.call1(
            py,
            (
                posonlyargs.to_pyo3_ast(py)?,
                args.to_pyo3_ast(py)?,
                vararg.to_pyo3_ast(py)?,
                kwonlyargs.to_pyo3_ast(py)?,
                kw_defaults.to_pyo3_ast(py)?,
                kwarg.to_pyo3_ast(py)?,
                defaults.to_pyo3_ast(py)?,
            ),
        )?;

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::Arg<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            arg,
            annotation,
            type_comment,
            range: _range,
        } = self;
        let instance = cache.0.call1(
            py,
            (
                arg.to_pyo3_ast(py)?,
                annotation.to_pyo3_ast(py)?,
                type_comment.to_pyo3_ast(py)?,
            ),
        )?;

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::Keyword<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            arg,
            value,
            range: _range,
        } = self;
        let instance = cache
            .0
            .call1(py, (arg.to_pyo3_ast(py)?, value.to_pyo3_ast(py)?))?;

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::Alias<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            name,
            asname,
            range: _range,
        } = self;
        let instance = cache
            .0
            .call1(py, (name.to_pyo3_ast(py)?, asname.to_pyo3_ast(py)?))?;

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::Withitem<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            context_expr,
            optional_vars,
            range: _range,
        } = self;
        let instance = cache.0.call1(
            py,
            (
                context_expr.to_pyo3_ast(py)?,
                optional_vars.to_pyo3_ast(py)?,
            ),
        )?;

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::MatchCase<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            pattern,
            guard,
            body,
            range: _range,
        } = self;
        let instance = cache.0.call1(
            py,
            (
                pattern.to_pyo3_ast(py)?,
                guard.to_pyo3_ast(py)?,
                body.to_pyo3_ast(py)?,
            ),
        )?;

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::generic::Pattern<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let instance = match &self {
            crate::Pattern::MatchValue(cons) => cons.to_pyo3_ast(py)?,
            crate::Pattern::MatchSingleton(cons) => cons.to_pyo3_ast(py)?,
            crate::Pattern::MatchSequence(cons) => cons.to_pyo3_ast(py)?,
            crate::Pattern::MatchMapping(cons) => cons.to_pyo3_ast(py)?,
            crate::Pattern::MatchClass(cons) => cons.to_pyo3_ast(py)?,
            crate::Pattern::MatchStar(cons) => cons.to_pyo3_ast(py)?,
            crate::Pattern::MatchAs(cons) => cons.to_pyo3_ast(py)?,
            crate::Pattern::MatchOr(cons) => cons.to_pyo3_ast(py)?,
        };
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::PatternMatchValue<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            value,
            range: _range,
        } = self;
        let instance = cache.0.call1(py, (value.to_pyo3_ast(py)?,))?;

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::PatternMatchSingleton<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            value,
            range: _range,
        } = self;
        let instance = cache.0.call1(py, (value.to_pyo3_ast(py)?,))?;

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::PatternMatchSequence<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            patterns,
            range: _range,
        } = self;
        let instance = cache.0.call1(py, (patterns.to_pyo3_ast(py)?,))?;

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::PatternMatchMapping<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            keys,
            patterns,
            rest,
            range: _range,
        } = self;
        let instance = cache.0.call1(
            py,
            (
                keys.to_pyo3_ast(py)?,
                patterns.to_pyo3_ast(py)?,
                rest.to_pyo3_ast(py)?,
            ),
        )?;

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::PatternMatchClass<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            cls,
            patterns,
            kwd_attrs,
            kwd_patterns,
            range: _range,
        } = self;
        let instance = cache.0.call1(
            py,
            (
                cls.to_pyo3_ast(py)?,
                patterns.to_pyo3_ast(py)?,
                kwd_attrs.to_pyo3_ast(py)?,
                kwd_patterns.to_pyo3_ast(py)?,
            ),
        )?;

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::PatternMatchStar<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            name,
            range: _range,
        } = self;
        let instance = cache.0.call1(py, (name.to_pyo3_ast(py)?,))?;

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::PatternMatchAs<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            pattern,
            name,
            range: _range,
        } = self;
        let instance = cache
            .0
            .call1(py, (pattern.to_pyo3_ast(py)?, name.to_pyo3_ast(py)?))?;

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::PatternMatchOr<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            patterns,
            range: _range,
        } = self;
        let instance = cache.0.call1(py, (patterns.to_pyo3_ast(py)?,))?;

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::generic::TypeIgnore<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let instance = match &self {
            crate::TypeIgnore::TypeIgnore(cons) => cons.to_pyo3_ast(py)?,
        };
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::TypeIgnoreTypeIgnore<TextRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            lineno,
            tag,
            range: _range,
        } = self;
        let instance = cache
            .0
            .call1(py, (lineno.to_pyo3_ast(py)?, tag.to_pyo3_ast(py)?))?;

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::generic::Mod<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let instance = match &self {
            crate::Mod::Module(cons) => cons.to_pyo3_ast(py)?,
            crate::Mod::Interactive(cons) => cons.to_pyo3_ast(py)?,
            crate::Mod::Expression(cons) => cons.to_pyo3_ast(py)?,
            crate::Mod::FunctionType(cons) => cons.to_pyo3_ast(py)?,
        };
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ModModule<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            body,
            type_ignores,
            range: _range,
        } = self;
        let instance = cache
            .0
            .call1(py, (body.to_pyo3_ast(py)?, type_ignores.to_pyo3_ast(py)?))?;

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ModInteractive<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            body,
            range: _range,
        } = self;
        let instance = cache.0.call1(py, (body.to_pyo3_ast(py)?,))?;

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ModExpression<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            body,
            range: _range,
        } = self;
        let instance = cache.0.call1(py, (body.to_pyo3_ast(py)?,))?;

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ModFunctionType<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            argtypes,
            returns,
            range: _range,
        } = self;
        let instance = cache
            .0
            .call1(py, (argtypes.to_pyo3_ast(py)?, returns.to_pyo3_ast(py)?))?;

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::generic::Stmt<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let instance = match &self {
            crate::Stmt::FunctionDef(cons) => cons.to_pyo3_ast(py)?,
            crate::Stmt::AsyncFunctionDef(cons) => cons.to_pyo3_ast(py)?,
            crate::Stmt::ClassDef(cons) => cons.to_pyo3_ast(py)?,
            crate::Stmt::Return(cons) => cons.to_pyo3_ast(py)?,
            crate::Stmt::Delete(cons) => cons.to_pyo3_ast(py)?,
            crate::Stmt::Assign(cons) => cons.to_pyo3_ast(py)?,
            crate::Stmt::AugAssign(cons) => cons.to_pyo3_ast(py)?,
            crate::Stmt::AnnAssign(cons) => cons.to_pyo3_ast(py)?,
            crate::Stmt::For(cons) => cons.to_pyo3_ast(py)?,
            crate::Stmt::AsyncFor(cons) => cons.to_pyo3_ast(py)?,
            crate::Stmt::While(cons) => cons.to_pyo3_ast(py)?,
            crate::Stmt::If(cons) => cons.to_pyo3_ast(py)?,
            crate::Stmt::With(cons) => cons.to_pyo3_ast(py)?,
            crate::Stmt::AsyncWith(cons) => cons.to_pyo3_ast(py)?,
            crate::Stmt::Match(cons) => cons.to_pyo3_ast(py)?,
            crate::Stmt::Raise(cons) => cons.to_pyo3_ast(py)?,
            crate::Stmt::Try(cons) => cons.to_pyo3_ast(py)?,
            crate::Stmt::TryStar(cons) => cons.to_pyo3_ast(py)?,
            crate::Stmt::Assert(cons) => cons.to_pyo3_ast(py)?,
            crate::Stmt::Import(cons) => cons.to_pyo3_ast(py)?,
            crate::Stmt::ImportFrom(cons) => cons.to_pyo3_ast(py)?,
            crate::Stmt::Global(cons) => cons.to_pyo3_ast(py)?,
            crate::Stmt::Nonlocal(cons) => cons.to_pyo3_ast(py)?,
            crate::Stmt::Expr(cons) => cons.to_pyo3_ast(py)?,
            crate::Stmt::Pass(cons) => cons.to_pyo3_ast(py)?,
            crate::Stmt::Break(cons) => cons.to_pyo3_ast(py)?,
            crate::Stmt::Continue(cons) => cons.to_pyo3_ast(py)?,
        };
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::StmtFunctionDef<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            name,
            args,
            body,
            decorator_list,
            returns,
            type_comment,
            range: _range,
        } = self;
        let instance = cache.0.call1(
            py,
            (
                name.to_pyo3_ast(py)?,
                args.to_pyo3_ast(py)?,
                body.to_pyo3_ast(py)?,
                decorator_list.to_pyo3_ast(py)?,
                returns.to_pyo3_ast(py)?,
                type_comment.to_pyo3_ast(py)?,
            ),
        )?;

        instance.setattr(py, "lineno", _range.start.row.get())?;
        instance.setattr(py, "col_offset", _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(py, "end_lineno", end.row.get())?;
            instance.setattr(py, "end_col_offset", end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::StmtAsyncFunctionDef<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            name,
            args,
            body,
            decorator_list,
            returns,
            type_comment,
            range: _range,
        } = self;
        let instance = cache.0.call1(
            py,
            (
                name.to_pyo3_ast(py)?,
                args.to_pyo3_ast(py)?,
                body.to_pyo3_ast(py)?,
                decorator_list.to_pyo3_ast(py)?,
                returns.to_pyo3_ast(py)?,
                type_comment.to_pyo3_ast(py)?,
            ),
        )?;

        instance.setattr(py, "lineno", _range.start.row.get())?;
        instance.setattr(py, "col_offset", _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(py, "end_lineno", end.row.get())?;
            instance.setattr(py, "end_col_offset", end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::StmtClassDef<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            name,
            bases,
            keywords,
            body,
            decorator_list,
            range: _range,
        } = self;
        let instance = cache.0.call1(
            py,
            (
                name.to_pyo3_ast(py)?,
                bases.to_pyo3_ast(py)?,
                keywords.to_pyo3_ast(py)?,
                body.to_pyo3_ast(py)?,
                decorator_list.to_pyo3_ast(py)?,
            ),
        )?;

        instance.setattr(py, "lineno", _range.start.row.get())?;
        instance.setattr(py, "col_offset", _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(py, "end_lineno", end.row.get())?;
            instance.setattr(py, "end_col_offset", end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::StmtReturn<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            value,
            range: _range,
        } = self;
        let instance = cache.0.call1(py, (value.to_pyo3_ast(py)?,))?;

        instance.setattr(py, "lineno", _range.start.row.get())?;
        instance.setattr(py, "col_offset", _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(py, "end_lineno", end.row.get())?;
            instance.setattr(py, "end_col_offset", end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::StmtDelete<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            targets,
            range: _range,
        } = self;
        let instance = cache.0.call1(py, (targets.to_pyo3_ast(py)?,))?;

        instance.setattr(py, "lineno", _range.start.row.get())?;
        instance.setattr(py, "col_offset", _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(py, "end_lineno", end.row.get())?;
            instance.setattr(py, "end_col_offset", end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::StmtAssign<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            targets,
            value,
            type_comment,
            range: _range,
        } = self;
        let instance = cache.0.call1(
            py,
            (
                targets.to_pyo3_ast(py)?,
                value.to_pyo3_ast(py)?,
                type_comment.to_pyo3_ast(py)?,
            ),
        )?;

        instance.setattr(py, "lineno", _range.start.row.get())?;
        instance.setattr(py, "col_offset", _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(py, "end_lineno", end.row.get())?;
            instance.setattr(py, "end_col_offset", end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::StmtAugAssign<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            target,
            op,
            value,
            range: _range,
        } = self;
        let instance = cache.0.call1(
            py,
            (
                target.to_pyo3_ast(py)?,
                op.to_pyo3_ast(py)?,
                value.to_pyo3_ast(py)?,
            ),
        )?;

        instance.setattr(py, "lineno", _range.start.row.get())?;
        instance.setattr(py, "col_offset", _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(py, "end_lineno", end.row.get())?;
            instance.setattr(py, "end_col_offset", end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::StmtAnnAssign<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            target,
            annotation,
            value,
            simple,
            range: _range,
        } = self;
        let instance = cache.0.call1(
            py,
            (
                target.to_pyo3_ast(py)?,
                annotation.to_pyo3_ast(py)?,
                value.to_pyo3_ast(py)?,
                simple.to_pyo3_ast(py)?,
            ),
        )?;

        instance.setattr(py, "lineno", _range.start.row.get())?;
        instance.setattr(py, "col_offset", _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(py, "end_lineno", end.row.get())?;
            instance.setattr(py, "end_col_offset", end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::StmtFor<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            target,
            iter,
            body,
            orelse,
            type_comment,
            range: _range,
        } = self;
        let instance = cache.0.call1(
            py,
            (
                target.to_pyo3_ast(py)?,
                iter.to_pyo3_ast(py)?,
                body.to_pyo3_ast(py)?,
                orelse.to_pyo3_ast(py)?,
                type_comment.to_pyo3_ast(py)?,
            ),
        )?;

        instance.setattr(py, "lineno", _range.start.row.get())?;
        instance.setattr(py, "col_offset", _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(py, "end_lineno", end.row.get())?;
            instance.setattr(py, "end_col_offset", end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::StmtAsyncFor<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            target,
            iter,
            body,
            orelse,
            type_comment,
            range: _range,
        } = self;
        let instance = cache.0.call1(
            py,
            (
                target.to_pyo3_ast(py)?,
                iter.to_pyo3_ast(py)?,
                body.to_pyo3_ast(py)?,
                orelse.to_pyo3_ast(py)?,
                type_comment.to_pyo3_ast(py)?,
            ),
        )?;

        instance.setattr(py, "lineno", _range.start.row.get())?;
        instance.setattr(py, "col_offset", _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(py, "end_lineno", end.row.get())?;
            instance.setattr(py, "end_col_offset", end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::StmtWhile<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            test,
            body,
            orelse,
            range: _range,
        } = self;
        let instance = cache.0.call1(
            py,
            (
                test.to_pyo3_ast(py)?,
                body.to_pyo3_ast(py)?,
                orelse.to_pyo3_ast(py)?,
            ),
        )?;

        instance.setattr(py, "lineno", _range.start.row.get())?;
        instance.setattr(py, "col_offset", _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(py, "end_lineno", end.row.get())?;
            instance.setattr(py, "end_col_offset", end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::StmtIf<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            test,
            body,
            orelse,
            range: _range,
        } = self;
        let instance = cache.0.call1(
            py,
            (
                test.to_pyo3_ast(py)?,
                body.to_pyo3_ast(py)?,
                orelse.to_pyo3_ast(py)?,
            ),
        )?;

        instance.setattr(py, "lineno", _range.start.row.get())?;
        instance.setattr(py, "col_offset", _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(py, "end_lineno", end.row.get())?;
            instance.setattr(py, "end_col_offset", end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::StmtWith<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            items,
            body,
            type_comment,
            range: _range,
        } = self;
        let instance = cache.0.call1(
            py,
            (
                items.to_pyo3_ast(py)?,
                body.to_pyo3_ast(py)?,
                type_comment.to_pyo3_ast(py)?,
            ),
        )?;

        instance.setattr(py, "lineno", _range.start.row.get())?;
        instance.setattr(py, "col_offset", _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(py, "end_lineno", end.row.get())?;
            instance.setattr(py, "end_col_offset", end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::StmtAsyncWith<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            items,
            body,
            type_comment,
            range: _range,
        } = self;
        let instance = cache.0.call1(
            py,
            (
                items.to_pyo3_ast(py)?,
                body.to_pyo3_ast(py)?,
                type_comment.to_pyo3_ast(py)?,
            ),
        )?;

        instance.setattr(py, "lineno", _range.start.row.get())?;
        instance.setattr(py, "col_offset", _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(py, "end_lineno", end.row.get())?;
            instance.setattr(py, "end_col_offset", end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::StmtMatch<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            subject,
            cases,
            range: _range,
        } = self;
        let instance = cache
            .0
            .call1(py, (subject.to_pyo3_ast(py)?, cases.to_pyo3_ast(py)?))?;

        instance.setattr(py, "lineno", _range.start.row.get())?;
        instance.setattr(py, "col_offset", _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(py, "end_lineno", end.row.get())?;
            instance.setattr(py, "end_col_offset", end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::StmtRaise<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            exc,
            cause,
            range: _range,
        } = self;
        let instance = cache
            .0
            .call1(py, (exc.to_pyo3_ast(py)?, cause.to_pyo3_ast(py)?))?;

        instance.setattr(py, "lineno", _range.start.row.get())?;
        instance.setattr(py, "col_offset", _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(py, "end_lineno", end.row.get())?;
            instance.setattr(py, "end_col_offset", end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::StmtTry<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            body,
            handlers,
            orelse,
            finalbody,
            range: _range,
        } = self;
        let instance = cache.0.call1(
            py,
            (
                body.to_pyo3_ast(py)?,
                handlers.to_pyo3_ast(py)?,
                orelse.to_pyo3_ast(py)?,
                finalbody.to_pyo3_ast(py)?,
            ),
        )?;

        instance.setattr(py, "lineno", _range.start.row.get())?;
        instance.setattr(py, "col_offset", _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(py, "end_lineno", end.row.get())?;
            instance.setattr(py, "end_col_offset", end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::StmtTryStar<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            body,
            handlers,
            orelse,
            finalbody,
            range: _range,
        } = self;
        let instance = cache.0.call1(
            py,
            (
                body.to_pyo3_ast(py)?,
                handlers.to_pyo3_ast(py)?,
                orelse.to_pyo3_ast(py)?,
                finalbody.to_pyo3_ast(py)?,
            ),
        )?;

        instance.setattr(py, "lineno", _range.start.row.get())?;
        instance.setattr(py, "col_offset", _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(py, "end_lineno", end.row.get())?;
            instance.setattr(py, "end_col_offset", end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::StmtAssert<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            test,
            msg,
            range: _range,
        } = self;
        let instance = cache
            .0
            .call1(py, (test.to_pyo3_ast(py)?, msg.to_pyo3_ast(py)?))?;

        instance.setattr(py, "lineno", _range.start.row.get())?;
        instance.setattr(py, "col_offset", _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(py, "end_lineno", end.row.get())?;
            instance.setattr(py, "end_col_offset", end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::StmtImport<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            names,
            range: _range,
        } = self;
        let instance = cache.0.call1(py, (names.to_pyo3_ast(py)?,))?;

        instance.setattr(py, "lineno", _range.start.row.get())?;
        instance.setattr(py, "col_offset", _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(py, "end_lineno", end.row.get())?;
            instance.setattr(py, "end_col_offset", end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::StmtImportFrom<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            module,
            names,
            level,
            range: _range,
        } = self;
        let instance = cache.0.call1(
            py,
            (
                module.to_pyo3_ast(py)?,
                names.to_pyo3_ast(py)?,
                level.to_pyo3_ast(py)?,
            ),
        )?;

        instance.setattr(py, "lineno", _range.start.row.get())?;
        instance.setattr(py, "col_offset", _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(py, "end_lineno", end.row.get())?;
            instance.setattr(py, "end_col_offset", end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::StmtGlobal<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            names,
            range: _range,
        } = self;
        let instance = cache.0.call1(py, (names.to_pyo3_ast(py)?,))?;

        instance.setattr(py, "lineno", _range.start.row.get())?;
        instance.setattr(py, "col_offset", _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(py, "end_lineno", end.row.get())?;
            instance.setattr(py, "end_col_offset", end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::StmtNonlocal<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            names,
            range: _range,
        } = self;
        let instance = cache.0.call1(py, (names.to_pyo3_ast(py)?,))?;

        instance.setattr(py, "lineno", _range.start.row.get())?;
        instance.setattr(py, "col_offset", _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(py, "end_lineno", end.row.get())?;
            instance.setattr(py, "end_col_offset", end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::StmtExpr<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            value,
            range: _range,
        } = self;
        let instance = cache.0.call1(py, (value.to_pyo3_ast(py)?,))?;

        instance.setattr(py, "lineno", _range.start.row.get())?;
        instance.setattr(py, "col_offset", _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(py, "end_lineno", end.row.get())?;
            instance.setattr(py, "end_col_offset", end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::StmtPass<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let instance = cache.0.call0(py)?;
        let Self { range: _range } = self;

        instance.setattr(py, "lineno", _range.start.row.get())?;
        instance.setattr(py, "col_offset", _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(py, "end_lineno", end.row.get())?;
            instance.setattr(py, "end_col_offset", end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::StmtBreak<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let instance = cache.0.call0(py)?;
        let Self { range: _range } = self;

        instance.setattr(py, "lineno", _range.start.row.get())?;
        instance.setattr(py, "col_offset", _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(py, "end_lineno", end.row.get())?;
            instance.setattr(py, "end_col_offset", end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::StmtContinue<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let instance = cache.0.call0(py)?;
        let Self { range: _range } = self;

        instance.setattr(py, "lineno", _range.start.row.get())?;
        instance.setattr(py, "col_offset", _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(py, "end_lineno", end.row.get())?;
            instance.setattr(py, "end_col_offset", end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::generic::Expr<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let instance = match &self {
            crate::Expr::BoolOp(cons) => cons.to_pyo3_ast(py)?,
            crate::Expr::NamedExpr(cons) => cons.to_pyo3_ast(py)?,
            crate::Expr::BinOp(cons) => cons.to_pyo3_ast(py)?,
            crate::Expr::UnaryOp(cons) => cons.to_pyo3_ast(py)?,
            crate::Expr::Lambda(cons) => cons.to_pyo3_ast(py)?,
            crate::Expr::IfExp(cons) => cons.to_pyo3_ast(py)?,
            crate::Expr::Dict(cons) => cons.to_pyo3_ast(py)?,
            crate::Expr::Set(cons) => cons.to_pyo3_ast(py)?,
            crate::Expr::ListComp(cons) => cons.to_pyo3_ast(py)?,
            crate::Expr::SetComp(cons) => cons.to_pyo3_ast(py)?,
            crate::Expr::DictComp(cons) => cons.to_pyo3_ast(py)?,
            crate::Expr::GeneratorExp(cons) => cons.to_pyo3_ast(py)?,
            crate::Expr::Await(cons) => cons.to_pyo3_ast(py)?,
            crate::Expr::Yield(cons) => cons.to_pyo3_ast(py)?,
            crate::Expr::YieldFrom(cons) => cons.to_pyo3_ast(py)?,
            crate::Expr::Compare(cons) => cons.to_pyo3_ast(py)?,
            crate::Expr::Call(cons) => cons.to_pyo3_ast(py)?,
            crate::Expr::FormattedValue(cons) => cons.to_pyo3_ast(py)?,
            crate::Expr::JoinedStr(cons) => cons.to_pyo3_ast(py)?,
            crate::Expr::Constant(cons) => cons.to_pyo3_ast(py)?,
            crate::Expr::Attribute(cons) => cons.to_pyo3_ast(py)?,
            crate::Expr::Subscript(cons) => cons.to_pyo3_ast(py)?,
            crate::Expr::Starred(cons) => cons.to_pyo3_ast(py)?,
            crate::Expr::Name(cons) => cons.to_pyo3_ast(py)?,
            crate::Expr::List(cons) => cons.to_pyo3_ast(py)?,
            crate::Expr::Tuple(cons) => cons.to_pyo3_ast(py)?,
            crate::Expr::Slice(cons) => cons.to_pyo3_ast(py)?,
        };
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ExprBoolOp<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            op,
            values,
            range: _range,
        } = self;
        let instance = cache
            .0
            .call1(py, (op.to_pyo3_ast(py)?, values.to_pyo3_ast(py)?))?;

        instance.setattr(py, "lineno", _range.start.row.get())?;
        instance.setattr(py, "col_offset", _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(py, "end_lineno", end.row.get())?;
            instance.setattr(py, "end_col_offset", end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ExprNamedExpr<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            target,
            value,
            range: _range,
        } = self;
        let instance = cache
            .0
            .call1(py, (target.to_pyo3_ast(py)?, value.to_pyo3_ast(py)?))?;

        instance.setattr(py, "lineno", _range.start.row.get())?;
        instance.setattr(py, "col_offset", _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(py, "end_lineno", end.row.get())?;
            instance.setattr(py, "end_col_offset", end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ExprBinOp<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            left,
            op,
            right,
            range: _range,
        } = self;
        let instance = cache.0.call1(
            py,
            (
                left.to_pyo3_ast(py)?,
                op.to_pyo3_ast(py)?,
                right.to_pyo3_ast(py)?,
            ),
        )?;

        instance.setattr(py, "lineno", _range.start.row.get())?;
        instance.setattr(py, "col_offset", _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(py, "end_lineno", end.row.get())?;
            instance.setattr(py, "end_col_offset", end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ExprUnaryOp<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            op,
            operand,
            range: _range,
        } = self;
        let instance = cache
            .0
            .call1(py, (op.to_pyo3_ast(py)?, operand.to_pyo3_ast(py)?))?;

        instance.setattr(py, "lineno", _range.start.row.get())?;
        instance.setattr(py, "col_offset", _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(py, "end_lineno", end.row.get())?;
            instance.setattr(py, "end_col_offset", end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ExprLambda<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            args,
            body,
            range: _range,
        } = self;
        let instance = cache
            .0
            .call1(py, (args.to_pyo3_ast(py)?, body.to_pyo3_ast(py)?))?;

        instance.setattr(py, "lineno", _range.start.row.get())?;
        instance.setattr(py, "col_offset", _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(py, "end_lineno", end.row.get())?;
            instance.setattr(py, "end_col_offset", end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ExprIfExp<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            test,
            body,
            orelse,
            range: _range,
        } = self;
        let instance = cache.0.call1(
            py,
            (
                test.to_pyo3_ast(py)?,
                body.to_pyo3_ast(py)?,
                orelse.to_pyo3_ast(py)?,
            ),
        )?;

        instance.setattr(py, "lineno", _range.start.row.get())?;
        instance.setattr(py, "col_offset", _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(py, "end_lineno", end.row.get())?;
            instance.setattr(py, "end_col_offset", end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ExprDict<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            keys,
            values,
            range: _range,
        } = self;
        let instance = cache
            .0
            .call1(py, (keys.to_pyo3_ast(py)?, values.to_pyo3_ast(py)?))?;

        instance.setattr(py, "lineno", _range.start.row.get())?;
        instance.setattr(py, "col_offset", _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(py, "end_lineno", end.row.get())?;
            instance.setattr(py, "end_col_offset", end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ExprSet<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            elts,
            range: _range,
        } = self;
        let instance = cache.0.call1(py, (elts.to_pyo3_ast(py)?,))?;

        instance.setattr(py, "lineno", _range.start.row.get())?;
        instance.setattr(py, "col_offset", _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(py, "end_lineno", end.row.get())?;
            instance.setattr(py, "end_col_offset", end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ExprListComp<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            elt,
            generators,
            range: _range,
        } = self;
        let instance = cache
            .0
            .call1(py, (elt.to_pyo3_ast(py)?, generators.to_pyo3_ast(py)?))?;

        instance.setattr(py, "lineno", _range.start.row.get())?;
        instance.setattr(py, "col_offset", _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(py, "end_lineno", end.row.get())?;
            instance.setattr(py, "end_col_offset", end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ExprSetComp<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            elt,
            generators,
            range: _range,
        } = self;
        let instance = cache
            .0
            .call1(py, (elt.to_pyo3_ast(py)?, generators.to_pyo3_ast(py)?))?;

        instance.setattr(py, "lineno", _range.start.row.get())?;
        instance.setattr(py, "col_offset", _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(py, "end_lineno", end.row.get())?;
            instance.setattr(py, "end_col_offset", end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ExprDictComp<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            key,
            value,
            generators,
            range: _range,
        } = self;
        let instance = cache.0.call1(
            py,
            (
                key.to_pyo3_ast(py)?,
                value.to_pyo3_ast(py)?,
                generators.to_pyo3_ast(py)?,
            ),
        )?;

        instance.setattr(py, "lineno", _range.start.row.get())?;
        instance.setattr(py, "col_offset", _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(py, "end_lineno", end.row.get())?;
            instance.setattr(py, "end_col_offset", end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ExprGeneratorExp<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            elt,
            generators,
            range: _range,
        } = self;
        let instance = cache
            .0
            .call1(py, (elt.to_pyo3_ast(py)?, generators.to_pyo3_ast(py)?))?;

        instance.setattr(py, "lineno", _range.start.row.get())?;
        instance.setattr(py, "col_offset", _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(py, "end_lineno", end.row.get())?;
            instance.setattr(py, "end_col_offset", end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ExprAwait<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            value,
            range: _range,
        } = self;
        let instance = cache.0.call1(py, (value.to_pyo3_ast(py)?,))?;

        instance.setattr(py, "lineno", _range.start.row.get())?;
        instance.setattr(py, "col_offset", _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(py, "end_lineno", end.row.get())?;
            instance.setattr(py, "end_col_offset", end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ExprYield<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            value,
            range: _range,
        } = self;
        let instance = cache.0.call1(py, (value.to_pyo3_ast(py)?,))?;

        instance.setattr(py, "lineno", _range.start.row.get())?;
        instance.setattr(py, "col_offset", _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(py, "end_lineno", end.row.get())?;
            instance.setattr(py, "end_col_offset", end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ExprYieldFrom<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            value,
            range: _range,
        } = self;
        let instance = cache.0.call1(py, (value.to_pyo3_ast(py)?,))?;

        instance.setattr(py, "lineno", _range.start.row.get())?;
        instance.setattr(py, "col_offset", _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(py, "end_lineno", end.row.get())?;
            instance.setattr(py, "end_col_offset", end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ExprCompare<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            left,
            ops,
            comparators,
            range: _range,
        } = self;
        let instance = cache.0.call1(
            py,
            (
                left.to_pyo3_ast(py)?,
                ops.to_pyo3_ast(py)?,
                comparators.to_pyo3_ast(py)?,
            ),
        )?;

        instance.setattr(py, "lineno", _range.start.row.get())?;
        instance.setattr(py, "col_offset", _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(py, "end_lineno", end.row.get())?;
            instance.setattr(py, "end_col_offset", end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ExprCall<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            func,
            args,
            keywords,
            range: _range,
        } = self;
        let instance = cache.0.call1(
            py,
            (
                func.to_pyo3_ast(py)?,
                args.to_pyo3_ast(py)?,
                keywords.to_pyo3_ast(py)?,
            ),
        )?;

        instance.setattr(py, "lineno", _range.start.row.get())?;
        instance.setattr(py, "col_offset", _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(py, "end_lineno", end.row.get())?;
            instance.setattr(py, "end_col_offset", end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ExprFormattedValue<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            value,
            conversion,
            format_spec,
            range: _range,
        } = self;
        let instance = cache.0.call1(
            py,
            (
                value.to_pyo3_ast(py)?,
                conversion.to_pyo3_ast(py)?,
                format_spec.to_pyo3_ast(py)?,
            ),
        )?;

        instance.setattr(py, "lineno", _range.start.row.get())?;
        instance.setattr(py, "col_offset", _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(py, "end_lineno", end.row.get())?;
            instance.setattr(py, "end_col_offset", end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ExprJoinedStr<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            values,
            range: _range,
        } = self;
        let instance = cache.0.call1(py, (values.to_pyo3_ast(py)?,))?;

        instance.setattr(py, "lineno", _range.start.row.get())?;
        instance.setattr(py, "col_offset", _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(py, "end_lineno", end.row.get())?;
            instance.setattr(py, "end_col_offset", end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ExprConstant<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            value,
            kind,
            range: _range,
        } = self;
        let instance = cache
            .0
            .call1(py, (value.to_pyo3_ast(py)?, kind.to_pyo3_ast(py)?))?;

        instance.setattr(py, "lineno", _range.start.row.get())?;
        instance.setattr(py, "col_offset", _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(py, "end_lineno", end.row.get())?;
            instance.setattr(py, "end_col_offset", end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ExprAttribute<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            value,
            attr,
            ctx,
            range: _range,
        } = self;
        let instance = cache.0.call1(
            py,
            (
                value.to_pyo3_ast(py)?,
                attr.to_pyo3_ast(py)?,
                ctx.to_pyo3_ast(py)?,
            ),
        )?;

        instance.setattr(py, "lineno", _range.start.row.get())?;
        instance.setattr(py, "col_offset", _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(py, "end_lineno", end.row.get())?;
            instance.setattr(py, "end_col_offset", end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ExprSubscript<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            value,
            slice,
            ctx,
            range: _range,
        } = self;
        let instance = cache.0.call1(
            py,
            (
                value.to_pyo3_ast(py)?,
                slice.to_pyo3_ast(py)?,
                ctx.to_pyo3_ast(py)?,
            ),
        )?;

        instance.setattr(py, "lineno", _range.start.row.get())?;
        instance.setattr(py, "col_offset", _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(py, "end_lineno", end.row.get())?;
            instance.setattr(py, "end_col_offset", end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ExprStarred<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            value,
            ctx,
            range: _range,
        } = self;
        let instance = cache
            .0
            .call1(py, (value.to_pyo3_ast(py)?, ctx.to_pyo3_ast(py)?))?;

        instance.setattr(py, "lineno", _range.start.row.get())?;
        instance.setattr(py, "col_offset", _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(py, "end_lineno", end.row.get())?;
            instance.setattr(py, "end_col_offset", end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ExprName<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            id,
            ctx,
            range: _range,
        } = self;
        let instance = cache
            .0
            .call1(py, (id.to_pyo3_ast(py)?, ctx.to_pyo3_ast(py)?))?;

        instance.setattr(py, "lineno", _range.start.row.get())?;
        instance.setattr(py, "col_offset", _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(py, "end_lineno", end.row.get())?;
            instance.setattr(py, "end_col_offset", end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ExprList<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            elts,
            ctx,
            range: _range,
        } = self;
        let instance = cache
            .0
            .call1(py, (elts.to_pyo3_ast(py)?, ctx.to_pyo3_ast(py)?))?;

        instance.setattr(py, "lineno", _range.start.row.get())?;
        instance.setattr(py, "col_offset", _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(py, "end_lineno", end.row.get())?;
            instance.setattr(py, "end_col_offset", end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ExprTuple<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            elts,
            ctx,
            range: _range,
        } = self;
        let instance = cache
            .0
            .call1(py, (elts.to_pyo3_ast(py)?, ctx.to_pyo3_ast(py)?))?;

        instance.setattr(py, "lineno", _range.start.row.get())?;
        instance.setattr(py, "col_offset", _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(py, "end_lineno", end.row.get())?;
            instance.setattr(py, "end_col_offset", end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ExprSlice<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            lower,
            upper,
            step,
            range: _range,
        } = self;
        let instance = cache.0.call1(
            py,
            (
                lower.to_pyo3_ast(py)?,
                upper.to_pyo3_ast(py)?,
                step.to_pyo3_ast(py)?,
            ),
        )?;

        instance.setattr(py, "lineno", _range.start.row.get())?;
        instance.setattr(py, "col_offset", _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(py, "end_lineno", end.row.get())?;
            instance.setattr(py, "end_col_offset", end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::Comprehension<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            target,
            iter,
            ifs,
            is_async,
            range: _range,
        } = self;
        let instance = cache.0.call1(
            py,
            (
                target.to_pyo3_ast(py)?,
                iter.to_pyo3_ast(py)?,
                ifs.to_pyo3_ast(py)?,
                is_async.to_pyo3_ast(py)?,
            ),
        )?;

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::generic::Excepthandler<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let instance = match &self {
            crate::Excepthandler::ExceptHandler(cons) => cons.to_pyo3_ast(py)?,
        };
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::ExcepthandlerExceptHandler<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            type_,
            name,
            body,
            range: _range,
        } = self;
        let instance = cache.0.call1(
            py,
            (
                type_.to_pyo3_ast(py)?,
                name.to_pyo3_ast(py)?,
                body.to_pyo3_ast(py)?,
            ),
        )?;

        instance.setattr(py, "lineno", _range.start.row.get())?;
        instance.setattr(py, "col_offset", _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(py, "end_lineno", end.row.get())?;
            instance.setattr(py, "end_col_offset", end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::Arguments<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            posonlyargs,
            args,
            vararg,
            kwonlyargs,
            kw_defaults,
            kwarg,
            defaults,
            range: _range,
        } = self;
        let instance = cache.0.call1(
            py,
            (
                posonlyargs.to_pyo3_ast(py)?,
                args.to_pyo3_ast(py)?,
                vararg.to_pyo3_ast(py)?,
                kwonlyargs.to_pyo3_ast(py)?,
                kw_defaults.to_pyo3_ast(py)?,
                kwarg.to_pyo3_ast(py)?,
                defaults.to_pyo3_ast(py)?,
            ),
        )?;

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::Arg<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            arg,
            annotation,
            type_comment,
            range: _range,
        } = self;
        let instance = cache.0.call1(
            py,
            (
                arg.to_pyo3_ast(py)?,
                annotation.to_pyo3_ast(py)?,
                type_comment.to_pyo3_ast(py)?,
            ),
        )?;

        instance.setattr(py, "lineno", _range.start.row.get())?;
        instance.setattr(py, "col_offset", _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(py, "end_lineno", end.row.get())?;
            instance.setattr(py, "end_col_offset", end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::Keyword<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            arg,
            value,
            range: _range,
        } = self;
        let instance = cache
            .0
            .call1(py, (arg.to_pyo3_ast(py)?, value.to_pyo3_ast(py)?))?;

        instance.setattr(py, "lineno", _range.start.row.get())?;
        instance.setattr(py, "col_offset", _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(py, "end_lineno", end.row.get())?;
            instance.setattr(py, "end_col_offset", end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::Alias<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            name,
            asname,
            range: _range,
        } = self;
        let instance = cache
            .0
            .call1(py, (name.to_pyo3_ast(py)?, asname.to_pyo3_ast(py)?))?;

        instance.setattr(py, "lineno", _range.start.row.get())?;
        instance.setattr(py, "col_offset", _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(py, "end_lineno", end.row.get())?;
            instance.setattr(py, "end_col_offset", end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::Withitem<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            context_expr,
            optional_vars,
            range: _range,
        } = self;
        let instance = cache.0.call1(
            py,
            (
                context_expr.to_pyo3_ast(py)?,
                optional_vars.to_pyo3_ast(py)?,
            ),
        )?;

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::MatchCase<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            pattern,
            guard,
            body,
            range: _range,
        } = self;
        let instance = cache.0.call1(
            py,
            (
                pattern.to_pyo3_ast(py)?,
                guard.to_pyo3_ast(py)?,
                body.to_pyo3_ast(py)?,
            ),
        )?;

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::generic::Pattern<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let instance = match &self {
            crate::Pattern::MatchValue(cons) => cons.to_pyo3_ast(py)?,
            crate::Pattern::MatchSingleton(cons) => cons.to_pyo3_ast(py)?,
            crate::Pattern::MatchSequence(cons) => cons.to_pyo3_ast(py)?,
            crate::Pattern::MatchMapping(cons) => cons.to_pyo3_ast(py)?,
            crate::Pattern::MatchClass(cons) => cons.to_pyo3_ast(py)?,
            crate::Pattern::MatchStar(cons) => cons.to_pyo3_ast(py)?,
            crate::Pattern::MatchAs(cons) => cons.to_pyo3_ast(py)?,
            crate::Pattern::MatchOr(cons) => cons.to_pyo3_ast(py)?,
        };
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::PatternMatchValue<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            value,
            range: _range,
        } = self;
        let instance = cache.0.call1(py, (value.to_pyo3_ast(py)?,))?;

        instance.setattr(py, "lineno", _range.start.row.get())?;
        instance.setattr(py, "col_offset", _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(py, "end_lineno", end.row.get())?;
            instance.setattr(py, "end_col_offset", end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::PatternMatchSingleton<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            value,
            range: _range,
        } = self;
        let instance = cache.0.call1(py, (value.to_pyo3_ast(py)?,))?;

        instance.setattr(py, "lineno", _range.start.row.get())?;
        instance.setattr(py, "col_offset", _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(py, "end_lineno", end.row.get())?;
            instance.setattr(py, "end_col_offset", end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::PatternMatchSequence<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            patterns,
            range: _range,
        } = self;
        let instance = cache.0.call1(py, (patterns.to_pyo3_ast(py)?,))?;

        instance.setattr(py, "lineno", _range.start.row.get())?;
        instance.setattr(py, "col_offset", _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(py, "end_lineno", end.row.get())?;
            instance.setattr(py, "end_col_offset", end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::PatternMatchMapping<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            keys,
            patterns,
            rest,
            range: _range,
        } = self;
        let instance = cache.0.call1(
            py,
            (
                keys.to_pyo3_ast(py)?,
                patterns.to_pyo3_ast(py)?,
                rest.to_pyo3_ast(py)?,
            ),
        )?;

        instance.setattr(py, "lineno", _range.start.row.get())?;
        instance.setattr(py, "col_offset", _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(py, "end_lineno", end.row.get())?;
            instance.setattr(py, "end_col_offset", end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::PatternMatchClass<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            cls,
            patterns,
            kwd_attrs,
            kwd_patterns,
            range: _range,
        } = self;
        let instance = cache.0.call1(
            py,
            (
                cls.to_pyo3_ast(py)?,
                patterns.to_pyo3_ast(py)?,
                kwd_attrs.to_pyo3_ast(py)?,
                kwd_patterns.to_pyo3_ast(py)?,
            ),
        )?;

        instance.setattr(py, "lineno", _range.start.row.get())?;
        instance.setattr(py, "col_offset", _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(py, "end_lineno", end.row.get())?;
            instance.setattr(py, "end_col_offset", end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::PatternMatchStar<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            name,
            range: _range,
        } = self;
        let instance = cache.0.call1(py, (name.to_pyo3_ast(py)?,))?;

        instance.setattr(py, "lineno", _range.start.row.get())?;
        instance.setattr(py, "col_offset", _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(py, "end_lineno", end.row.get())?;
            instance.setattr(py, "end_col_offset", end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::PatternMatchAs<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            pattern,
            name,
            range: _range,
        } = self;
        let instance = cache
            .0
            .call1(py, (pattern.to_pyo3_ast(py)?, name.to_pyo3_ast(py)?))?;

        instance.setattr(py, "lineno", _range.start.row.get())?;
        instance.setattr(py, "col_offset", _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(py, "end_lineno", end.row.get())?;
            instance.setattr(py, "end_col_offset", end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::PatternMatchOr<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            patterns,
            range: _range,
        } = self;
        let instance = cache.0.call1(py, (patterns.to_pyo3_ast(py)?,))?;

        instance.setattr(py, "lineno", _range.start.row.get())?;
        instance.setattr(py, "col_offset", _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(py, "end_lineno", end.row.get())?;
            instance.setattr(py, "end_col_offset", end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyo3Ast for crate::generic::TypeIgnore<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let instance = match &self {
            crate::TypeIgnore::TypeIgnore(cons) => cons.to_pyo3_ast(py)?,
        };
        Ok(instance)
    }
}

impl ToPyo3Ast for crate::TypeIgnoreTypeIgnore<SourceRange> {
    #[inline]
    fn to_pyo3_ast(&self, py: Python) -> PyResult<Py<PyAny>> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            lineno,
            tag,
            range: _range,
        } = self;
        let instance = cache
            .0
            .call1(py, (lineno.to_pyo3_ast(py)?, tag.to_pyo3_ast(py)?))?;

        Ok(instance)
    }
}

fn init_types(py: Python) -> PyResult<()> {
    let ast_module = PyModule::import(py, "_ast")?;
    cache_py_type::<crate::generic::Mod>(ast_module)?;
    cache_py_type::<crate::generic::ModModule>(ast_module)?;
    cache_py_type::<crate::generic::ModInteractive>(ast_module)?;
    cache_py_type::<crate::generic::ModExpression>(ast_module)?;
    cache_py_type::<crate::generic::ModFunctionType>(ast_module)?;
    cache_py_type::<crate::generic::Stmt>(ast_module)?;
    cache_py_type::<crate::generic::StmtFunctionDef>(ast_module)?;
    cache_py_type::<crate::generic::StmtAsyncFunctionDef>(ast_module)?;
    cache_py_type::<crate::generic::StmtClassDef>(ast_module)?;
    cache_py_type::<crate::generic::StmtReturn>(ast_module)?;
    cache_py_type::<crate::generic::StmtDelete>(ast_module)?;
    cache_py_type::<crate::generic::StmtAssign>(ast_module)?;
    cache_py_type::<crate::generic::StmtAugAssign>(ast_module)?;
    cache_py_type::<crate::generic::StmtAnnAssign>(ast_module)?;
    cache_py_type::<crate::generic::StmtFor>(ast_module)?;
    cache_py_type::<crate::generic::StmtAsyncFor>(ast_module)?;
    cache_py_type::<crate::generic::StmtWhile>(ast_module)?;
    cache_py_type::<crate::generic::StmtIf>(ast_module)?;
    cache_py_type::<crate::generic::StmtWith>(ast_module)?;
    cache_py_type::<crate::generic::StmtAsyncWith>(ast_module)?;
    cache_py_type::<crate::generic::StmtMatch>(ast_module)?;
    cache_py_type::<crate::generic::StmtRaise>(ast_module)?;
    cache_py_type::<crate::generic::StmtTry>(ast_module)?;
    cache_py_type::<crate::generic::StmtTryStar>(ast_module)?;
    cache_py_type::<crate::generic::StmtAssert>(ast_module)?;
    cache_py_type::<crate::generic::StmtImport>(ast_module)?;
    cache_py_type::<crate::generic::StmtImportFrom>(ast_module)?;
    cache_py_type::<crate::generic::StmtGlobal>(ast_module)?;
    cache_py_type::<crate::generic::StmtNonlocal>(ast_module)?;
    cache_py_type::<crate::generic::StmtExpr>(ast_module)?;
    cache_py_type::<crate::generic::StmtPass>(ast_module)?;
    cache_py_type::<crate::generic::StmtBreak>(ast_module)?;
    cache_py_type::<crate::generic::StmtContinue>(ast_module)?;
    cache_py_type::<crate::generic::Expr>(ast_module)?;
    cache_py_type::<crate::generic::ExprBoolOp>(ast_module)?;
    cache_py_type::<crate::generic::ExprNamedExpr>(ast_module)?;
    cache_py_type::<crate::generic::ExprBinOp>(ast_module)?;
    cache_py_type::<crate::generic::ExprUnaryOp>(ast_module)?;
    cache_py_type::<crate::generic::ExprLambda>(ast_module)?;
    cache_py_type::<crate::generic::ExprIfExp>(ast_module)?;
    cache_py_type::<crate::generic::ExprDict>(ast_module)?;
    cache_py_type::<crate::generic::ExprSet>(ast_module)?;
    cache_py_type::<crate::generic::ExprListComp>(ast_module)?;
    cache_py_type::<crate::generic::ExprSetComp>(ast_module)?;
    cache_py_type::<crate::generic::ExprDictComp>(ast_module)?;
    cache_py_type::<crate::generic::ExprGeneratorExp>(ast_module)?;
    cache_py_type::<crate::generic::ExprAwait>(ast_module)?;
    cache_py_type::<crate::generic::ExprYield>(ast_module)?;
    cache_py_type::<crate::generic::ExprYieldFrom>(ast_module)?;
    cache_py_type::<crate::generic::ExprCompare>(ast_module)?;
    cache_py_type::<crate::generic::ExprCall>(ast_module)?;
    cache_py_type::<crate::generic::ExprFormattedValue>(ast_module)?;
    cache_py_type::<crate::generic::ExprJoinedStr>(ast_module)?;
    cache_py_type::<crate::generic::ExprConstant>(ast_module)?;
    cache_py_type::<crate::generic::ExprAttribute>(ast_module)?;
    cache_py_type::<crate::generic::ExprSubscript>(ast_module)?;
    cache_py_type::<crate::generic::ExprStarred>(ast_module)?;
    cache_py_type::<crate::generic::ExprName>(ast_module)?;
    cache_py_type::<crate::generic::ExprList>(ast_module)?;
    cache_py_type::<crate::generic::ExprTuple>(ast_module)?;
    cache_py_type::<crate::generic::ExprSlice>(ast_module)?;
    cache_py_type::<crate::generic::ExprContext>(ast_module)?;
    cache_py_type::<crate::generic::ExprContextLoad>(ast_module)?;
    cache_py_type::<crate::generic::ExprContextStore>(ast_module)?;
    cache_py_type::<crate::generic::ExprContextDel>(ast_module)?;
    cache_py_type::<crate::generic::Boolop>(ast_module)?;
    cache_py_type::<crate::generic::BoolopAnd>(ast_module)?;
    cache_py_type::<crate::generic::BoolopOr>(ast_module)?;
    cache_py_type::<crate::generic::Operator>(ast_module)?;
    cache_py_type::<crate::generic::OperatorAdd>(ast_module)?;
    cache_py_type::<crate::generic::OperatorSub>(ast_module)?;
    cache_py_type::<crate::generic::OperatorMult>(ast_module)?;
    cache_py_type::<crate::generic::OperatorMatMult>(ast_module)?;
    cache_py_type::<crate::generic::OperatorDiv>(ast_module)?;
    cache_py_type::<crate::generic::OperatorMod>(ast_module)?;
    cache_py_type::<crate::generic::OperatorPow>(ast_module)?;
    cache_py_type::<crate::generic::OperatorLShift>(ast_module)?;
    cache_py_type::<crate::generic::OperatorRShift>(ast_module)?;
    cache_py_type::<crate::generic::OperatorBitOr>(ast_module)?;
    cache_py_type::<crate::generic::OperatorBitXor>(ast_module)?;
    cache_py_type::<crate::generic::OperatorBitAnd>(ast_module)?;
    cache_py_type::<crate::generic::OperatorFloorDiv>(ast_module)?;
    cache_py_type::<crate::generic::Unaryop>(ast_module)?;
    cache_py_type::<crate::generic::UnaryopInvert>(ast_module)?;
    cache_py_type::<crate::generic::UnaryopNot>(ast_module)?;
    cache_py_type::<crate::generic::UnaryopUAdd>(ast_module)?;
    cache_py_type::<crate::generic::UnaryopUSub>(ast_module)?;
    cache_py_type::<crate::generic::Cmpop>(ast_module)?;
    cache_py_type::<crate::generic::CmpopEq>(ast_module)?;
    cache_py_type::<crate::generic::CmpopNotEq>(ast_module)?;
    cache_py_type::<crate::generic::CmpopLt>(ast_module)?;
    cache_py_type::<crate::generic::CmpopLtE>(ast_module)?;
    cache_py_type::<crate::generic::CmpopGt>(ast_module)?;
    cache_py_type::<crate::generic::CmpopGtE>(ast_module)?;
    cache_py_type::<crate::generic::CmpopIs>(ast_module)?;
    cache_py_type::<crate::generic::CmpopIsNot>(ast_module)?;
    cache_py_type::<crate::generic::CmpopIn>(ast_module)?;
    cache_py_type::<crate::generic::CmpopNotIn>(ast_module)?;
    cache_py_type::<crate::generic::Comprehension>(ast_module)?;
    cache_py_type::<crate::generic::Excepthandler>(ast_module)?;
    cache_py_type::<crate::generic::ExcepthandlerExceptHandler>(ast_module)?;
    cache_py_type::<crate::generic::Arguments>(ast_module)?;
    cache_py_type::<crate::generic::Arg>(ast_module)?;
    cache_py_type::<crate::generic::Keyword>(ast_module)?;
    cache_py_type::<crate::generic::Alias>(ast_module)?;
    cache_py_type::<crate::generic::Withitem>(ast_module)?;
    cache_py_type::<crate::generic::MatchCase>(ast_module)?;
    cache_py_type::<crate::generic::Pattern>(ast_module)?;
    cache_py_type::<crate::generic::PatternMatchValue>(ast_module)?;
    cache_py_type::<crate::generic::PatternMatchSingleton>(ast_module)?;
    cache_py_type::<crate::generic::PatternMatchSequence>(ast_module)?;
    cache_py_type::<crate::generic::PatternMatchMapping>(ast_module)?;
    cache_py_type::<crate::generic::PatternMatchClass>(ast_module)?;
    cache_py_type::<crate::generic::PatternMatchStar>(ast_module)?;
    cache_py_type::<crate::generic::PatternMatchAs>(ast_module)?;
    cache_py_type::<crate::generic::PatternMatchOr>(ast_module)?;
    cache_py_type::<crate::generic::TypeIgnore>(ast_module)?;
    cache_py_type::<crate::generic::TypeIgnoreTypeIgnore>(ast_module)?;
    Ok(())
}
