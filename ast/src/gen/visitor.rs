// File automatically generated by ast/asdl_rs.py.

#[allow(unused_variables, non_snake_case)]
pub trait Visitor<R = crate::text_size::TextRange> {
    fn visit_stmt(&mut self, node: Stmt<R>) {
        self.generic_visit_stmt(node)
    }
    fn generic_visit_stmt(&mut self, node: Stmt<R>) {
        match node {
            Stmt::FunctionDef(data) => self.visit_stmt_FunctionDef(data),
            Stmt::AsyncFunctionDef(data) => self.visit_stmt_AsyncFunctionDef(data),
            Stmt::ClassDef(data) => self.visit_stmt_ClassDef(data),
            Stmt::Return(data) => self.visit_stmt_Return(data),
            Stmt::Delete(data) => self.visit_stmt_Delete(data),
            Stmt::Assign(data) => self.visit_stmt_Assign(data),
            Stmt::AugAssign(data) => self.visit_stmt_AugAssign(data),
            Stmt::AnnAssign(data) => self.visit_stmt_AnnAssign(data),
            Stmt::For(data) => self.visit_stmt_For(data),
            Stmt::AsyncFor(data) => self.visit_stmt_AsyncFor(data),
            Stmt::While(data) => self.visit_stmt_While(data),
            Stmt::If(data) => self.visit_stmt_If(data),
            Stmt::With(data) => self.visit_stmt_With(data),
            Stmt::AsyncWith(data) => self.visit_stmt_AsyncWith(data),
            Stmt::Match(data) => self.visit_stmt_Match(data),
            Stmt::Raise(data) => self.visit_stmt_Raise(data),
            Stmt::Try(data) => self.visit_stmt_Try(data),
            Stmt::TryStar(data) => self.visit_stmt_TryStar(data),
            Stmt::Assert(data) => self.visit_stmt_Assert(data),
            Stmt::Import(data) => self.visit_stmt_Import(data),
            Stmt::ImportFrom(data) => self.visit_stmt_ImportFrom(data),
            Stmt::Global(data) => self.visit_stmt_Global(data),
            Stmt::Nonlocal(data) => self.visit_stmt_Nonlocal(data),
            Stmt::Expr(data) => self.visit_stmt_Expr(data),
            Stmt::Pass(data) => self.visit_stmt_Pass(data),
            Stmt::Break(data) => self.visit_stmt_Break(data),
            Stmt::Continue(data) => self.visit_stmt_Continue(data),
        }
    }
    fn visit_stmt_FunctionDef(&mut self, node: StmtFunctionDef<R>) {
        self.generic_visit_stmt_FunctionDef(node)
    }
    fn generic_visit_stmt_FunctionDef(&mut self, node: StmtFunctionDef<R>) {
        {
            let value = node.args;
            self.visit_arguments(*value);
        }
        for value in node.body {
            self.visit_stmt(value);
        }
        for value in node.decorator_list {
            self.visit_expr(value);
        }
        if let Some(value) = node.returns {
            self.visit_expr(*value);
        }
    }
    fn visit_stmt_AsyncFunctionDef(&mut self, node: StmtAsyncFunctionDef<R>) {
        self.generic_visit_stmt_AsyncFunctionDef(node)
    }
    fn generic_visit_stmt_AsyncFunctionDef(&mut self, node: StmtAsyncFunctionDef<R>) {
        {
            let value = node.args;
            self.visit_arguments(*value);
        }
        for value in node.body {
            self.visit_stmt(value);
        }
        for value in node.decorator_list {
            self.visit_expr(value);
        }
        if let Some(value) = node.returns {
            self.visit_expr(*value);
        }
    }
    fn visit_stmt_ClassDef(&mut self, node: StmtClassDef<R>) {
        self.generic_visit_stmt_ClassDef(node)
    }
    fn generic_visit_stmt_ClassDef(&mut self, node: StmtClassDef<R>) {
        for value in node.bases {
            self.visit_expr(value);
        }
        for value in node.keywords {
            self.visit_keyword(value);
        }
        for value in node.body {
            self.visit_stmt(value);
        }
        for value in node.decorator_list {
            self.visit_expr(value);
        }
    }
    fn visit_stmt_Return(&mut self, node: StmtReturn<R>) {
        self.generic_visit_stmt_Return(node)
    }
    fn generic_visit_stmt_Return(&mut self, node: StmtReturn<R>) {
        if let Some(value) = node.value {
            self.visit_expr(*value);
        }
    }
    fn visit_stmt_Delete(&mut self, node: StmtDelete<R>) {
        self.generic_visit_stmt_Delete(node)
    }
    fn generic_visit_stmt_Delete(&mut self, node: StmtDelete<R>) {
        for value in node.targets {
            self.visit_expr(value);
        }
    }
    fn visit_stmt_Assign(&mut self, node: StmtAssign<R>) {
        self.generic_visit_stmt_Assign(node)
    }
    fn generic_visit_stmt_Assign(&mut self, node: StmtAssign<R>) {
        for value in node.targets {
            self.visit_expr(value);
        }
        {
            let value = node.value;
            self.visit_expr(*value);
        }
    }
    fn visit_stmt_AugAssign(&mut self, node: StmtAugAssign<R>) {
        self.generic_visit_stmt_AugAssign(node)
    }
    fn generic_visit_stmt_AugAssign(&mut self, node: StmtAugAssign<R>) {
        {
            let value = node.target;
            self.visit_expr(*value);
        }
        {
            let value = node.value;
            self.visit_expr(*value);
        }
    }
    fn visit_stmt_AnnAssign(&mut self, node: StmtAnnAssign<R>) {
        self.generic_visit_stmt_AnnAssign(node)
    }
    fn generic_visit_stmt_AnnAssign(&mut self, node: StmtAnnAssign<R>) {
        {
            let value = node.target;
            self.visit_expr(*value);
        }
        {
            let value = node.annotation;
            self.visit_expr(*value);
        }
        if let Some(value) = node.value {
            self.visit_expr(*value);
        }
    }
    fn visit_stmt_For(&mut self, node: StmtFor<R>) {
        self.generic_visit_stmt_For(node)
    }
    fn generic_visit_stmt_For(&mut self, node: StmtFor<R>) {
        {
            let value = node.target;
            self.visit_expr(*value);
        }
        {
            let value = node.iter;
            self.visit_expr(*value);
        }
        for value in node.body {
            self.visit_stmt(value);
        }
        for value in node.orelse {
            self.visit_stmt(value);
        }
    }
    fn visit_stmt_AsyncFor(&mut self, node: StmtAsyncFor<R>) {
        self.generic_visit_stmt_AsyncFor(node)
    }
    fn generic_visit_stmt_AsyncFor(&mut self, node: StmtAsyncFor<R>) {
        {
            let value = node.target;
            self.visit_expr(*value);
        }
        {
            let value = node.iter;
            self.visit_expr(*value);
        }
        for value in node.body {
            self.visit_stmt(value);
        }
        for value in node.orelse {
            self.visit_stmt(value);
        }
    }
    fn visit_stmt_While(&mut self, node: StmtWhile<R>) {
        self.generic_visit_stmt_While(node)
    }
    fn generic_visit_stmt_While(&mut self, node: StmtWhile<R>) {
        {
            let value = node.test;
            self.visit_expr(*value);
        }
        for value in node.body {
            self.visit_stmt(value);
        }
        for value in node.orelse {
            self.visit_stmt(value);
        }
    }
    fn visit_stmt_If(&mut self, node: StmtIf<R>) {
        self.generic_visit_stmt_If(node)
    }
    fn generic_visit_stmt_If(&mut self, node: StmtIf<R>) {
        {
            let value = node.test;
            self.visit_expr(*value);
        }
        for value in node.body {
            self.visit_stmt(value);
        }
        for value in node.orelse {
            self.visit_stmt(value);
        }
    }
    fn visit_stmt_With(&mut self, node: StmtWith<R>) {
        self.generic_visit_stmt_With(node)
    }
    fn generic_visit_stmt_With(&mut self, node: StmtWith<R>) {
        for value in node.items {
            self.visit_withitem(value);
        }
        for value in node.body {
            self.visit_stmt(value);
        }
    }
    fn visit_stmt_AsyncWith(&mut self, node: StmtAsyncWith<R>) {
        self.generic_visit_stmt_AsyncWith(node)
    }
    fn generic_visit_stmt_AsyncWith(&mut self, node: StmtAsyncWith<R>) {
        for value in node.items {
            self.visit_withitem(value);
        }
        for value in node.body {
            self.visit_stmt(value);
        }
    }
    fn visit_stmt_Match(&mut self, node: StmtMatch<R>) {
        self.generic_visit_stmt_Match(node)
    }
    fn generic_visit_stmt_Match(&mut self, node: StmtMatch<R>) {
        {
            let value = node.subject;
            self.visit_expr(*value);
        }
        for value in node.cases {
            self.visit_match_case(value);
        }
    }
    fn visit_stmt_Raise(&mut self, node: StmtRaise<R>) {
        self.generic_visit_stmt_Raise(node)
    }
    fn generic_visit_stmt_Raise(&mut self, node: StmtRaise<R>) {
        if let Some(value) = node.exc {
            self.visit_expr(*value);
        }
        if let Some(value) = node.cause {
            self.visit_expr(*value);
        }
    }
    fn visit_stmt_Try(&mut self, node: StmtTry<R>) {
        self.generic_visit_stmt_Try(node)
    }
    fn generic_visit_stmt_Try(&mut self, node: StmtTry<R>) {
        for value in node.body {
            self.visit_stmt(value);
        }
        for value in node.handlers {
            self.visit_excepthandler(value);
        }
        for value in node.orelse {
            self.visit_stmt(value);
        }
        for value in node.finalbody {
            self.visit_stmt(value);
        }
    }
    fn visit_stmt_TryStar(&mut self, node: StmtTryStar<R>) {
        self.generic_visit_stmt_TryStar(node)
    }
    fn generic_visit_stmt_TryStar(&mut self, node: StmtTryStar<R>) {
        for value in node.body {
            self.visit_stmt(value);
        }
        for value in node.handlers {
            self.visit_excepthandler(value);
        }
        for value in node.orelse {
            self.visit_stmt(value);
        }
        for value in node.finalbody {
            self.visit_stmt(value);
        }
    }
    fn visit_stmt_Assert(&mut self, node: StmtAssert<R>) {
        self.generic_visit_stmt_Assert(node)
    }
    fn generic_visit_stmt_Assert(&mut self, node: StmtAssert<R>) {
        {
            let value = node.test;
            self.visit_expr(*value);
        }
        if let Some(value) = node.msg {
            self.visit_expr(*value);
        }
    }
    fn visit_stmt_Import(&mut self, node: StmtImport<R>) {
        self.generic_visit_stmt_Import(node)
    }
    fn generic_visit_stmt_Import(&mut self, node: StmtImport<R>) {
        for value in node.names {
            self.visit_alias(value);
        }
    }
    fn visit_stmt_ImportFrom(&mut self, node: StmtImportFrom<R>) {
        self.generic_visit_stmt_ImportFrom(node)
    }
    fn generic_visit_stmt_ImportFrom(&mut self, node: StmtImportFrom<R>) {
        for value in node.names {
            self.visit_alias(value);
        }
    }
    fn visit_stmt_Global(&mut self, node: StmtGlobal<R>) {
        self.generic_visit_stmt_Global(node)
    }
    fn generic_visit_stmt_Global(&mut self, node: StmtGlobal<R>) {}
    fn visit_stmt_Nonlocal(&mut self, node: StmtNonlocal<R>) {
        self.generic_visit_stmt_Nonlocal(node)
    }
    fn generic_visit_stmt_Nonlocal(&mut self, node: StmtNonlocal<R>) {}
    fn visit_stmt_Expr(&mut self, node: StmtExpr<R>) {
        self.generic_visit_stmt_Expr(node)
    }
    fn generic_visit_stmt_Expr(&mut self, node: StmtExpr<R>) {
        {
            let value = node.value;
            self.visit_expr(*value);
        }
    }
    fn visit_stmt_Pass(&mut self, node: StmtPass<R>) {}
    fn visit_stmt_Break(&mut self, node: StmtBreak<R>) {}
    fn visit_stmt_Continue(&mut self, node: StmtContinue<R>) {}
    fn visit_expr(&mut self, node: Expr<R>) {
        self.generic_visit_expr(node)
    }
    fn generic_visit_expr(&mut self, node: Expr<R>) {
        match node {
            Expr::BoolOp(data) => self.visit_expr_BoolOp(data),
            Expr::NamedExpr(data) => self.visit_expr_NamedExpr(data),
            Expr::BinOp(data) => self.visit_expr_BinOp(data),
            Expr::UnaryOp(data) => self.visit_expr_UnaryOp(data),
            Expr::Lambda(data) => self.visit_expr_Lambda(data),
            Expr::IfExp(data) => self.visit_expr_IfExp(data),
            Expr::Dict(data) => self.visit_expr_Dict(data),
            Expr::Set(data) => self.visit_expr_Set(data),
            Expr::ListComp(data) => self.visit_expr_ListComp(data),
            Expr::SetComp(data) => self.visit_expr_SetComp(data),
            Expr::DictComp(data) => self.visit_expr_DictComp(data),
            Expr::GeneratorExp(data) => self.visit_expr_GeneratorExp(data),
            Expr::Await(data) => self.visit_expr_Await(data),
            Expr::Yield(data) => self.visit_expr_Yield(data),
            Expr::YieldFrom(data) => self.visit_expr_YieldFrom(data),
            Expr::Compare(data) => self.visit_expr_Compare(data),
            Expr::Call(data) => self.visit_expr_Call(data),
            Expr::FormattedValue(data) => self.visit_expr_FormattedValue(data),
            Expr::JoinedStr(data) => self.visit_expr_JoinedStr(data),
            Expr::Constant(data) => self.visit_expr_Constant(data),
            Expr::Attribute(data) => self.visit_expr_Attribute(data),
            Expr::Subscript(data) => self.visit_expr_Subscript(data),
            Expr::Starred(data) => self.visit_expr_Starred(data),
            Expr::Name(data) => self.visit_expr_Name(data),
            Expr::List(data) => self.visit_expr_List(data),
            Expr::Tuple(data) => self.visit_expr_Tuple(data),
            Expr::Slice(data) => self.visit_expr_Slice(data),
        }
    }
    fn visit_expr_BoolOp(&mut self, node: ExprBoolOp<R>) {
        self.generic_visit_expr_BoolOp(node)
    }
    fn generic_visit_expr_BoolOp(&mut self, node: ExprBoolOp<R>) {
        for value in node.values {
            self.visit_expr(value);
        }
    }
    fn visit_expr_NamedExpr(&mut self, node: ExprNamedExpr<R>) {
        self.generic_visit_expr_NamedExpr(node)
    }
    fn generic_visit_expr_NamedExpr(&mut self, node: ExprNamedExpr<R>) {
        {
            let value = node.target;
            self.visit_expr(*value);
        }
        {
            let value = node.value;
            self.visit_expr(*value);
        }
    }
    fn visit_expr_BinOp(&mut self, node: ExprBinOp<R>) {
        self.generic_visit_expr_BinOp(node)
    }
    fn generic_visit_expr_BinOp(&mut self, node: ExprBinOp<R>) {
        {
            let value = node.left;
            self.visit_expr(*value);
        }
        {
            let value = node.right;
            self.visit_expr(*value);
        }
    }
    fn visit_expr_UnaryOp(&mut self, node: ExprUnaryOp<R>) {
        self.generic_visit_expr_UnaryOp(node)
    }
    fn generic_visit_expr_UnaryOp(&mut self, node: ExprUnaryOp<R>) {
        {
            let value = node.operand;
            self.visit_expr(*value);
        }
    }
    fn visit_expr_Lambda(&mut self, node: ExprLambda<R>) {
        self.generic_visit_expr_Lambda(node)
    }
    fn generic_visit_expr_Lambda(&mut self, node: ExprLambda<R>) {
        {
            let value = node.args;
            self.visit_arguments(*value);
        }
        {
            let value = node.body;
            self.visit_expr(*value);
        }
    }
    fn visit_expr_IfExp(&mut self, node: ExprIfExp<R>) {
        self.generic_visit_expr_IfExp(node)
    }
    fn generic_visit_expr_IfExp(&mut self, node: ExprIfExp<R>) {
        {
            let value = node.test;
            self.visit_expr(*value);
        }
        {
            let value = node.body;
            self.visit_expr(*value);
        }
        {
            let value = node.orelse;
            self.visit_expr(*value);
        }
    }
    fn visit_expr_Dict(&mut self, node: ExprDict<R>) {
        self.generic_visit_expr_Dict(node)
    }
    fn generic_visit_expr_Dict(&mut self, node: ExprDict<R>) {
        for value in node.keys.into_iter().flatten() {
            self.visit_expr(value);
        }
        for value in node.values {
            self.visit_expr(value);
        }
    }
    fn visit_expr_Set(&mut self, node: ExprSet<R>) {
        self.generic_visit_expr_Set(node)
    }
    fn generic_visit_expr_Set(&mut self, node: ExprSet<R>) {
        for value in node.elts {
            self.visit_expr(value);
        }
    }
    fn visit_expr_ListComp(&mut self, node: ExprListComp<R>) {
        self.generic_visit_expr_ListComp(node)
    }
    fn generic_visit_expr_ListComp(&mut self, node: ExprListComp<R>) {
        {
            let value = node.elt;
            self.visit_expr(*value);
        }
        for value in node.generators {
            self.visit_comprehension(value);
        }
    }
    fn visit_expr_SetComp(&mut self, node: ExprSetComp<R>) {
        self.generic_visit_expr_SetComp(node)
    }
    fn generic_visit_expr_SetComp(&mut self, node: ExprSetComp<R>) {
        {
            let value = node.elt;
            self.visit_expr(*value);
        }
        for value in node.generators {
            self.visit_comprehension(value);
        }
    }
    fn visit_expr_DictComp(&mut self, node: ExprDictComp<R>) {
        self.generic_visit_expr_DictComp(node)
    }
    fn generic_visit_expr_DictComp(&mut self, node: ExprDictComp<R>) {
        {
            let value = node.key;
            self.visit_expr(*value);
        }
        {
            let value = node.value;
            self.visit_expr(*value);
        }
        for value in node.generators {
            self.visit_comprehension(value);
        }
    }
    fn visit_expr_GeneratorExp(&mut self, node: ExprGeneratorExp<R>) {
        self.generic_visit_expr_GeneratorExp(node)
    }
    fn generic_visit_expr_GeneratorExp(&mut self, node: ExprGeneratorExp<R>) {
        {
            let value = node.elt;
            self.visit_expr(*value);
        }
        for value in node.generators {
            self.visit_comprehension(value);
        }
    }
    fn visit_expr_Await(&mut self, node: ExprAwait<R>) {
        self.generic_visit_expr_Await(node)
    }
    fn generic_visit_expr_Await(&mut self, node: ExprAwait<R>) {
        {
            let value = node.value;
            self.visit_expr(*value);
        }
    }
    fn visit_expr_Yield(&mut self, node: ExprYield<R>) {
        self.generic_visit_expr_Yield(node)
    }
    fn generic_visit_expr_Yield(&mut self, node: ExprYield<R>) {
        if let Some(value) = node.value {
            self.visit_expr(*value);
        }
    }
    fn visit_expr_YieldFrom(&mut self, node: ExprYieldFrom<R>) {
        self.generic_visit_expr_YieldFrom(node)
    }
    fn generic_visit_expr_YieldFrom(&mut self, node: ExprYieldFrom<R>) {
        {
            let value = node.value;
            self.visit_expr(*value);
        }
    }
    fn visit_expr_Compare(&mut self, node: ExprCompare<R>) {
        self.generic_visit_expr_Compare(node)
    }
    fn generic_visit_expr_Compare(&mut self, node: ExprCompare<R>) {
        {
            let value = node.left;
            self.visit_expr(*value);
        }
        for value in node.comparators {
            self.visit_expr(value);
        }
    }
    fn visit_expr_Call(&mut self, node: ExprCall<R>) {
        self.generic_visit_expr_Call(node)
    }
    fn generic_visit_expr_Call(&mut self, node: ExprCall<R>) {
        {
            let value = node.func;
            self.visit_expr(*value);
        }
        for value in node.args {
            self.visit_expr(value);
        }
        for value in node.keywords {
            self.visit_keyword(value);
        }
    }
    fn visit_expr_FormattedValue(&mut self, node: ExprFormattedValue<R>) {
        self.generic_visit_expr_FormattedValue(node)
    }
    fn generic_visit_expr_FormattedValue(&mut self, node: ExprFormattedValue<R>) {
        {
            let value = node.value;
            self.visit_expr(*value);
        }
        if let Some(value) = node.format_spec {
            self.visit_expr(*value);
        }
    }
    fn visit_expr_JoinedStr(&mut self, node: ExprJoinedStr<R>) {
        self.generic_visit_expr_JoinedStr(node)
    }
    fn generic_visit_expr_JoinedStr(&mut self, node: ExprJoinedStr<R>) {
        for value in node.values {
            self.visit_expr(value);
        }
    }
    fn visit_expr_Constant(&mut self, node: ExprConstant<R>) {
        self.generic_visit_expr_Constant(node)
    }
    fn generic_visit_expr_Constant(&mut self, node: ExprConstant<R>) {}
    fn visit_expr_Attribute(&mut self, node: ExprAttribute<R>) {
        self.generic_visit_expr_Attribute(node)
    }
    fn generic_visit_expr_Attribute(&mut self, node: ExprAttribute<R>) {
        {
            let value = node.value;
            self.visit_expr(*value);
        }
    }
    fn visit_expr_Subscript(&mut self, node: ExprSubscript<R>) {
        self.generic_visit_expr_Subscript(node)
    }
    fn generic_visit_expr_Subscript(&mut self, node: ExprSubscript<R>) {
        {
            let value = node.value;
            self.visit_expr(*value);
        }
        {
            let value = node.slice;
            self.visit_expr(*value);
        }
    }
    fn visit_expr_Starred(&mut self, node: ExprStarred<R>) {
        self.generic_visit_expr_Starred(node)
    }
    fn generic_visit_expr_Starred(&mut self, node: ExprStarred<R>) {
        {
            let value = node.value;
            self.visit_expr(*value);
        }
    }
    fn visit_expr_Name(&mut self, node: ExprName<R>) {
        self.generic_visit_expr_Name(node)
    }
    fn generic_visit_expr_Name(&mut self, node: ExprName<R>) {}
    fn visit_expr_List(&mut self, node: ExprList<R>) {
        self.generic_visit_expr_List(node)
    }
    fn generic_visit_expr_List(&mut self, node: ExprList<R>) {
        for value in node.elts {
            self.visit_expr(value);
        }
    }
    fn visit_expr_Tuple(&mut self, node: ExprTuple<R>) {
        self.generic_visit_expr_Tuple(node)
    }
    fn generic_visit_expr_Tuple(&mut self, node: ExprTuple<R>) {
        for value in node.elts {
            self.visit_expr(value);
        }
    }
    fn visit_expr_Slice(&mut self, node: ExprSlice<R>) {
        self.generic_visit_expr_Slice(node)
    }
    fn generic_visit_expr_Slice(&mut self, node: ExprSlice<R>) {
        if let Some(value) = node.lower {
            self.visit_expr(*value);
        }
        if let Some(value) = node.upper {
            self.visit_expr(*value);
        }
        if let Some(value) = node.step {
            self.visit_expr(*value);
        }
    }
    fn visit_expr_context(&mut self, node: ExprContext) {
        self.generic_visit_expr_context(node)
    }
    fn generic_visit_expr_context(&mut self, node: ExprContext) {}
    fn visit_boolop(&mut self, node: Boolop) {
        self.generic_visit_boolop(node)
    }
    fn generic_visit_boolop(&mut self, node: Boolop) {}
    fn visit_operator(&mut self, node: Operator) {
        self.generic_visit_operator(node)
    }
    fn generic_visit_operator(&mut self, node: Operator) {}
    fn visit_unaryop(&mut self, node: Unaryop) {
        self.generic_visit_unaryop(node)
    }
    fn generic_visit_unaryop(&mut self, node: Unaryop) {}
    fn visit_cmpop(&mut self, node: Cmpop) {
        self.generic_visit_cmpop(node)
    }
    fn generic_visit_cmpop(&mut self, node: Cmpop) {}
    fn visit_comprehension(&mut self, node: Comprehension<R>) {
        self.generic_visit_comprehension(node)
    }
    fn generic_visit_comprehension(&mut self, node: Comprehension<R>) {}
    fn visit_excepthandler(&mut self, node: Excepthandler<R>) {
        self.generic_visit_excepthandler(node)
    }
    fn generic_visit_excepthandler(&mut self, node: Excepthandler<R>) {
        match node {
            Excepthandler::ExceptHandler(data) => self.visit_excepthandler_ExceptHandler(data),
        }
    }
    fn visit_excepthandler_ExceptHandler(&mut self, node: ExcepthandlerExceptHandler<R>) {
        self.generic_visit_excepthandler_ExceptHandler(node)
    }
    fn generic_visit_excepthandler_ExceptHandler(&mut self, node: ExcepthandlerExceptHandler<R>) {
        if let Some(value) = node.type_ {
            self.visit_expr(*value);
        }
        for value in node.body {
            self.visit_stmt(value);
        }
    }
    fn visit_arguments(&mut self, node: Arguments<R>) {
        self.generic_visit_arguments(node)
    }
    fn generic_visit_arguments(&mut self, node: Arguments<R>) {}
    fn visit_arg(&mut self, node: Arg<R>) {
        self.generic_visit_arg(node)
    }
    fn generic_visit_arg(&mut self, node: Arg<R>) {}
    fn visit_keyword(&mut self, node: Keyword<R>) {
        self.generic_visit_keyword(node)
    }
    fn generic_visit_keyword(&mut self, node: Keyword<R>) {}
    fn visit_alias(&mut self, node: Alias<R>) {
        self.generic_visit_alias(node)
    }
    fn generic_visit_alias(&mut self, node: Alias<R>) {}
    fn visit_withitem(&mut self, node: Withitem<R>) {
        self.generic_visit_withitem(node)
    }
    fn generic_visit_withitem(&mut self, node: Withitem<R>) {}
    fn visit_match_case(&mut self, node: MatchCase<R>) {
        self.generic_visit_match_case(node)
    }
    fn generic_visit_match_case(&mut self, node: MatchCase<R>) {}
    fn visit_pattern(&mut self, node: Pattern<R>) {
        self.generic_visit_pattern(node)
    }
    fn generic_visit_pattern(&mut self, node: Pattern<R>) {
        match node {
            Pattern::MatchValue(data) => self.visit_pattern_MatchValue(data),
            Pattern::MatchSingleton(data) => self.visit_pattern_MatchSingleton(data),
            Pattern::MatchSequence(data) => self.visit_pattern_MatchSequence(data),
            Pattern::MatchMapping(data) => self.visit_pattern_MatchMapping(data),
            Pattern::MatchClass(data) => self.visit_pattern_MatchClass(data),
            Pattern::MatchStar(data) => self.visit_pattern_MatchStar(data),
            Pattern::MatchAs(data) => self.visit_pattern_MatchAs(data),
            Pattern::MatchOr(data) => self.visit_pattern_MatchOr(data),
        }
    }
    fn visit_pattern_MatchValue(&mut self, node: PatternMatchValue<R>) {
        self.generic_visit_pattern_MatchValue(node)
    }
    fn generic_visit_pattern_MatchValue(&mut self, node: PatternMatchValue<R>) {
        {
            let value = node.value;
            self.visit_expr(*value);
        }
    }
    fn visit_pattern_MatchSingleton(&mut self, node: PatternMatchSingleton<R>) {
        self.generic_visit_pattern_MatchSingleton(node)
    }
    fn generic_visit_pattern_MatchSingleton(&mut self, node: PatternMatchSingleton<R>) {}
    fn visit_pattern_MatchSequence(&mut self, node: PatternMatchSequence<R>) {
        self.generic_visit_pattern_MatchSequence(node)
    }
    fn generic_visit_pattern_MatchSequence(&mut self, node: PatternMatchSequence<R>) {
        for value in node.patterns {
            self.visit_pattern(value);
        }
    }
    fn visit_pattern_MatchMapping(&mut self, node: PatternMatchMapping<R>) {
        self.generic_visit_pattern_MatchMapping(node)
    }
    fn generic_visit_pattern_MatchMapping(&mut self, node: PatternMatchMapping<R>) {
        for value in node.keys {
            self.visit_expr(value);
        }
        for value in node.patterns {
            self.visit_pattern(value);
        }
    }
    fn visit_pattern_MatchClass(&mut self, node: PatternMatchClass<R>) {
        self.generic_visit_pattern_MatchClass(node)
    }
    fn generic_visit_pattern_MatchClass(&mut self, node: PatternMatchClass<R>) {
        {
            let value = node.cls;
            self.visit_expr(*value);
        }
        for value in node.patterns {
            self.visit_pattern(value);
        }
        for value in node.kwd_patterns {
            self.visit_pattern(value);
        }
    }
    fn visit_pattern_MatchStar(&mut self, node: PatternMatchStar<R>) {
        self.generic_visit_pattern_MatchStar(node)
    }
    fn generic_visit_pattern_MatchStar(&mut self, node: PatternMatchStar<R>) {}
    fn visit_pattern_MatchAs(&mut self, node: PatternMatchAs<R>) {
        self.generic_visit_pattern_MatchAs(node)
    }
    fn generic_visit_pattern_MatchAs(&mut self, node: PatternMatchAs<R>) {
        if let Some(value) = node.pattern {
            self.visit_pattern(*value);
        }
    }
    fn visit_pattern_MatchOr(&mut self, node: PatternMatchOr<R>) {
        self.generic_visit_pattern_MatchOr(node)
    }
    fn generic_visit_pattern_MatchOr(&mut self, node: PatternMatchOr<R>) {
        for value in node.patterns {
            self.visit_pattern(value);
        }
    }
}
