// File automatically generated by ast/asdl_rs.py.

#[pyclass(module="rustpython_ast.located", name="_mod", extends=super::AST, frozen, subclass)]
#[derive(Clone, Debug)]
pub struct Mod;

impl From<&'static crate::Mod<SourceRange>> for Mod {
    fn from(_node: &'static crate::Mod<SourceRange>) -> Self {
        Mod
    }
}

#[pymethods]
impl Mod {
    #[new]
    fn new() -> PyClassInitializer<Self> {
        PyClassInitializer::from(AST).add_subclass(Self)
    }
}
impl ToPyObject for Mod {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = Self::new();
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::Mod<SourceRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        match &self {
            Self::Module(cons) => cons.to_pyo3_wrapper(py),
            Self::Interactive(cons) => cons.to_pyo3_wrapper(py),
            Self::Expression(cons) => cons.to_pyo3_wrapper(py),
            Self::FunctionType(cons) => cons.to_pyo3_wrapper(py),
        }
    }
}

#[pyclass(module="rustpython_ast.located", name="_Module", extends=Mod, frozen)]
#[derive(Clone, Debug)]
pub struct ModModule(pub &'static crate::ModModule<SourceRange>);

impl From<&'static crate::ModModule<SourceRange>> for ModModule {
    fn from(node: &'static crate::ModModule<SourceRange>) -> Self {
        ModModule(node)
    }
}

impl ToPyObject for ModModule {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Mod)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ModModule<SourceRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ModModule(self).to_object(py))
    }
}

#[pymethods]
impl ModModule {
    #[getter]
    #[inline]
    fn get_body(&self, py: Python) -> PyResult<PyObject> {
        self.0.body.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_type_ignores(&self, py: Python) -> PyResult<PyObject> {
        self.0.type_ignores.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.located", name="_Interactive", extends=Mod, frozen)]
#[derive(Clone, Debug)]
pub struct ModInteractive(pub &'static crate::ModInteractive<SourceRange>);

impl From<&'static crate::ModInteractive<SourceRange>> for ModInteractive {
    fn from(node: &'static crate::ModInteractive<SourceRange>) -> Self {
        ModInteractive(node)
    }
}

impl ToPyObject for ModInteractive {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Mod)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ModInteractive<SourceRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ModInteractive(self).to_object(py))
    }
}

#[pymethods]
impl ModInteractive {
    #[getter]
    #[inline]
    fn get_body(&self, py: Python) -> PyResult<PyObject> {
        self.0.body.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.located", name="_Expression", extends=Mod, frozen)]
#[derive(Clone, Debug)]
pub struct ModExpression(pub &'static crate::ModExpression<SourceRange>);

impl From<&'static crate::ModExpression<SourceRange>> for ModExpression {
    fn from(node: &'static crate::ModExpression<SourceRange>) -> Self {
        ModExpression(node)
    }
}

impl ToPyObject for ModExpression {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Mod)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ModExpression<SourceRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ModExpression(self).to_object(py))
    }
}

#[pymethods]
impl ModExpression {
    #[getter]
    #[inline]
    fn get_body(&self, py: Python) -> PyResult<PyObject> {
        self.0.body.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.located", name="_FunctionType", extends=Mod, frozen)]
#[derive(Clone, Debug)]
pub struct ModFunctionType(pub &'static crate::ModFunctionType<SourceRange>);

impl From<&'static crate::ModFunctionType<SourceRange>> for ModFunctionType {
    fn from(node: &'static crate::ModFunctionType<SourceRange>) -> Self {
        ModFunctionType(node)
    }
}

impl ToPyObject for ModFunctionType {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Mod)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ModFunctionType<SourceRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ModFunctionType(self).to_object(py))
    }
}

#[pymethods]
impl ModFunctionType {
    #[getter]
    #[inline]
    fn get_argtypes(&self, py: Python) -> PyResult<PyObject> {
        self.0.argtypes.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_returns(&self, py: Python) -> PyResult<PyObject> {
        self.0.returns.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.located", name="_stmt", extends=super::AST, frozen, subclass)]
#[derive(Clone, Debug)]
pub struct Stmt;

impl From<&'static crate::Stmt<SourceRange>> for Stmt {
    fn from(_node: &'static crate::Stmt<SourceRange>) -> Self {
        Stmt
    }
}

#[pymethods]
impl Stmt {
    #[new]
    fn new() -> PyClassInitializer<Self> {
        PyClassInitializer::from(AST).add_subclass(Self)
    }
}
impl ToPyObject for Stmt {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = Self::new();
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::Stmt<SourceRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        match &self {
            Self::FunctionDef(cons) => cons.to_pyo3_wrapper(py),
            Self::AsyncFunctionDef(cons) => cons.to_pyo3_wrapper(py),
            Self::ClassDef(cons) => cons.to_pyo3_wrapper(py),
            Self::Return(cons) => cons.to_pyo3_wrapper(py),
            Self::Delete(cons) => cons.to_pyo3_wrapper(py),
            Self::Assign(cons) => cons.to_pyo3_wrapper(py),
            Self::AugAssign(cons) => cons.to_pyo3_wrapper(py),
            Self::AnnAssign(cons) => cons.to_pyo3_wrapper(py),
            Self::For(cons) => cons.to_pyo3_wrapper(py),
            Self::AsyncFor(cons) => cons.to_pyo3_wrapper(py),
            Self::While(cons) => cons.to_pyo3_wrapper(py),
            Self::If(cons) => cons.to_pyo3_wrapper(py),
            Self::With(cons) => cons.to_pyo3_wrapper(py),
            Self::AsyncWith(cons) => cons.to_pyo3_wrapper(py),
            Self::Match(cons) => cons.to_pyo3_wrapper(py),
            Self::Raise(cons) => cons.to_pyo3_wrapper(py),
            Self::Try(cons) => cons.to_pyo3_wrapper(py),
            Self::TryStar(cons) => cons.to_pyo3_wrapper(py),
            Self::Assert(cons) => cons.to_pyo3_wrapper(py),
            Self::Import(cons) => cons.to_pyo3_wrapper(py),
            Self::ImportFrom(cons) => cons.to_pyo3_wrapper(py),
            Self::Global(cons) => cons.to_pyo3_wrapper(py),
            Self::Nonlocal(cons) => cons.to_pyo3_wrapper(py),
            Self::Expr(cons) => cons.to_pyo3_wrapper(py),
            Self::Pass(cons) => cons.to_pyo3_wrapper(py),
            Self::Break(cons) => cons.to_pyo3_wrapper(py),
            Self::Continue(cons) => cons.to_pyo3_wrapper(py),
        }
    }
}

#[pyclass(module="rustpython_ast.located", name="_FunctionDef", extends=Stmt, frozen)]
#[derive(Clone, Debug)]
pub struct StmtFunctionDef(pub &'static crate::StmtFunctionDef<SourceRange>);

impl From<&'static crate::StmtFunctionDef<SourceRange>> for StmtFunctionDef {
    fn from(node: &'static crate::StmtFunctionDef<SourceRange>) -> Self {
        StmtFunctionDef(node)
    }
}

impl ToPyObject for StmtFunctionDef {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Stmt)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::StmtFunctionDef<SourceRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(StmtFunctionDef(self).to_object(py))
    }
}

#[pymethods]
impl StmtFunctionDef {
    #[getter]
    #[inline]
    fn get_name(&self, py: Python) -> PyResult<PyObject> {
        self.0.name.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_args(&self, py: Python) -> PyResult<PyObject> {
        self.0.args.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_body(&self, py: Python) -> PyResult<PyObject> {
        self.0.body.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_decorator_list(&self, py: Python) -> PyResult<PyObject> {
        self.0.decorator_list.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_returns(&self, py: Python) -> PyResult<PyObject> {
        self.0.returns.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_type_comment(&self, py: Python) -> PyResult<PyObject> {
        self.0.type_comment.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.located", name="_AsyncFunctionDef", extends=Stmt, frozen)]
#[derive(Clone, Debug)]
pub struct StmtAsyncFunctionDef(pub &'static crate::StmtAsyncFunctionDef<SourceRange>);

impl From<&'static crate::StmtAsyncFunctionDef<SourceRange>> for StmtAsyncFunctionDef {
    fn from(node: &'static crate::StmtAsyncFunctionDef<SourceRange>) -> Self {
        StmtAsyncFunctionDef(node)
    }
}

impl ToPyObject for StmtAsyncFunctionDef {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Stmt)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::StmtAsyncFunctionDef<SourceRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(StmtAsyncFunctionDef(self).to_object(py))
    }
}

#[pymethods]
impl StmtAsyncFunctionDef {
    #[getter]
    #[inline]
    fn get_name(&self, py: Python) -> PyResult<PyObject> {
        self.0.name.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_args(&self, py: Python) -> PyResult<PyObject> {
        self.0.args.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_body(&self, py: Python) -> PyResult<PyObject> {
        self.0.body.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_decorator_list(&self, py: Python) -> PyResult<PyObject> {
        self.0.decorator_list.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_returns(&self, py: Python) -> PyResult<PyObject> {
        self.0.returns.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_type_comment(&self, py: Python) -> PyResult<PyObject> {
        self.0.type_comment.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.located", name="_ClassDef", extends=Stmt, frozen)]
#[derive(Clone, Debug)]
pub struct StmtClassDef(pub &'static crate::StmtClassDef<SourceRange>);

impl From<&'static crate::StmtClassDef<SourceRange>> for StmtClassDef {
    fn from(node: &'static crate::StmtClassDef<SourceRange>) -> Self {
        StmtClassDef(node)
    }
}

impl ToPyObject for StmtClassDef {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Stmt)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::StmtClassDef<SourceRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(StmtClassDef(self).to_object(py))
    }
}

#[pymethods]
impl StmtClassDef {
    #[getter]
    #[inline]
    fn get_name(&self, py: Python) -> PyResult<PyObject> {
        self.0.name.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_bases(&self, py: Python) -> PyResult<PyObject> {
        self.0.bases.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_keywords(&self, py: Python) -> PyResult<PyObject> {
        self.0.keywords.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_body(&self, py: Python) -> PyResult<PyObject> {
        self.0.body.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_decorator_list(&self, py: Python) -> PyResult<PyObject> {
        self.0.decorator_list.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.located", name="_Return", extends=Stmt, frozen)]
#[derive(Clone, Debug)]
pub struct StmtReturn(pub &'static crate::StmtReturn<SourceRange>);

impl From<&'static crate::StmtReturn<SourceRange>> for StmtReturn {
    fn from(node: &'static crate::StmtReturn<SourceRange>) -> Self {
        StmtReturn(node)
    }
}

impl ToPyObject for StmtReturn {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Stmt)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::StmtReturn<SourceRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(StmtReturn(self).to_object(py))
    }
}

#[pymethods]
impl StmtReturn {
    #[getter]
    #[inline]
    fn get_value(&self, py: Python) -> PyResult<PyObject> {
        self.0.value.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.located", name="_Delete", extends=Stmt, frozen)]
#[derive(Clone, Debug)]
pub struct StmtDelete(pub &'static crate::StmtDelete<SourceRange>);

impl From<&'static crate::StmtDelete<SourceRange>> for StmtDelete {
    fn from(node: &'static crate::StmtDelete<SourceRange>) -> Self {
        StmtDelete(node)
    }
}

impl ToPyObject for StmtDelete {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Stmt)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::StmtDelete<SourceRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(StmtDelete(self).to_object(py))
    }
}

#[pymethods]
impl StmtDelete {
    #[getter]
    #[inline]
    fn get_targets(&self, py: Python) -> PyResult<PyObject> {
        self.0.targets.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.located", name="_Assign", extends=Stmt, frozen)]
#[derive(Clone, Debug)]
pub struct StmtAssign(pub &'static crate::StmtAssign<SourceRange>);

impl From<&'static crate::StmtAssign<SourceRange>> for StmtAssign {
    fn from(node: &'static crate::StmtAssign<SourceRange>) -> Self {
        StmtAssign(node)
    }
}

impl ToPyObject for StmtAssign {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Stmt)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::StmtAssign<SourceRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(StmtAssign(self).to_object(py))
    }
}

#[pymethods]
impl StmtAssign {
    #[getter]
    #[inline]
    fn get_targets(&self, py: Python) -> PyResult<PyObject> {
        self.0.targets.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_value(&self, py: Python) -> PyResult<PyObject> {
        self.0.value.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_type_comment(&self, py: Python) -> PyResult<PyObject> {
        self.0.type_comment.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.located", name="_AugAssign", extends=Stmt, frozen)]
#[derive(Clone, Debug)]
pub struct StmtAugAssign(pub &'static crate::StmtAugAssign<SourceRange>);

impl From<&'static crate::StmtAugAssign<SourceRange>> for StmtAugAssign {
    fn from(node: &'static crate::StmtAugAssign<SourceRange>) -> Self {
        StmtAugAssign(node)
    }
}

impl ToPyObject for StmtAugAssign {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Stmt)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::StmtAugAssign<SourceRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(StmtAugAssign(self).to_object(py))
    }
}

#[pymethods]
impl StmtAugAssign {
    #[getter]
    #[inline]
    fn get_target(&self, py: Python) -> PyResult<PyObject> {
        self.0.target.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_op(&self, py: Python) -> PyResult<PyObject> {
        self.0.op.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_value(&self, py: Python) -> PyResult<PyObject> {
        self.0.value.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.located", name="_AnnAssign", extends=Stmt, frozen)]
#[derive(Clone, Debug)]
pub struct StmtAnnAssign(pub &'static crate::StmtAnnAssign<SourceRange>);

impl From<&'static crate::StmtAnnAssign<SourceRange>> for StmtAnnAssign {
    fn from(node: &'static crate::StmtAnnAssign<SourceRange>) -> Self {
        StmtAnnAssign(node)
    }
}

impl ToPyObject for StmtAnnAssign {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Stmt)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::StmtAnnAssign<SourceRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(StmtAnnAssign(self).to_object(py))
    }
}

#[pymethods]
impl StmtAnnAssign {
    #[getter]
    #[inline]
    fn get_target(&self, py: Python) -> PyResult<PyObject> {
        self.0.target.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_annotation(&self, py: Python) -> PyResult<PyObject> {
        self.0.annotation.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_value(&self, py: Python) -> PyResult<PyObject> {
        self.0.value.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_simple(&self, py: Python) -> PyResult<PyObject> {
        self.0.simple.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.located", name="_For", extends=Stmt, frozen)]
#[derive(Clone, Debug)]
pub struct StmtFor(pub &'static crate::StmtFor<SourceRange>);

impl From<&'static crate::StmtFor<SourceRange>> for StmtFor {
    fn from(node: &'static crate::StmtFor<SourceRange>) -> Self {
        StmtFor(node)
    }
}

impl ToPyObject for StmtFor {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Stmt)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::StmtFor<SourceRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(StmtFor(self).to_object(py))
    }
}

#[pymethods]
impl StmtFor {
    #[getter]
    #[inline]
    fn get_target(&self, py: Python) -> PyResult<PyObject> {
        self.0.target.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_iter(&self, py: Python) -> PyResult<PyObject> {
        self.0.iter.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_body(&self, py: Python) -> PyResult<PyObject> {
        self.0.body.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_orelse(&self, py: Python) -> PyResult<PyObject> {
        self.0.orelse.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_type_comment(&self, py: Python) -> PyResult<PyObject> {
        self.0.type_comment.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.located", name="_AsyncFor", extends=Stmt, frozen)]
#[derive(Clone, Debug)]
pub struct StmtAsyncFor(pub &'static crate::StmtAsyncFor<SourceRange>);

impl From<&'static crate::StmtAsyncFor<SourceRange>> for StmtAsyncFor {
    fn from(node: &'static crate::StmtAsyncFor<SourceRange>) -> Self {
        StmtAsyncFor(node)
    }
}

impl ToPyObject for StmtAsyncFor {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Stmt)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::StmtAsyncFor<SourceRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(StmtAsyncFor(self).to_object(py))
    }
}

#[pymethods]
impl StmtAsyncFor {
    #[getter]
    #[inline]
    fn get_target(&self, py: Python) -> PyResult<PyObject> {
        self.0.target.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_iter(&self, py: Python) -> PyResult<PyObject> {
        self.0.iter.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_body(&self, py: Python) -> PyResult<PyObject> {
        self.0.body.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_orelse(&self, py: Python) -> PyResult<PyObject> {
        self.0.orelse.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_type_comment(&self, py: Python) -> PyResult<PyObject> {
        self.0.type_comment.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.located", name="_While", extends=Stmt, frozen)]
#[derive(Clone, Debug)]
pub struct StmtWhile(pub &'static crate::StmtWhile<SourceRange>);

impl From<&'static crate::StmtWhile<SourceRange>> for StmtWhile {
    fn from(node: &'static crate::StmtWhile<SourceRange>) -> Self {
        StmtWhile(node)
    }
}

impl ToPyObject for StmtWhile {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Stmt)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::StmtWhile<SourceRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(StmtWhile(self).to_object(py))
    }
}

#[pymethods]
impl StmtWhile {
    #[getter]
    #[inline]
    fn get_test(&self, py: Python) -> PyResult<PyObject> {
        self.0.test.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_body(&self, py: Python) -> PyResult<PyObject> {
        self.0.body.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_orelse(&self, py: Python) -> PyResult<PyObject> {
        self.0.orelse.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.located", name="_If", extends=Stmt, frozen)]
#[derive(Clone, Debug)]
pub struct StmtIf(pub &'static crate::StmtIf<SourceRange>);

impl From<&'static crate::StmtIf<SourceRange>> for StmtIf {
    fn from(node: &'static crate::StmtIf<SourceRange>) -> Self {
        StmtIf(node)
    }
}

impl ToPyObject for StmtIf {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Stmt)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::StmtIf<SourceRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(StmtIf(self).to_object(py))
    }
}

#[pymethods]
impl StmtIf {
    #[getter]
    #[inline]
    fn get_test(&self, py: Python) -> PyResult<PyObject> {
        self.0.test.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_body(&self, py: Python) -> PyResult<PyObject> {
        self.0.body.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_orelse(&self, py: Python) -> PyResult<PyObject> {
        self.0.orelse.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.located", name="_With", extends=Stmt, frozen)]
#[derive(Clone, Debug)]
pub struct StmtWith(pub &'static crate::StmtWith<SourceRange>);

impl From<&'static crate::StmtWith<SourceRange>> for StmtWith {
    fn from(node: &'static crate::StmtWith<SourceRange>) -> Self {
        StmtWith(node)
    }
}

impl ToPyObject for StmtWith {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Stmt)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::StmtWith<SourceRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(StmtWith(self).to_object(py))
    }
}

#[pymethods]
impl StmtWith {
    #[getter]
    #[inline]
    fn get_items(&self, py: Python) -> PyResult<PyObject> {
        self.0.items.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_body(&self, py: Python) -> PyResult<PyObject> {
        self.0.body.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_type_comment(&self, py: Python) -> PyResult<PyObject> {
        self.0.type_comment.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.located", name="_AsyncWith", extends=Stmt, frozen)]
#[derive(Clone, Debug)]
pub struct StmtAsyncWith(pub &'static crate::StmtAsyncWith<SourceRange>);

impl From<&'static crate::StmtAsyncWith<SourceRange>> for StmtAsyncWith {
    fn from(node: &'static crate::StmtAsyncWith<SourceRange>) -> Self {
        StmtAsyncWith(node)
    }
}

impl ToPyObject for StmtAsyncWith {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Stmt)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::StmtAsyncWith<SourceRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(StmtAsyncWith(self).to_object(py))
    }
}

#[pymethods]
impl StmtAsyncWith {
    #[getter]
    #[inline]
    fn get_items(&self, py: Python) -> PyResult<PyObject> {
        self.0.items.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_body(&self, py: Python) -> PyResult<PyObject> {
        self.0.body.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_type_comment(&self, py: Python) -> PyResult<PyObject> {
        self.0.type_comment.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.located", name="_Match", extends=Stmt, frozen)]
#[derive(Clone, Debug)]
pub struct StmtMatch(pub &'static crate::StmtMatch<SourceRange>);

impl From<&'static crate::StmtMatch<SourceRange>> for StmtMatch {
    fn from(node: &'static crate::StmtMatch<SourceRange>) -> Self {
        StmtMatch(node)
    }
}

impl ToPyObject for StmtMatch {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Stmt)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::StmtMatch<SourceRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(StmtMatch(self).to_object(py))
    }
}

#[pymethods]
impl StmtMatch {
    #[getter]
    #[inline]
    fn get_subject(&self, py: Python) -> PyResult<PyObject> {
        self.0.subject.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_cases(&self, py: Python) -> PyResult<PyObject> {
        self.0.cases.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.located", name="_Raise", extends=Stmt, frozen)]
#[derive(Clone, Debug)]
pub struct StmtRaise(pub &'static crate::StmtRaise<SourceRange>);

impl From<&'static crate::StmtRaise<SourceRange>> for StmtRaise {
    fn from(node: &'static crate::StmtRaise<SourceRange>) -> Self {
        StmtRaise(node)
    }
}

impl ToPyObject for StmtRaise {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Stmt)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::StmtRaise<SourceRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(StmtRaise(self).to_object(py))
    }
}

#[pymethods]
impl StmtRaise {
    #[getter]
    #[inline]
    fn get_exc(&self, py: Python) -> PyResult<PyObject> {
        self.0.exc.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_cause(&self, py: Python) -> PyResult<PyObject> {
        self.0.cause.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.located", name="_Try", extends=Stmt, frozen)]
#[derive(Clone, Debug)]
pub struct StmtTry(pub &'static crate::StmtTry<SourceRange>);

impl From<&'static crate::StmtTry<SourceRange>> for StmtTry {
    fn from(node: &'static crate::StmtTry<SourceRange>) -> Self {
        StmtTry(node)
    }
}

impl ToPyObject for StmtTry {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Stmt)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::StmtTry<SourceRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(StmtTry(self).to_object(py))
    }
}

#[pymethods]
impl StmtTry {
    #[getter]
    #[inline]
    fn get_body(&self, py: Python) -> PyResult<PyObject> {
        self.0.body.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_handlers(&self, py: Python) -> PyResult<PyObject> {
        self.0.handlers.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_orelse(&self, py: Python) -> PyResult<PyObject> {
        self.0.orelse.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_finalbody(&self, py: Python) -> PyResult<PyObject> {
        self.0.finalbody.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.located", name="_TryStar", extends=Stmt, frozen)]
#[derive(Clone, Debug)]
pub struct StmtTryStar(pub &'static crate::StmtTryStar<SourceRange>);

impl From<&'static crate::StmtTryStar<SourceRange>> for StmtTryStar {
    fn from(node: &'static crate::StmtTryStar<SourceRange>) -> Self {
        StmtTryStar(node)
    }
}

impl ToPyObject for StmtTryStar {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Stmt)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::StmtTryStar<SourceRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(StmtTryStar(self).to_object(py))
    }
}

#[pymethods]
impl StmtTryStar {
    #[getter]
    #[inline]
    fn get_body(&self, py: Python) -> PyResult<PyObject> {
        self.0.body.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_handlers(&self, py: Python) -> PyResult<PyObject> {
        self.0.handlers.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_orelse(&self, py: Python) -> PyResult<PyObject> {
        self.0.orelse.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_finalbody(&self, py: Python) -> PyResult<PyObject> {
        self.0.finalbody.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.located", name="_Assert", extends=Stmt, frozen)]
#[derive(Clone, Debug)]
pub struct StmtAssert(pub &'static crate::StmtAssert<SourceRange>);

impl From<&'static crate::StmtAssert<SourceRange>> for StmtAssert {
    fn from(node: &'static crate::StmtAssert<SourceRange>) -> Self {
        StmtAssert(node)
    }
}

impl ToPyObject for StmtAssert {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Stmt)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::StmtAssert<SourceRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(StmtAssert(self).to_object(py))
    }
}

#[pymethods]
impl StmtAssert {
    #[getter]
    #[inline]
    fn get_test(&self, py: Python) -> PyResult<PyObject> {
        self.0.test.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_msg(&self, py: Python) -> PyResult<PyObject> {
        self.0.msg.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.located", name="_Import", extends=Stmt, frozen)]
#[derive(Clone, Debug)]
pub struct StmtImport(pub &'static crate::StmtImport<SourceRange>);

impl From<&'static crate::StmtImport<SourceRange>> for StmtImport {
    fn from(node: &'static crate::StmtImport<SourceRange>) -> Self {
        StmtImport(node)
    }
}

impl ToPyObject for StmtImport {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Stmt)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::StmtImport<SourceRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(StmtImport(self).to_object(py))
    }
}

#[pymethods]
impl StmtImport {
    #[getter]
    #[inline]
    fn get_names(&self, py: Python) -> PyResult<PyObject> {
        self.0.names.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.located", name="_ImportFrom", extends=Stmt, frozen)]
#[derive(Clone, Debug)]
pub struct StmtImportFrom(pub &'static crate::StmtImportFrom<SourceRange>);

impl From<&'static crate::StmtImportFrom<SourceRange>> for StmtImportFrom {
    fn from(node: &'static crate::StmtImportFrom<SourceRange>) -> Self {
        StmtImportFrom(node)
    }
}

impl ToPyObject for StmtImportFrom {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Stmt)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::StmtImportFrom<SourceRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(StmtImportFrom(self).to_object(py))
    }
}

#[pymethods]
impl StmtImportFrom {
    #[getter]
    #[inline]
    fn get_module(&self, py: Python) -> PyResult<PyObject> {
        self.0.module.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_names(&self, py: Python) -> PyResult<PyObject> {
        self.0.names.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_level(&self, py: Python) -> PyResult<PyObject> {
        self.0.level.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.located", name="_Global", extends=Stmt, frozen)]
#[derive(Clone, Debug)]
pub struct StmtGlobal(pub &'static crate::StmtGlobal<SourceRange>);

impl From<&'static crate::StmtGlobal<SourceRange>> for StmtGlobal {
    fn from(node: &'static crate::StmtGlobal<SourceRange>) -> Self {
        StmtGlobal(node)
    }
}

impl ToPyObject for StmtGlobal {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Stmt)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::StmtGlobal<SourceRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(StmtGlobal(self).to_object(py))
    }
}

#[pymethods]
impl StmtGlobal {
    #[getter]
    #[inline]
    fn get_names(&self, py: Python) -> PyResult<PyObject> {
        self.0.names.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.located", name="_Nonlocal", extends=Stmt, frozen)]
#[derive(Clone, Debug)]
pub struct StmtNonlocal(pub &'static crate::StmtNonlocal<SourceRange>);

impl From<&'static crate::StmtNonlocal<SourceRange>> for StmtNonlocal {
    fn from(node: &'static crate::StmtNonlocal<SourceRange>) -> Self {
        StmtNonlocal(node)
    }
}

impl ToPyObject for StmtNonlocal {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Stmt)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::StmtNonlocal<SourceRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(StmtNonlocal(self).to_object(py))
    }
}

#[pymethods]
impl StmtNonlocal {
    #[getter]
    #[inline]
    fn get_names(&self, py: Python) -> PyResult<PyObject> {
        self.0.names.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.located", name="_Expr", extends=Stmt, frozen)]
#[derive(Clone, Debug)]
pub struct StmtExpr(pub &'static crate::StmtExpr<SourceRange>);

impl From<&'static crate::StmtExpr<SourceRange>> for StmtExpr {
    fn from(node: &'static crate::StmtExpr<SourceRange>) -> Self {
        StmtExpr(node)
    }
}

impl ToPyObject for StmtExpr {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Stmt)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::StmtExpr<SourceRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(StmtExpr(self).to_object(py))
    }
}

#[pymethods]
impl StmtExpr {
    #[getter]
    #[inline]
    fn get_value(&self, py: Python) -> PyResult<PyObject> {
        self.0.value.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.located", name="_Pass", extends=Stmt, frozen)]
#[derive(Clone, Debug)]
pub struct StmtPass(pub &'static crate::StmtPass<SourceRange>);

impl From<&'static crate::StmtPass<SourceRange>> for StmtPass {
    fn from(node: &'static crate::StmtPass<SourceRange>) -> Self {
        StmtPass(node)
    }
}

impl ToPyObject for StmtPass {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Stmt)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::StmtPass<SourceRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(StmtPass(self).to_object(py))
    }
}

#[pymethods]
impl StmtPass {}

#[pyclass(module="rustpython_ast.located", name="_Break", extends=Stmt, frozen)]
#[derive(Clone, Debug)]
pub struct StmtBreak(pub &'static crate::StmtBreak<SourceRange>);

impl From<&'static crate::StmtBreak<SourceRange>> for StmtBreak {
    fn from(node: &'static crate::StmtBreak<SourceRange>) -> Self {
        StmtBreak(node)
    }
}

impl ToPyObject for StmtBreak {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Stmt)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::StmtBreak<SourceRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(StmtBreak(self).to_object(py))
    }
}

#[pymethods]
impl StmtBreak {}

#[pyclass(module="rustpython_ast.located", name="_Continue", extends=Stmt, frozen)]
#[derive(Clone, Debug)]
pub struct StmtContinue(pub &'static crate::StmtContinue<SourceRange>);

impl From<&'static crate::StmtContinue<SourceRange>> for StmtContinue {
    fn from(node: &'static crate::StmtContinue<SourceRange>) -> Self {
        StmtContinue(node)
    }
}

impl ToPyObject for StmtContinue {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Stmt)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::StmtContinue<SourceRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(StmtContinue(self).to_object(py))
    }
}

#[pymethods]
impl StmtContinue {}

#[pyclass(module="rustpython_ast.located", name="_expr", extends=super::AST, frozen, subclass)]
#[derive(Clone, Debug)]
pub struct Expr;

impl From<&'static crate::Expr<SourceRange>> for Expr {
    fn from(_node: &'static crate::Expr<SourceRange>) -> Self {
        Expr
    }
}

#[pymethods]
impl Expr {
    #[new]
    fn new() -> PyClassInitializer<Self> {
        PyClassInitializer::from(AST).add_subclass(Self)
    }
}
impl ToPyObject for Expr {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = Self::new();
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::Expr<SourceRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        match &self {
            Self::BoolOp(cons) => cons.to_pyo3_wrapper(py),
            Self::NamedExpr(cons) => cons.to_pyo3_wrapper(py),
            Self::BinOp(cons) => cons.to_pyo3_wrapper(py),
            Self::UnaryOp(cons) => cons.to_pyo3_wrapper(py),
            Self::Lambda(cons) => cons.to_pyo3_wrapper(py),
            Self::IfExp(cons) => cons.to_pyo3_wrapper(py),
            Self::Dict(cons) => cons.to_pyo3_wrapper(py),
            Self::Set(cons) => cons.to_pyo3_wrapper(py),
            Self::ListComp(cons) => cons.to_pyo3_wrapper(py),
            Self::SetComp(cons) => cons.to_pyo3_wrapper(py),
            Self::DictComp(cons) => cons.to_pyo3_wrapper(py),
            Self::GeneratorExp(cons) => cons.to_pyo3_wrapper(py),
            Self::Await(cons) => cons.to_pyo3_wrapper(py),
            Self::Yield(cons) => cons.to_pyo3_wrapper(py),
            Self::YieldFrom(cons) => cons.to_pyo3_wrapper(py),
            Self::Compare(cons) => cons.to_pyo3_wrapper(py),
            Self::Call(cons) => cons.to_pyo3_wrapper(py),
            Self::FormattedValue(cons) => cons.to_pyo3_wrapper(py),
            Self::JoinedStr(cons) => cons.to_pyo3_wrapper(py),
            Self::Constant(cons) => cons.to_pyo3_wrapper(py),
            Self::Attribute(cons) => cons.to_pyo3_wrapper(py),
            Self::Subscript(cons) => cons.to_pyo3_wrapper(py),
            Self::Starred(cons) => cons.to_pyo3_wrapper(py),
            Self::Name(cons) => cons.to_pyo3_wrapper(py),
            Self::List(cons) => cons.to_pyo3_wrapper(py),
            Self::Tuple(cons) => cons.to_pyo3_wrapper(py),
            Self::Slice(cons) => cons.to_pyo3_wrapper(py),
        }
    }
}

#[pyclass(module="rustpython_ast.located", name="_BoolOp", extends=Expr, frozen)]
#[derive(Clone, Debug)]
pub struct ExprBoolOp(pub &'static crate::ExprBoolOp<SourceRange>);

impl From<&'static crate::ExprBoolOp<SourceRange>> for ExprBoolOp {
    fn from(node: &'static crate::ExprBoolOp<SourceRange>) -> Self {
        ExprBoolOp(node)
    }
}

impl ToPyObject for ExprBoolOp {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Expr)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ExprBoolOp<SourceRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ExprBoolOp(self).to_object(py))
    }
}

#[pymethods]
impl ExprBoolOp {
    #[getter]
    #[inline]
    fn get_op(&self, py: Python) -> PyResult<PyObject> {
        self.0.op.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_values(&self, py: Python) -> PyResult<PyObject> {
        self.0.values.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.located", name="_NamedExpr", extends=Expr, frozen)]
#[derive(Clone, Debug)]
pub struct ExprNamedExpr(pub &'static crate::ExprNamedExpr<SourceRange>);

impl From<&'static crate::ExprNamedExpr<SourceRange>> for ExprNamedExpr {
    fn from(node: &'static crate::ExprNamedExpr<SourceRange>) -> Self {
        ExprNamedExpr(node)
    }
}

impl ToPyObject for ExprNamedExpr {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Expr)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ExprNamedExpr<SourceRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ExprNamedExpr(self).to_object(py))
    }
}

#[pymethods]
impl ExprNamedExpr {
    #[getter]
    #[inline]
    fn get_target(&self, py: Python) -> PyResult<PyObject> {
        self.0.target.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_value(&self, py: Python) -> PyResult<PyObject> {
        self.0.value.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.located", name="_BinOp", extends=Expr, frozen)]
#[derive(Clone, Debug)]
pub struct ExprBinOp(pub &'static crate::ExprBinOp<SourceRange>);

impl From<&'static crate::ExprBinOp<SourceRange>> for ExprBinOp {
    fn from(node: &'static crate::ExprBinOp<SourceRange>) -> Self {
        ExprBinOp(node)
    }
}

impl ToPyObject for ExprBinOp {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Expr)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ExprBinOp<SourceRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ExprBinOp(self).to_object(py))
    }
}

#[pymethods]
impl ExprBinOp {
    #[getter]
    #[inline]
    fn get_left(&self, py: Python) -> PyResult<PyObject> {
        self.0.left.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_op(&self, py: Python) -> PyResult<PyObject> {
        self.0.op.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_right(&self, py: Python) -> PyResult<PyObject> {
        self.0.right.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.located", name="_UnaryOp", extends=Expr, frozen)]
#[derive(Clone, Debug)]
pub struct ExprUnaryOp(pub &'static crate::ExprUnaryOp<SourceRange>);

impl From<&'static crate::ExprUnaryOp<SourceRange>> for ExprUnaryOp {
    fn from(node: &'static crate::ExprUnaryOp<SourceRange>) -> Self {
        ExprUnaryOp(node)
    }
}

impl ToPyObject for ExprUnaryOp {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Expr)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ExprUnaryOp<SourceRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ExprUnaryOp(self).to_object(py))
    }
}

#[pymethods]
impl ExprUnaryOp {
    #[getter]
    #[inline]
    fn get_op(&self, py: Python) -> PyResult<PyObject> {
        self.0.op.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_operand(&self, py: Python) -> PyResult<PyObject> {
        self.0.operand.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.located", name="_Lambda", extends=Expr, frozen)]
#[derive(Clone, Debug)]
pub struct ExprLambda(pub &'static crate::ExprLambda<SourceRange>);

impl From<&'static crate::ExprLambda<SourceRange>> for ExprLambda {
    fn from(node: &'static crate::ExprLambda<SourceRange>) -> Self {
        ExprLambda(node)
    }
}

impl ToPyObject for ExprLambda {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Expr)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ExprLambda<SourceRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ExprLambda(self).to_object(py))
    }
}

#[pymethods]
impl ExprLambda {
    #[getter]
    #[inline]
    fn get_args(&self, py: Python) -> PyResult<PyObject> {
        self.0.args.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_body(&self, py: Python) -> PyResult<PyObject> {
        self.0.body.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.located", name="_IfExp", extends=Expr, frozen)]
#[derive(Clone, Debug)]
pub struct ExprIfExp(pub &'static crate::ExprIfExp<SourceRange>);

impl From<&'static crate::ExprIfExp<SourceRange>> for ExprIfExp {
    fn from(node: &'static crate::ExprIfExp<SourceRange>) -> Self {
        ExprIfExp(node)
    }
}

impl ToPyObject for ExprIfExp {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Expr)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ExprIfExp<SourceRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ExprIfExp(self).to_object(py))
    }
}

#[pymethods]
impl ExprIfExp {
    #[getter]
    #[inline]
    fn get_test(&self, py: Python) -> PyResult<PyObject> {
        self.0.test.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_body(&self, py: Python) -> PyResult<PyObject> {
        self.0.body.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_orelse(&self, py: Python) -> PyResult<PyObject> {
        self.0.orelse.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.located", name="_Dict", extends=Expr, frozen)]
#[derive(Clone, Debug)]
pub struct ExprDict(pub &'static crate::ExprDict<SourceRange>);

impl From<&'static crate::ExprDict<SourceRange>> for ExprDict {
    fn from(node: &'static crate::ExprDict<SourceRange>) -> Self {
        ExprDict(node)
    }
}

impl ToPyObject for ExprDict {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Expr)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ExprDict<SourceRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ExprDict(self).to_object(py))
    }
}

#[pymethods]
impl ExprDict {
    #[getter]
    #[inline]
    fn get_keys(&self, py: Python) -> PyResult<PyObject> {
        self.0.keys.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_values(&self, py: Python) -> PyResult<PyObject> {
        self.0.values.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.located", name="_Set", extends=Expr, frozen)]
#[derive(Clone, Debug)]
pub struct ExprSet(pub &'static crate::ExprSet<SourceRange>);

impl From<&'static crate::ExprSet<SourceRange>> for ExprSet {
    fn from(node: &'static crate::ExprSet<SourceRange>) -> Self {
        ExprSet(node)
    }
}

impl ToPyObject for ExprSet {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Expr)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ExprSet<SourceRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ExprSet(self).to_object(py))
    }
}

#[pymethods]
impl ExprSet {
    #[getter]
    #[inline]
    fn get_elts(&self, py: Python) -> PyResult<PyObject> {
        self.0.elts.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.located", name="_ListComp", extends=Expr, frozen)]
#[derive(Clone, Debug)]
pub struct ExprListComp(pub &'static crate::ExprListComp<SourceRange>);

impl From<&'static crate::ExprListComp<SourceRange>> for ExprListComp {
    fn from(node: &'static crate::ExprListComp<SourceRange>) -> Self {
        ExprListComp(node)
    }
}

impl ToPyObject for ExprListComp {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Expr)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ExprListComp<SourceRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ExprListComp(self).to_object(py))
    }
}

#[pymethods]
impl ExprListComp {
    #[getter]
    #[inline]
    fn get_elt(&self, py: Python) -> PyResult<PyObject> {
        self.0.elt.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_generators(&self, py: Python) -> PyResult<PyObject> {
        self.0.generators.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.located", name="_SetComp", extends=Expr, frozen)]
#[derive(Clone, Debug)]
pub struct ExprSetComp(pub &'static crate::ExprSetComp<SourceRange>);

impl From<&'static crate::ExprSetComp<SourceRange>> for ExprSetComp {
    fn from(node: &'static crate::ExprSetComp<SourceRange>) -> Self {
        ExprSetComp(node)
    }
}

impl ToPyObject for ExprSetComp {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Expr)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ExprSetComp<SourceRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ExprSetComp(self).to_object(py))
    }
}

#[pymethods]
impl ExprSetComp {
    #[getter]
    #[inline]
    fn get_elt(&self, py: Python) -> PyResult<PyObject> {
        self.0.elt.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_generators(&self, py: Python) -> PyResult<PyObject> {
        self.0.generators.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.located", name="_DictComp", extends=Expr, frozen)]
#[derive(Clone, Debug)]
pub struct ExprDictComp(pub &'static crate::ExprDictComp<SourceRange>);

impl From<&'static crate::ExprDictComp<SourceRange>> for ExprDictComp {
    fn from(node: &'static crate::ExprDictComp<SourceRange>) -> Self {
        ExprDictComp(node)
    }
}

impl ToPyObject for ExprDictComp {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Expr)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ExprDictComp<SourceRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ExprDictComp(self).to_object(py))
    }
}

#[pymethods]
impl ExprDictComp {
    #[getter]
    #[inline]
    fn get_key(&self, py: Python) -> PyResult<PyObject> {
        self.0.key.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_value(&self, py: Python) -> PyResult<PyObject> {
        self.0.value.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_generators(&self, py: Python) -> PyResult<PyObject> {
        self.0.generators.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.located", name="_GeneratorExp", extends=Expr, frozen)]
#[derive(Clone, Debug)]
pub struct ExprGeneratorExp(pub &'static crate::ExprGeneratorExp<SourceRange>);

impl From<&'static crate::ExprGeneratorExp<SourceRange>> for ExprGeneratorExp {
    fn from(node: &'static crate::ExprGeneratorExp<SourceRange>) -> Self {
        ExprGeneratorExp(node)
    }
}

impl ToPyObject for ExprGeneratorExp {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Expr)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ExprGeneratorExp<SourceRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ExprGeneratorExp(self).to_object(py))
    }
}

#[pymethods]
impl ExprGeneratorExp {
    #[getter]
    #[inline]
    fn get_elt(&self, py: Python) -> PyResult<PyObject> {
        self.0.elt.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_generators(&self, py: Python) -> PyResult<PyObject> {
        self.0.generators.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.located", name="_Await", extends=Expr, frozen)]
#[derive(Clone, Debug)]
pub struct ExprAwait(pub &'static crate::ExprAwait<SourceRange>);

impl From<&'static crate::ExprAwait<SourceRange>> for ExprAwait {
    fn from(node: &'static crate::ExprAwait<SourceRange>) -> Self {
        ExprAwait(node)
    }
}

impl ToPyObject for ExprAwait {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Expr)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ExprAwait<SourceRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ExprAwait(self).to_object(py))
    }
}

#[pymethods]
impl ExprAwait {
    #[getter]
    #[inline]
    fn get_value(&self, py: Python) -> PyResult<PyObject> {
        self.0.value.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.located", name="_Yield", extends=Expr, frozen)]
#[derive(Clone, Debug)]
pub struct ExprYield(pub &'static crate::ExprYield<SourceRange>);

impl From<&'static crate::ExprYield<SourceRange>> for ExprYield {
    fn from(node: &'static crate::ExprYield<SourceRange>) -> Self {
        ExprYield(node)
    }
}

impl ToPyObject for ExprYield {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Expr)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ExprYield<SourceRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ExprYield(self).to_object(py))
    }
}

#[pymethods]
impl ExprYield {
    #[getter]
    #[inline]
    fn get_value(&self, py: Python) -> PyResult<PyObject> {
        self.0.value.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.located", name="_YieldFrom", extends=Expr, frozen)]
#[derive(Clone, Debug)]
pub struct ExprYieldFrom(pub &'static crate::ExprYieldFrom<SourceRange>);

impl From<&'static crate::ExprYieldFrom<SourceRange>> for ExprYieldFrom {
    fn from(node: &'static crate::ExprYieldFrom<SourceRange>) -> Self {
        ExprYieldFrom(node)
    }
}

impl ToPyObject for ExprYieldFrom {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Expr)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ExprYieldFrom<SourceRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ExprYieldFrom(self).to_object(py))
    }
}

#[pymethods]
impl ExprYieldFrom {
    #[getter]
    #[inline]
    fn get_value(&self, py: Python) -> PyResult<PyObject> {
        self.0.value.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.located", name="_Compare", extends=Expr, frozen)]
#[derive(Clone, Debug)]
pub struct ExprCompare(pub &'static crate::ExprCompare<SourceRange>);

impl From<&'static crate::ExprCompare<SourceRange>> for ExprCompare {
    fn from(node: &'static crate::ExprCompare<SourceRange>) -> Self {
        ExprCompare(node)
    }
}

impl ToPyObject for ExprCompare {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Expr)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ExprCompare<SourceRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ExprCompare(self).to_object(py))
    }
}

#[pymethods]
impl ExprCompare {
    #[getter]
    #[inline]
    fn get_left(&self, py: Python) -> PyResult<PyObject> {
        self.0.left.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_ops(&self, py: Python) -> PyResult<PyObject> {
        self.0.ops.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_comparators(&self, py: Python) -> PyResult<PyObject> {
        self.0.comparators.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.located", name="_Call", extends=Expr, frozen)]
#[derive(Clone, Debug)]
pub struct ExprCall(pub &'static crate::ExprCall<SourceRange>);

impl From<&'static crate::ExprCall<SourceRange>> for ExprCall {
    fn from(node: &'static crate::ExprCall<SourceRange>) -> Self {
        ExprCall(node)
    }
}

impl ToPyObject for ExprCall {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Expr)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ExprCall<SourceRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ExprCall(self).to_object(py))
    }
}

#[pymethods]
impl ExprCall {
    #[getter]
    #[inline]
    fn get_func(&self, py: Python) -> PyResult<PyObject> {
        self.0.func.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_args(&self, py: Python) -> PyResult<PyObject> {
        self.0.args.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_keywords(&self, py: Python) -> PyResult<PyObject> {
        self.0.keywords.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.located", name="_FormattedValue", extends=Expr, frozen)]
#[derive(Clone, Debug)]
pub struct ExprFormattedValue(pub &'static crate::ExprFormattedValue<SourceRange>);

impl From<&'static crate::ExprFormattedValue<SourceRange>> for ExprFormattedValue {
    fn from(node: &'static crate::ExprFormattedValue<SourceRange>) -> Self {
        ExprFormattedValue(node)
    }
}

impl ToPyObject for ExprFormattedValue {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Expr)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ExprFormattedValue<SourceRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ExprFormattedValue(self).to_object(py))
    }
}

#[pymethods]
impl ExprFormattedValue {
    #[getter]
    #[inline]
    fn get_value(&self, py: Python) -> PyResult<PyObject> {
        self.0.value.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_conversion(&self, py: Python) -> PyResult<PyObject> {
        self.0.conversion.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_format_spec(&self, py: Python) -> PyResult<PyObject> {
        self.0.format_spec.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.located", name="_JoinedStr", extends=Expr, frozen)]
#[derive(Clone, Debug)]
pub struct ExprJoinedStr(pub &'static crate::ExprJoinedStr<SourceRange>);

impl From<&'static crate::ExprJoinedStr<SourceRange>> for ExprJoinedStr {
    fn from(node: &'static crate::ExprJoinedStr<SourceRange>) -> Self {
        ExprJoinedStr(node)
    }
}

impl ToPyObject for ExprJoinedStr {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Expr)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ExprJoinedStr<SourceRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ExprJoinedStr(self).to_object(py))
    }
}

#[pymethods]
impl ExprJoinedStr {
    #[getter]
    #[inline]
    fn get_values(&self, py: Python) -> PyResult<PyObject> {
        self.0.values.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.located", name="_Constant", extends=Expr, frozen)]
#[derive(Clone, Debug)]
pub struct ExprConstant(pub &'static crate::ExprConstant<SourceRange>);

impl From<&'static crate::ExprConstant<SourceRange>> for ExprConstant {
    fn from(node: &'static crate::ExprConstant<SourceRange>) -> Self {
        ExprConstant(node)
    }
}

impl ToPyObject for ExprConstant {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Expr)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ExprConstant<SourceRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ExprConstant(self).to_object(py))
    }
}

#[pymethods]
impl ExprConstant {
    #[getter]
    #[inline]
    fn get_value(&self, py: Python) -> PyResult<PyObject> {
        self.0.value.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_kind(&self, py: Python) -> PyResult<PyObject> {
        self.0.kind.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.located", name="_Attribute", extends=Expr, frozen)]
#[derive(Clone, Debug)]
pub struct ExprAttribute(pub &'static crate::ExprAttribute<SourceRange>);

impl From<&'static crate::ExprAttribute<SourceRange>> for ExprAttribute {
    fn from(node: &'static crate::ExprAttribute<SourceRange>) -> Self {
        ExprAttribute(node)
    }
}

impl ToPyObject for ExprAttribute {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Expr)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ExprAttribute<SourceRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ExprAttribute(self).to_object(py))
    }
}

#[pymethods]
impl ExprAttribute {
    #[getter]
    #[inline]
    fn get_value(&self, py: Python) -> PyResult<PyObject> {
        self.0.value.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_attr(&self, py: Python) -> PyResult<PyObject> {
        self.0.attr.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_ctx(&self, py: Python) -> PyResult<PyObject> {
        self.0.ctx.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.located", name="_Subscript", extends=Expr, frozen)]
#[derive(Clone, Debug)]
pub struct ExprSubscript(pub &'static crate::ExprSubscript<SourceRange>);

impl From<&'static crate::ExprSubscript<SourceRange>> for ExprSubscript {
    fn from(node: &'static crate::ExprSubscript<SourceRange>) -> Self {
        ExprSubscript(node)
    }
}

impl ToPyObject for ExprSubscript {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Expr)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ExprSubscript<SourceRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ExprSubscript(self).to_object(py))
    }
}

#[pymethods]
impl ExprSubscript {
    #[getter]
    #[inline]
    fn get_value(&self, py: Python) -> PyResult<PyObject> {
        self.0.value.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_slice(&self, py: Python) -> PyResult<PyObject> {
        self.0.slice.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_ctx(&self, py: Python) -> PyResult<PyObject> {
        self.0.ctx.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.located", name="_Starred", extends=Expr, frozen)]
#[derive(Clone, Debug)]
pub struct ExprStarred(pub &'static crate::ExprStarred<SourceRange>);

impl From<&'static crate::ExprStarred<SourceRange>> for ExprStarred {
    fn from(node: &'static crate::ExprStarred<SourceRange>) -> Self {
        ExprStarred(node)
    }
}

impl ToPyObject for ExprStarred {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Expr)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ExprStarred<SourceRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ExprStarred(self).to_object(py))
    }
}

#[pymethods]
impl ExprStarred {
    #[getter]
    #[inline]
    fn get_value(&self, py: Python) -> PyResult<PyObject> {
        self.0.value.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_ctx(&self, py: Python) -> PyResult<PyObject> {
        self.0.ctx.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.located", name="_Name", extends=Expr, frozen)]
#[derive(Clone, Debug)]
pub struct ExprName(pub &'static crate::ExprName<SourceRange>);

impl From<&'static crate::ExprName<SourceRange>> for ExprName {
    fn from(node: &'static crate::ExprName<SourceRange>) -> Self {
        ExprName(node)
    }
}

impl ToPyObject for ExprName {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Expr)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ExprName<SourceRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ExprName(self).to_object(py))
    }
}

#[pymethods]
impl ExprName {
    #[getter]
    #[inline]
    fn get_id(&self, py: Python) -> PyResult<PyObject> {
        self.0.id.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_ctx(&self, py: Python) -> PyResult<PyObject> {
        self.0.ctx.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.located", name="_List", extends=Expr, frozen)]
#[derive(Clone, Debug)]
pub struct ExprList(pub &'static crate::ExprList<SourceRange>);

impl From<&'static crate::ExprList<SourceRange>> for ExprList {
    fn from(node: &'static crate::ExprList<SourceRange>) -> Self {
        ExprList(node)
    }
}

impl ToPyObject for ExprList {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Expr)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ExprList<SourceRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ExprList(self).to_object(py))
    }
}

#[pymethods]
impl ExprList {
    #[getter]
    #[inline]
    fn get_elts(&self, py: Python) -> PyResult<PyObject> {
        self.0.elts.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_ctx(&self, py: Python) -> PyResult<PyObject> {
        self.0.ctx.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.located", name="_Tuple", extends=Expr, frozen)]
#[derive(Clone, Debug)]
pub struct ExprTuple(pub &'static crate::ExprTuple<SourceRange>);

impl From<&'static crate::ExprTuple<SourceRange>> for ExprTuple {
    fn from(node: &'static crate::ExprTuple<SourceRange>) -> Self {
        ExprTuple(node)
    }
}

impl ToPyObject for ExprTuple {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Expr)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ExprTuple<SourceRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ExprTuple(self).to_object(py))
    }
}

#[pymethods]
impl ExprTuple {
    #[getter]
    #[inline]
    fn get_elts(&self, py: Python) -> PyResult<PyObject> {
        self.0.elts.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_ctx(&self, py: Python) -> PyResult<PyObject> {
        self.0.ctx.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.located", name="_Slice", extends=Expr, frozen)]
#[derive(Clone, Debug)]
pub struct ExprSlice(pub &'static crate::ExprSlice<SourceRange>);

impl From<&'static crate::ExprSlice<SourceRange>> for ExprSlice {
    fn from(node: &'static crate::ExprSlice<SourceRange>) -> Self {
        ExprSlice(node)
    }
}

impl ToPyObject for ExprSlice {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Expr)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ExprSlice<SourceRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ExprSlice(self).to_object(py))
    }
}

#[pymethods]
impl ExprSlice {
    #[getter]
    #[inline]
    fn get_lower(&self, py: Python) -> PyResult<PyObject> {
        self.0.lower.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_upper(&self, py: Python) -> PyResult<PyObject> {
        self.0.upper.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_step(&self, py: Python) -> PyResult<PyObject> {
        self.0.step.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.located", name="_expr_context", extends=super::AST, frozen, subclass)]
#[derive(Clone, Debug)]
pub struct ExprContext;

impl From<&'static crate::ExprContext> for ExprContext {
    fn from(_node: &'static crate::ExprContext) -> Self {
        ExprContext
    }
}

#[pymethods]
impl ExprContext {
    #[new]
    fn new() -> PyClassInitializer<Self> {
        PyClassInitializer::from(AST).add_subclass(Self)
    }
}
impl ToPyObject for ExprContext {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = Self::new();
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

#[pyclass(module="rustpython_ast.located", name="_Load", extends=ExprContext)]
pub struct ExprContextLoad;

impl ToPyObject for ExprContextLoad {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(ExprContext)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

#[pyclass(module="rustpython_ast.located", name="_Store", extends=ExprContext)]
pub struct ExprContextStore;

impl ToPyObject for ExprContextStore {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(ExprContext)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

#[pyclass(module="rustpython_ast.located", name="_Del", extends=ExprContext)]
pub struct ExprContextDel;

impl ToPyObject for ExprContextDel {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(ExprContext)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

#[pyclass(module="rustpython_ast.located", name="_boolop", extends=super::AST, frozen, subclass)]
#[derive(Clone, Debug)]
pub struct Boolop;

impl From<&'static crate::Boolop> for Boolop {
    fn from(_node: &'static crate::Boolop) -> Self {
        Boolop
    }
}

#[pymethods]
impl Boolop {
    #[new]
    fn new() -> PyClassInitializer<Self> {
        PyClassInitializer::from(AST).add_subclass(Self)
    }
}
impl ToPyObject for Boolop {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = Self::new();
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

#[pyclass(module="rustpython_ast.located", name="_And", extends=Boolop)]
pub struct BoolopAnd;

impl ToPyObject for BoolopAnd {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Boolop)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

#[pyclass(module="rustpython_ast.located", name="_Or", extends=Boolop)]
pub struct BoolopOr;

impl ToPyObject for BoolopOr {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Boolop)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

#[pyclass(module="rustpython_ast.located", name="_operator", extends=super::AST, frozen, subclass)]
#[derive(Clone, Debug)]
pub struct Operator;

impl From<&'static crate::Operator> for Operator {
    fn from(_node: &'static crate::Operator) -> Self {
        Operator
    }
}

#[pymethods]
impl Operator {
    #[new]
    fn new() -> PyClassInitializer<Self> {
        PyClassInitializer::from(AST).add_subclass(Self)
    }
}
impl ToPyObject for Operator {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = Self::new();
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

#[pyclass(module="rustpython_ast.located", name="_Add", extends=Operator)]
pub struct OperatorAdd;

impl ToPyObject for OperatorAdd {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Operator)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

#[pyclass(module="rustpython_ast.located", name="_Sub", extends=Operator)]
pub struct OperatorSub;

impl ToPyObject for OperatorSub {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Operator)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

#[pyclass(module="rustpython_ast.located", name="_Mult", extends=Operator)]
pub struct OperatorMult;

impl ToPyObject for OperatorMult {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Operator)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

#[pyclass(module="rustpython_ast.located", name="_MatMult", extends=Operator)]
pub struct OperatorMatMult;

impl ToPyObject for OperatorMatMult {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Operator)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

#[pyclass(module="rustpython_ast.located", name="_Div", extends=Operator)]
pub struct OperatorDiv;

impl ToPyObject for OperatorDiv {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Operator)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

#[pyclass(module="rustpython_ast.located", name="_Mod", extends=Operator)]
pub struct OperatorMod;

impl ToPyObject for OperatorMod {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Operator)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

#[pyclass(module="rustpython_ast.located", name="_Pow", extends=Operator)]
pub struct OperatorPow;

impl ToPyObject for OperatorPow {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Operator)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

#[pyclass(module="rustpython_ast.located", name="_LShift", extends=Operator)]
pub struct OperatorLShift;

impl ToPyObject for OperatorLShift {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Operator)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

#[pyclass(module="rustpython_ast.located", name="_RShift", extends=Operator)]
pub struct OperatorRShift;

impl ToPyObject for OperatorRShift {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Operator)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

#[pyclass(module="rustpython_ast.located", name="_BitOr", extends=Operator)]
pub struct OperatorBitOr;

impl ToPyObject for OperatorBitOr {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Operator)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

#[pyclass(module="rustpython_ast.located", name="_BitXor", extends=Operator)]
pub struct OperatorBitXor;

impl ToPyObject for OperatorBitXor {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Operator)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

#[pyclass(module="rustpython_ast.located", name="_BitAnd", extends=Operator)]
pub struct OperatorBitAnd;

impl ToPyObject for OperatorBitAnd {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Operator)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

#[pyclass(module="rustpython_ast.located", name="_FloorDiv", extends=Operator)]
pub struct OperatorFloorDiv;

impl ToPyObject for OperatorFloorDiv {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Operator)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

#[pyclass(module="rustpython_ast.located", name="_unaryop", extends=super::AST, frozen, subclass)]
#[derive(Clone, Debug)]
pub struct Unaryop;

impl From<&'static crate::Unaryop> for Unaryop {
    fn from(_node: &'static crate::Unaryop) -> Self {
        Unaryop
    }
}

#[pymethods]
impl Unaryop {
    #[new]
    fn new() -> PyClassInitializer<Self> {
        PyClassInitializer::from(AST).add_subclass(Self)
    }
}
impl ToPyObject for Unaryop {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = Self::new();
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

#[pyclass(module="rustpython_ast.located", name="_Invert", extends=Unaryop)]
pub struct UnaryopInvert;

impl ToPyObject for UnaryopInvert {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Unaryop)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

#[pyclass(module="rustpython_ast.located", name="_Not", extends=Unaryop)]
pub struct UnaryopNot;

impl ToPyObject for UnaryopNot {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Unaryop)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

#[pyclass(module="rustpython_ast.located", name="_UAdd", extends=Unaryop)]
pub struct UnaryopUAdd;

impl ToPyObject for UnaryopUAdd {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Unaryop)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

#[pyclass(module="rustpython_ast.located", name="_USub", extends=Unaryop)]
pub struct UnaryopUSub;

impl ToPyObject for UnaryopUSub {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Unaryop)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

#[pyclass(module="rustpython_ast.located", name="_cmpop", extends=super::AST, frozen, subclass)]
#[derive(Clone, Debug)]
pub struct Cmpop;

impl From<&'static crate::Cmpop> for Cmpop {
    fn from(_node: &'static crate::Cmpop) -> Self {
        Cmpop
    }
}

#[pymethods]
impl Cmpop {
    #[new]
    fn new() -> PyClassInitializer<Self> {
        PyClassInitializer::from(AST).add_subclass(Self)
    }
}
impl ToPyObject for Cmpop {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = Self::new();
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

#[pyclass(module="rustpython_ast.located", name="_Eq", extends=Cmpop)]
pub struct CmpopEq;

impl ToPyObject for CmpopEq {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Cmpop)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

#[pyclass(module="rustpython_ast.located", name="_NotEq", extends=Cmpop)]
pub struct CmpopNotEq;

impl ToPyObject for CmpopNotEq {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Cmpop)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

#[pyclass(module="rustpython_ast.located", name="_Lt", extends=Cmpop)]
pub struct CmpopLt;

impl ToPyObject for CmpopLt {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Cmpop)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

#[pyclass(module="rustpython_ast.located", name="_LtE", extends=Cmpop)]
pub struct CmpopLtE;

impl ToPyObject for CmpopLtE {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Cmpop)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

#[pyclass(module="rustpython_ast.located", name="_Gt", extends=Cmpop)]
pub struct CmpopGt;

impl ToPyObject for CmpopGt {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Cmpop)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

#[pyclass(module="rustpython_ast.located", name="_GtE", extends=Cmpop)]
pub struct CmpopGtE;

impl ToPyObject for CmpopGtE {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Cmpop)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

#[pyclass(module="rustpython_ast.located", name="_Is", extends=Cmpop)]
pub struct CmpopIs;

impl ToPyObject for CmpopIs {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Cmpop)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

#[pyclass(module="rustpython_ast.located", name="_IsNot", extends=Cmpop)]
pub struct CmpopIsNot;

impl ToPyObject for CmpopIsNot {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Cmpop)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

#[pyclass(module="rustpython_ast.located", name="_In", extends=Cmpop)]
pub struct CmpopIn;

impl ToPyObject for CmpopIn {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Cmpop)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

#[pyclass(module="rustpython_ast.located", name="_NotIn", extends=Cmpop)]
pub struct CmpopNotIn;

impl ToPyObject for CmpopNotIn {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Cmpop)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

#[pyclass(module="rustpython_ast.located", name="_comprehension", extends=super::AST, frozen)]
#[derive(Clone, Debug)]
pub struct Comprehension(pub &'static crate::Comprehension<SourceRange>);

impl From<&'static crate::Comprehension<SourceRange>> for Comprehension {
    fn from(node: &'static crate::Comprehension<SourceRange>) -> Self {
        Comprehension(node)
    }
}

impl ToPyObject for Comprehension {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST).add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::Comprehension<SourceRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(Comprehension(self).to_object(py))
    }
}

#[pymethods]
impl Comprehension {
    #[getter]
    #[inline]
    fn get_target(&self, py: Python) -> PyResult<PyObject> {
        self.0.target.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_iter(&self, py: Python) -> PyResult<PyObject> {
        self.0.iter.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_ifs(&self, py: Python) -> PyResult<PyObject> {
        self.0.ifs.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_is_async(&self, py: Python) -> PyResult<PyObject> {
        self.0.is_async.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.located", name="_excepthandler", extends=super::AST, frozen, subclass)]
#[derive(Clone, Debug)]
pub struct Excepthandler;

impl From<&'static crate::Excepthandler<SourceRange>> for Excepthandler {
    fn from(_node: &'static crate::Excepthandler<SourceRange>) -> Self {
        Excepthandler
    }
}

#[pymethods]
impl Excepthandler {
    #[new]
    fn new() -> PyClassInitializer<Self> {
        PyClassInitializer::from(AST).add_subclass(Self)
    }
}
impl ToPyObject for Excepthandler {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = Self::new();
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::Excepthandler<SourceRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        match &self {
            Self::ExceptHandler(cons) => cons.to_pyo3_wrapper(py),
        }
    }
}

#[pyclass(module="rustpython_ast.located", name="_ExceptHandler", extends=Excepthandler, frozen)]
#[derive(Clone, Debug)]
pub struct ExcepthandlerExceptHandler(pub &'static crate::ExcepthandlerExceptHandler<SourceRange>);

impl From<&'static crate::ExcepthandlerExceptHandler<SourceRange>> for ExcepthandlerExceptHandler {
    fn from(node: &'static crate::ExcepthandlerExceptHandler<SourceRange>) -> Self {
        ExcepthandlerExceptHandler(node)
    }
}

impl ToPyObject for ExcepthandlerExceptHandler {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Excepthandler)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ExcepthandlerExceptHandler<SourceRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ExcepthandlerExceptHandler(self).to_object(py))
    }
}

#[pymethods]
impl ExcepthandlerExceptHandler {
    #[getter]
    #[inline]
    fn get_type(&self, py: Python) -> PyResult<PyObject> {
        self.0.type_.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_name(&self, py: Python) -> PyResult<PyObject> {
        self.0.name.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_body(&self, py: Python) -> PyResult<PyObject> {
        self.0.body.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.located", name="_arguments", extends=super::AST, frozen)]
#[derive(Clone, Debug)]
pub struct Arguments(pub &'static crate::Arguments<SourceRange>);

impl From<&'static crate::Arguments<SourceRange>> for Arguments {
    fn from(node: &'static crate::Arguments<SourceRange>) -> Self {
        Arguments(node)
    }
}

impl ToPyObject for Arguments {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST).add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::Arguments<SourceRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(Arguments(self).to_object(py))
    }
}

#[pymethods]
impl Arguments {
    #[getter]
    #[inline]
    fn get_posonlyargs(&self, py: Python) -> PyResult<PyObject> {
        self.0.posonlyargs.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_args(&self, py: Python) -> PyResult<PyObject> {
        self.0.args.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_vararg(&self, py: Python) -> PyResult<PyObject> {
        self.0.vararg.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_kwonlyargs(&self, py: Python) -> PyResult<PyObject> {
        self.0.kwonlyargs.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_kw_defaults(&self, py: Python) -> PyResult<PyObject> {
        self.0.kw_defaults.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_kwarg(&self, py: Python) -> PyResult<PyObject> {
        self.0.kwarg.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_defaults(&self, py: Python) -> PyResult<PyObject> {
        self.0.defaults.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.located", name="_arg", extends=super::AST, frozen)]
#[derive(Clone, Debug)]
pub struct Arg(pub &'static crate::Arg<SourceRange>);

impl From<&'static crate::Arg<SourceRange>> for Arg {
    fn from(node: &'static crate::Arg<SourceRange>) -> Self {
        Arg(node)
    }
}

impl ToPyObject for Arg {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST).add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::Arg<SourceRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(Arg(self).to_object(py))
    }
}

#[pymethods]
impl Arg {
    #[getter]
    #[inline]
    fn get_arg(&self, py: Python) -> PyResult<PyObject> {
        self.0.arg.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_annotation(&self, py: Python) -> PyResult<PyObject> {
        self.0.annotation.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_type_comment(&self, py: Python) -> PyResult<PyObject> {
        self.0.type_comment.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.located", name="_keyword", extends=super::AST, frozen)]
#[derive(Clone, Debug)]
pub struct Keyword(pub &'static crate::Keyword<SourceRange>);

impl From<&'static crate::Keyword<SourceRange>> for Keyword {
    fn from(node: &'static crate::Keyword<SourceRange>) -> Self {
        Keyword(node)
    }
}

impl ToPyObject for Keyword {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST).add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::Keyword<SourceRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(Keyword(self).to_object(py))
    }
}

#[pymethods]
impl Keyword {
    #[getter]
    #[inline]
    fn get_arg(&self, py: Python) -> PyResult<PyObject> {
        self.0.arg.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_value(&self, py: Python) -> PyResult<PyObject> {
        self.0.value.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.located", name="_alias", extends=super::AST, frozen)]
#[derive(Clone, Debug)]
pub struct Alias(pub &'static crate::Alias<SourceRange>);

impl From<&'static crate::Alias<SourceRange>> for Alias {
    fn from(node: &'static crate::Alias<SourceRange>) -> Self {
        Alias(node)
    }
}

impl ToPyObject for Alias {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST).add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::Alias<SourceRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(Alias(self).to_object(py))
    }
}

#[pymethods]
impl Alias {
    #[getter]
    #[inline]
    fn get_name(&self, py: Python) -> PyResult<PyObject> {
        self.0.name.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_asname(&self, py: Python) -> PyResult<PyObject> {
        self.0.asname.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.located", name="_withitem", extends=super::AST, frozen)]
#[derive(Clone, Debug)]
pub struct Withitem(pub &'static crate::Withitem<SourceRange>);

impl From<&'static crate::Withitem<SourceRange>> for Withitem {
    fn from(node: &'static crate::Withitem<SourceRange>) -> Self {
        Withitem(node)
    }
}

impl ToPyObject for Withitem {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST).add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::Withitem<SourceRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(Withitem(self).to_object(py))
    }
}

#[pymethods]
impl Withitem {
    #[getter]
    #[inline]
    fn get_context_expr(&self, py: Python) -> PyResult<PyObject> {
        self.0.context_expr.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_optional_vars(&self, py: Python) -> PyResult<PyObject> {
        self.0.optional_vars.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.located", name="_match_case", extends=super::AST, frozen)]
#[derive(Clone, Debug)]
pub struct MatchCase(pub &'static crate::MatchCase<SourceRange>);

impl From<&'static crate::MatchCase<SourceRange>> for MatchCase {
    fn from(node: &'static crate::MatchCase<SourceRange>) -> Self {
        MatchCase(node)
    }
}

impl ToPyObject for MatchCase {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST).add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::MatchCase<SourceRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(MatchCase(self).to_object(py))
    }
}

#[pymethods]
impl MatchCase {
    #[getter]
    #[inline]
    fn get_pattern(&self, py: Python) -> PyResult<PyObject> {
        self.0.pattern.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_guard(&self, py: Python) -> PyResult<PyObject> {
        self.0.guard.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_body(&self, py: Python) -> PyResult<PyObject> {
        self.0.body.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.located", name="_pattern", extends=super::AST, frozen, subclass)]
#[derive(Clone, Debug)]
pub struct Pattern;

impl From<&'static crate::Pattern<SourceRange>> for Pattern {
    fn from(_node: &'static crate::Pattern<SourceRange>) -> Self {
        Pattern
    }
}

#[pymethods]
impl Pattern {
    #[new]
    fn new() -> PyClassInitializer<Self> {
        PyClassInitializer::from(AST).add_subclass(Self)
    }
}
impl ToPyObject for Pattern {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = Self::new();
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::Pattern<SourceRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        match &self {
            Self::MatchValue(cons) => cons.to_pyo3_wrapper(py),
            Self::MatchSingleton(cons) => cons.to_pyo3_wrapper(py),
            Self::MatchSequence(cons) => cons.to_pyo3_wrapper(py),
            Self::MatchMapping(cons) => cons.to_pyo3_wrapper(py),
            Self::MatchClass(cons) => cons.to_pyo3_wrapper(py),
            Self::MatchStar(cons) => cons.to_pyo3_wrapper(py),
            Self::MatchAs(cons) => cons.to_pyo3_wrapper(py),
            Self::MatchOr(cons) => cons.to_pyo3_wrapper(py),
        }
    }
}

#[pyclass(module="rustpython_ast.located", name="_MatchValue", extends=Pattern, frozen)]
#[derive(Clone, Debug)]
pub struct PatternMatchValue(pub &'static crate::PatternMatchValue<SourceRange>);

impl From<&'static crate::PatternMatchValue<SourceRange>> for PatternMatchValue {
    fn from(node: &'static crate::PatternMatchValue<SourceRange>) -> Self {
        PatternMatchValue(node)
    }
}

impl ToPyObject for PatternMatchValue {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Pattern)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::PatternMatchValue<SourceRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(PatternMatchValue(self).to_object(py))
    }
}

#[pymethods]
impl PatternMatchValue {
    #[getter]
    #[inline]
    fn get_value(&self, py: Python) -> PyResult<PyObject> {
        self.0.value.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.located", name="_MatchSingleton", extends=Pattern, frozen)]
#[derive(Clone, Debug)]
pub struct PatternMatchSingleton(pub &'static crate::PatternMatchSingleton<SourceRange>);

impl From<&'static crate::PatternMatchSingleton<SourceRange>> for PatternMatchSingleton {
    fn from(node: &'static crate::PatternMatchSingleton<SourceRange>) -> Self {
        PatternMatchSingleton(node)
    }
}

impl ToPyObject for PatternMatchSingleton {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Pattern)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::PatternMatchSingleton<SourceRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(PatternMatchSingleton(self).to_object(py))
    }
}

#[pymethods]
impl PatternMatchSingleton {
    #[getter]
    #[inline]
    fn get_value(&self, py: Python) -> PyResult<PyObject> {
        self.0.value.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.located", name="_MatchSequence", extends=Pattern, frozen)]
#[derive(Clone, Debug)]
pub struct PatternMatchSequence(pub &'static crate::PatternMatchSequence<SourceRange>);

impl From<&'static crate::PatternMatchSequence<SourceRange>> for PatternMatchSequence {
    fn from(node: &'static crate::PatternMatchSequence<SourceRange>) -> Self {
        PatternMatchSequence(node)
    }
}

impl ToPyObject for PatternMatchSequence {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Pattern)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::PatternMatchSequence<SourceRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(PatternMatchSequence(self).to_object(py))
    }
}

#[pymethods]
impl PatternMatchSequence {
    #[getter]
    #[inline]
    fn get_patterns(&self, py: Python) -> PyResult<PyObject> {
        self.0.patterns.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.located", name="_MatchMapping", extends=Pattern, frozen)]
#[derive(Clone, Debug)]
pub struct PatternMatchMapping(pub &'static crate::PatternMatchMapping<SourceRange>);

impl From<&'static crate::PatternMatchMapping<SourceRange>> for PatternMatchMapping {
    fn from(node: &'static crate::PatternMatchMapping<SourceRange>) -> Self {
        PatternMatchMapping(node)
    }
}

impl ToPyObject for PatternMatchMapping {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Pattern)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::PatternMatchMapping<SourceRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(PatternMatchMapping(self).to_object(py))
    }
}

#[pymethods]
impl PatternMatchMapping {
    #[getter]
    #[inline]
    fn get_keys(&self, py: Python) -> PyResult<PyObject> {
        self.0.keys.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_patterns(&self, py: Python) -> PyResult<PyObject> {
        self.0.patterns.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_rest(&self, py: Python) -> PyResult<PyObject> {
        self.0.rest.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.located", name="_MatchClass", extends=Pattern, frozen)]
#[derive(Clone, Debug)]
pub struct PatternMatchClass(pub &'static crate::PatternMatchClass<SourceRange>);

impl From<&'static crate::PatternMatchClass<SourceRange>> for PatternMatchClass {
    fn from(node: &'static crate::PatternMatchClass<SourceRange>) -> Self {
        PatternMatchClass(node)
    }
}

impl ToPyObject for PatternMatchClass {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Pattern)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::PatternMatchClass<SourceRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(PatternMatchClass(self).to_object(py))
    }
}

#[pymethods]
impl PatternMatchClass {
    #[getter]
    #[inline]
    fn get_cls(&self, py: Python) -> PyResult<PyObject> {
        self.0.cls.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_patterns(&self, py: Python) -> PyResult<PyObject> {
        self.0.patterns.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_kwd_attrs(&self, py: Python) -> PyResult<PyObject> {
        self.0.kwd_attrs.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_kwd_patterns(&self, py: Python) -> PyResult<PyObject> {
        self.0.kwd_patterns.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.located", name="_MatchStar", extends=Pattern, frozen)]
#[derive(Clone, Debug)]
pub struct PatternMatchStar(pub &'static crate::PatternMatchStar<SourceRange>);

impl From<&'static crate::PatternMatchStar<SourceRange>> for PatternMatchStar {
    fn from(node: &'static crate::PatternMatchStar<SourceRange>) -> Self {
        PatternMatchStar(node)
    }
}

impl ToPyObject for PatternMatchStar {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Pattern)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::PatternMatchStar<SourceRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(PatternMatchStar(self).to_object(py))
    }
}

#[pymethods]
impl PatternMatchStar {
    #[getter]
    #[inline]
    fn get_name(&self, py: Python) -> PyResult<PyObject> {
        self.0.name.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.located", name="_MatchAs", extends=Pattern, frozen)]
#[derive(Clone, Debug)]
pub struct PatternMatchAs(pub &'static crate::PatternMatchAs<SourceRange>);

impl From<&'static crate::PatternMatchAs<SourceRange>> for PatternMatchAs {
    fn from(node: &'static crate::PatternMatchAs<SourceRange>) -> Self {
        PatternMatchAs(node)
    }
}

impl ToPyObject for PatternMatchAs {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Pattern)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::PatternMatchAs<SourceRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(PatternMatchAs(self).to_object(py))
    }
}

#[pymethods]
impl PatternMatchAs {
    #[getter]
    #[inline]
    fn get_pattern(&self, py: Python) -> PyResult<PyObject> {
        self.0.pattern.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_name(&self, py: Python) -> PyResult<PyObject> {
        self.0.name.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.located", name="_MatchOr", extends=Pattern, frozen)]
#[derive(Clone, Debug)]
pub struct PatternMatchOr(pub &'static crate::PatternMatchOr<SourceRange>);

impl From<&'static crate::PatternMatchOr<SourceRange>> for PatternMatchOr {
    fn from(node: &'static crate::PatternMatchOr<SourceRange>) -> Self {
        PatternMatchOr(node)
    }
}

impl ToPyObject for PatternMatchOr {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Pattern)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::PatternMatchOr<SourceRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(PatternMatchOr(self).to_object(py))
    }
}

#[pymethods]
impl PatternMatchOr {
    #[getter]
    #[inline]
    fn get_patterns(&self, py: Python) -> PyResult<PyObject> {
        self.0.patterns.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.located", name="_type_ignore", extends=super::AST, frozen, subclass)]
#[derive(Clone, Debug)]
pub struct TypeIgnore;

impl From<&'static crate::TypeIgnore<SourceRange>> for TypeIgnore {
    fn from(_node: &'static crate::TypeIgnore<SourceRange>) -> Self {
        TypeIgnore
    }
}

#[pymethods]
impl TypeIgnore {
    #[new]
    fn new() -> PyClassInitializer<Self> {
        PyClassInitializer::from(AST).add_subclass(Self)
    }
}
impl ToPyObject for TypeIgnore {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = Self::new();
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::TypeIgnore<SourceRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        match &self {
            Self::TypeIgnore(cons) => cons.to_pyo3_wrapper(py),
        }
    }
}

#[pyclass(module="rustpython_ast.located", name="_TypeIgnore", extends=TypeIgnore, frozen)]
#[derive(Clone, Debug)]
pub struct TypeIgnoreTypeIgnore(pub &'static crate::TypeIgnoreTypeIgnore<SourceRange>);

impl From<&'static crate::TypeIgnoreTypeIgnore<SourceRange>> for TypeIgnoreTypeIgnore {
    fn from(node: &'static crate::TypeIgnoreTypeIgnore<SourceRange>) -> Self {
        TypeIgnoreTypeIgnore(node)
    }
}

impl ToPyObject for TypeIgnoreTypeIgnore {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(TypeIgnore)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::TypeIgnoreTypeIgnore<SourceRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(TypeIgnoreTypeIgnore(self).to_object(py))
    }
}

#[pymethods]
impl TypeIgnoreTypeIgnore {
    #[getter]
    #[inline]
    fn get_lineno(&self, py: Python) -> PyResult<PyObject> {
        self.0.lineno.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_tag(&self, py: Python) -> PyResult<PyObject> {
        self.0.tag.to_pyo3_wrapper(py)
    }
}

impl ToPyo3Wrapper for crate::generic::ExprContext {
    #[inline]
    fn to_pyo3_wrapper(&self, py: Python) -> PyResult<Py<PyAny>> {
        match &self {
            Self::Load => Ok(ExprContextLoad.to_object(py)),
            Self::Store => Ok(ExprContextStore.to_object(py)),
            Self::Del => Ok(ExprContextDel.to_object(py)),
        }
    }
}

impl ToPyo3Wrapper for crate::generic::ExprContextLoad {
    #[inline]
    fn to_pyo3_wrapper(&self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ExprContextLoad.to_object(py))
    }
}

impl ToPyo3Wrapper for crate::generic::ExprContextStore {
    #[inline]
    fn to_pyo3_wrapper(&self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ExprContextStore.to_object(py))
    }
}

impl ToPyo3Wrapper for crate::generic::ExprContextDel {
    #[inline]
    fn to_pyo3_wrapper(&self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ExprContextDel.to_object(py))
    }
}

impl ToPyo3Wrapper for crate::generic::Boolop {
    #[inline]
    fn to_pyo3_wrapper(&self, py: Python) -> PyResult<Py<PyAny>> {
        match &self {
            Self::And => Ok(BoolopAnd.to_object(py)),
            Self::Or => Ok(BoolopOr.to_object(py)),
        }
    }
}

impl ToPyo3Wrapper for crate::generic::BoolopAnd {
    #[inline]
    fn to_pyo3_wrapper(&self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(BoolopAnd.to_object(py))
    }
}

impl ToPyo3Wrapper for crate::generic::BoolopOr {
    #[inline]
    fn to_pyo3_wrapper(&self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(BoolopOr.to_object(py))
    }
}

impl ToPyo3Wrapper for crate::generic::Operator {
    #[inline]
    fn to_pyo3_wrapper(&self, py: Python) -> PyResult<Py<PyAny>> {
        match &self {
            Self::Add => Ok(OperatorAdd.to_object(py)),
            Self::Sub => Ok(OperatorSub.to_object(py)),
            Self::Mult => Ok(OperatorMult.to_object(py)),
            Self::MatMult => Ok(OperatorMatMult.to_object(py)),
            Self::Div => Ok(OperatorDiv.to_object(py)),
            Self::Mod => Ok(OperatorMod.to_object(py)),
            Self::Pow => Ok(OperatorPow.to_object(py)),
            Self::LShift => Ok(OperatorLShift.to_object(py)),
            Self::RShift => Ok(OperatorRShift.to_object(py)),
            Self::BitOr => Ok(OperatorBitOr.to_object(py)),
            Self::BitXor => Ok(OperatorBitXor.to_object(py)),
            Self::BitAnd => Ok(OperatorBitAnd.to_object(py)),
            Self::FloorDiv => Ok(OperatorFloorDiv.to_object(py)),
        }
    }
}

impl ToPyo3Wrapper for crate::generic::OperatorAdd {
    #[inline]
    fn to_pyo3_wrapper(&self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(OperatorAdd.to_object(py))
    }
}

impl ToPyo3Wrapper for crate::generic::OperatorSub {
    #[inline]
    fn to_pyo3_wrapper(&self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(OperatorSub.to_object(py))
    }
}

impl ToPyo3Wrapper for crate::generic::OperatorMult {
    #[inline]
    fn to_pyo3_wrapper(&self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(OperatorMult.to_object(py))
    }
}

impl ToPyo3Wrapper for crate::generic::OperatorMatMult {
    #[inline]
    fn to_pyo3_wrapper(&self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(OperatorMatMult.to_object(py))
    }
}

impl ToPyo3Wrapper for crate::generic::OperatorDiv {
    #[inline]
    fn to_pyo3_wrapper(&self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(OperatorDiv.to_object(py))
    }
}

impl ToPyo3Wrapper for crate::generic::OperatorMod {
    #[inline]
    fn to_pyo3_wrapper(&self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(OperatorMod.to_object(py))
    }
}

impl ToPyo3Wrapper for crate::generic::OperatorPow {
    #[inline]
    fn to_pyo3_wrapper(&self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(OperatorPow.to_object(py))
    }
}

impl ToPyo3Wrapper for crate::generic::OperatorLShift {
    #[inline]
    fn to_pyo3_wrapper(&self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(OperatorLShift.to_object(py))
    }
}

impl ToPyo3Wrapper for crate::generic::OperatorRShift {
    #[inline]
    fn to_pyo3_wrapper(&self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(OperatorRShift.to_object(py))
    }
}

impl ToPyo3Wrapper for crate::generic::OperatorBitOr {
    #[inline]
    fn to_pyo3_wrapper(&self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(OperatorBitOr.to_object(py))
    }
}

impl ToPyo3Wrapper for crate::generic::OperatorBitXor {
    #[inline]
    fn to_pyo3_wrapper(&self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(OperatorBitXor.to_object(py))
    }
}

impl ToPyo3Wrapper for crate::generic::OperatorBitAnd {
    #[inline]
    fn to_pyo3_wrapper(&self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(OperatorBitAnd.to_object(py))
    }
}

impl ToPyo3Wrapper for crate::generic::OperatorFloorDiv {
    #[inline]
    fn to_pyo3_wrapper(&self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(OperatorFloorDiv.to_object(py))
    }
}

impl ToPyo3Wrapper for crate::generic::Unaryop {
    #[inline]
    fn to_pyo3_wrapper(&self, py: Python) -> PyResult<Py<PyAny>> {
        match &self {
            Self::Invert => Ok(UnaryopInvert.to_object(py)),
            Self::Not => Ok(UnaryopNot.to_object(py)),
            Self::UAdd => Ok(UnaryopUAdd.to_object(py)),
            Self::USub => Ok(UnaryopUSub.to_object(py)),
        }
    }
}

impl ToPyo3Wrapper for crate::generic::UnaryopInvert {
    #[inline]
    fn to_pyo3_wrapper(&self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(UnaryopInvert.to_object(py))
    }
}

impl ToPyo3Wrapper for crate::generic::UnaryopNot {
    #[inline]
    fn to_pyo3_wrapper(&self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(UnaryopNot.to_object(py))
    }
}

impl ToPyo3Wrapper for crate::generic::UnaryopUAdd {
    #[inline]
    fn to_pyo3_wrapper(&self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(UnaryopUAdd.to_object(py))
    }
}

impl ToPyo3Wrapper for crate::generic::UnaryopUSub {
    #[inline]
    fn to_pyo3_wrapper(&self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(UnaryopUSub.to_object(py))
    }
}

impl ToPyo3Wrapper for crate::generic::Cmpop {
    #[inline]
    fn to_pyo3_wrapper(&self, py: Python) -> PyResult<Py<PyAny>> {
        match &self {
            Self::Eq => Ok(CmpopEq.to_object(py)),
            Self::NotEq => Ok(CmpopNotEq.to_object(py)),
            Self::Lt => Ok(CmpopLt.to_object(py)),
            Self::LtE => Ok(CmpopLtE.to_object(py)),
            Self::Gt => Ok(CmpopGt.to_object(py)),
            Self::GtE => Ok(CmpopGtE.to_object(py)),
            Self::Is => Ok(CmpopIs.to_object(py)),
            Self::IsNot => Ok(CmpopIsNot.to_object(py)),
            Self::In => Ok(CmpopIn.to_object(py)),
            Self::NotIn => Ok(CmpopNotIn.to_object(py)),
        }
    }
}

impl ToPyo3Wrapper for crate::generic::CmpopEq {
    #[inline]
    fn to_pyo3_wrapper(&self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(CmpopEq.to_object(py))
    }
}

impl ToPyo3Wrapper for crate::generic::CmpopNotEq {
    #[inline]
    fn to_pyo3_wrapper(&self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(CmpopNotEq.to_object(py))
    }
}

impl ToPyo3Wrapper for crate::generic::CmpopLt {
    #[inline]
    fn to_pyo3_wrapper(&self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(CmpopLt.to_object(py))
    }
}

impl ToPyo3Wrapper for crate::generic::CmpopLtE {
    #[inline]
    fn to_pyo3_wrapper(&self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(CmpopLtE.to_object(py))
    }
}

impl ToPyo3Wrapper for crate::generic::CmpopGt {
    #[inline]
    fn to_pyo3_wrapper(&self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(CmpopGt.to_object(py))
    }
}

impl ToPyo3Wrapper for crate::generic::CmpopGtE {
    #[inline]
    fn to_pyo3_wrapper(&self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(CmpopGtE.to_object(py))
    }
}

impl ToPyo3Wrapper for crate::generic::CmpopIs {
    #[inline]
    fn to_pyo3_wrapper(&self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(CmpopIs.to_object(py))
    }
}

impl ToPyo3Wrapper for crate::generic::CmpopIsNot {
    #[inline]
    fn to_pyo3_wrapper(&self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(CmpopIsNot.to_object(py))
    }
}

impl ToPyo3Wrapper for crate::generic::CmpopIn {
    #[inline]
    fn to_pyo3_wrapper(&self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(CmpopIn.to_object(py))
    }
}

impl ToPyo3Wrapper for crate::generic::CmpopNotIn {
    #[inline]
    fn to_pyo3_wrapper(&self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(CmpopNotIn.to_object(py))
    }
}

pub fn add_to_module(py: Python, m: &PyModule) -> PyResult<()> {
    super::init_module(py, m)?;
    super::init_type::<Mod, crate::generic::Mod>(py, m)?;
    super::init_type::<ModModule, crate::generic::ModModule>(py, m)?;
    super::init_type::<ModInteractive, crate::generic::ModInteractive>(py, m)?;
    super::init_type::<ModExpression, crate::generic::ModExpression>(py, m)?;
    super::init_type::<ModFunctionType, crate::generic::ModFunctionType>(py, m)?;
    super::init_type::<Stmt, crate::generic::Stmt>(py, m)?;
    super::init_type::<StmtFunctionDef, crate::generic::StmtFunctionDef>(py, m)?;
    super::init_type::<StmtAsyncFunctionDef, crate::generic::StmtAsyncFunctionDef>(py, m)?;
    super::init_type::<StmtClassDef, crate::generic::StmtClassDef>(py, m)?;
    super::init_type::<StmtReturn, crate::generic::StmtReturn>(py, m)?;
    super::init_type::<StmtDelete, crate::generic::StmtDelete>(py, m)?;
    super::init_type::<StmtAssign, crate::generic::StmtAssign>(py, m)?;
    super::init_type::<StmtAugAssign, crate::generic::StmtAugAssign>(py, m)?;
    super::init_type::<StmtAnnAssign, crate::generic::StmtAnnAssign>(py, m)?;
    super::init_type::<StmtFor, crate::generic::StmtFor>(py, m)?;
    super::init_type::<StmtAsyncFor, crate::generic::StmtAsyncFor>(py, m)?;
    super::init_type::<StmtWhile, crate::generic::StmtWhile>(py, m)?;
    super::init_type::<StmtIf, crate::generic::StmtIf>(py, m)?;
    super::init_type::<StmtWith, crate::generic::StmtWith>(py, m)?;
    super::init_type::<StmtAsyncWith, crate::generic::StmtAsyncWith>(py, m)?;
    super::init_type::<StmtMatch, crate::generic::StmtMatch>(py, m)?;
    super::init_type::<StmtRaise, crate::generic::StmtRaise>(py, m)?;
    super::init_type::<StmtTry, crate::generic::StmtTry>(py, m)?;
    super::init_type::<StmtTryStar, crate::generic::StmtTryStar>(py, m)?;
    super::init_type::<StmtAssert, crate::generic::StmtAssert>(py, m)?;
    super::init_type::<StmtImport, crate::generic::StmtImport>(py, m)?;
    super::init_type::<StmtImportFrom, crate::generic::StmtImportFrom>(py, m)?;
    super::init_type::<StmtGlobal, crate::generic::StmtGlobal>(py, m)?;
    super::init_type::<StmtNonlocal, crate::generic::StmtNonlocal>(py, m)?;
    super::init_type::<StmtExpr, crate::generic::StmtExpr>(py, m)?;
    super::init_type::<StmtPass, crate::generic::StmtPass>(py, m)?;
    super::init_type::<StmtBreak, crate::generic::StmtBreak>(py, m)?;
    super::init_type::<StmtContinue, crate::generic::StmtContinue>(py, m)?;
    super::init_type::<Expr, crate::generic::Expr>(py, m)?;
    super::init_type::<ExprBoolOp, crate::generic::ExprBoolOp>(py, m)?;
    super::init_type::<ExprNamedExpr, crate::generic::ExprNamedExpr>(py, m)?;
    super::init_type::<ExprBinOp, crate::generic::ExprBinOp>(py, m)?;
    super::init_type::<ExprUnaryOp, crate::generic::ExprUnaryOp>(py, m)?;
    super::init_type::<ExprLambda, crate::generic::ExprLambda>(py, m)?;
    super::init_type::<ExprIfExp, crate::generic::ExprIfExp>(py, m)?;
    super::init_type::<ExprDict, crate::generic::ExprDict>(py, m)?;
    super::init_type::<ExprSet, crate::generic::ExprSet>(py, m)?;
    super::init_type::<ExprListComp, crate::generic::ExprListComp>(py, m)?;
    super::init_type::<ExprSetComp, crate::generic::ExprSetComp>(py, m)?;
    super::init_type::<ExprDictComp, crate::generic::ExprDictComp>(py, m)?;
    super::init_type::<ExprGeneratorExp, crate::generic::ExprGeneratorExp>(py, m)?;
    super::init_type::<ExprAwait, crate::generic::ExprAwait>(py, m)?;
    super::init_type::<ExprYield, crate::generic::ExprYield>(py, m)?;
    super::init_type::<ExprYieldFrom, crate::generic::ExprYieldFrom>(py, m)?;
    super::init_type::<ExprCompare, crate::generic::ExprCompare>(py, m)?;
    super::init_type::<ExprCall, crate::generic::ExprCall>(py, m)?;
    super::init_type::<ExprFormattedValue, crate::generic::ExprFormattedValue>(py, m)?;
    super::init_type::<ExprJoinedStr, crate::generic::ExprJoinedStr>(py, m)?;
    super::init_type::<ExprConstant, crate::generic::ExprConstant>(py, m)?;
    super::init_type::<ExprAttribute, crate::generic::ExprAttribute>(py, m)?;
    super::init_type::<ExprSubscript, crate::generic::ExprSubscript>(py, m)?;
    super::init_type::<ExprStarred, crate::generic::ExprStarred>(py, m)?;
    super::init_type::<ExprName, crate::generic::ExprName>(py, m)?;
    super::init_type::<ExprList, crate::generic::ExprList>(py, m)?;
    super::init_type::<ExprTuple, crate::generic::ExprTuple>(py, m)?;
    super::init_type::<ExprSlice, crate::generic::ExprSlice>(py, m)?;
    super::init_type::<ExprContext, crate::generic::ExprContext>(py, m)?;
    super::init_type::<ExprContextLoad, crate::generic::ExprContextLoad>(py, m)?;
    super::init_type::<ExprContextStore, crate::generic::ExprContextStore>(py, m)?;
    super::init_type::<ExprContextDel, crate::generic::ExprContextDel>(py, m)?;
    super::init_type::<Boolop, crate::generic::Boolop>(py, m)?;
    super::init_type::<BoolopAnd, crate::generic::BoolopAnd>(py, m)?;
    super::init_type::<BoolopOr, crate::generic::BoolopOr>(py, m)?;
    super::init_type::<Operator, crate::generic::Operator>(py, m)?;
    super::init_type::<OperatorAdd, crate::generic::OperatorAdd>(py, m)?;
    super::init_type::<OperatorSub, crate::generic::OperatorSub>(py, m)?;
    super::init_type::<OperatorMult, crate::generic::OperatorMult>(py, m)?;
    super::init_type::<OperatorMatMult, crate::generic::OperatorMatMult>(py, m)?;
    super::init_type::<OperatorDiv, crate::generic::OperatorDiv>(py, m)?;
    super::init_type::<OperatorMod, crate::generic::OperatorMod>(py, m)?;
    super::init_type::<OperatorPow, crate::generic::OperatorPow>(py, m)?;
    super::init_type::<OperatorLShift, crate::generic::OperatorLShift>(py, m)?;
    super::init_type::<OperatorRShift, crate::generic::OperatorRShift>(py, m)?;
    super::init_type::<OperatorBitOr, crate::generic::OperatorBitOr>(py, m)?;
    super::init_type::<OperatorBitXor, crate::generic::OperatorBitXor>(py, m)?;
    super::init_type::<OperatorBitAnd, crate::generic::OperatorBitAnd>(py, m)?;
    super::init_type::<OperatorFloorDiv, crate::generic::OperatorFloorDiv>(py, m)?;
    super::init_type::<Unaryop, crate::generic::Unaryop>(py, m)?;
    super::init_type::<UnaryopInvert, crate::generic::UnaryopInvert>(py, m)?;
    super::init_type::<UnaryopNot, crate::generic::UnaryopNot>(py, m)?;
    super::init_type::<UnaryopUAdd, crate::generic::UnaryopUAdd>(py, m)?;
    super::init_type::<UnaryopUSub, crate::generic::UnaryopUSub>(py, m)?;
    super::init_type::<Cmpop, crate::generic::Cmpop>(py, m)?;
    super::init_type::<CmpopEq, crate::generic::CmpopEq>(py, m)?;
    super::init_type::<CmpopNotEq, crate::generic::CmpopNotEq>(py, m)?;
    super::init_type::<CmpopLt, crate::generic::CmpopLt>(py, m)?;
    super::init_type::<CmpopLtE, crate::generic::CmpopLtE>(py, m)?;
    super::init_type::<CmpopGt, crate::generic::CmpopGt>(py, m)?;
    super::init_type::<CmpopGtE, crate::generic::CmpopGtE>(py, m)?;
    super::init_type::<CmpopIs, crate::generic::CmpopIs>(py, m)?;
    super::init_type::<CmpopIsNot, crate::generic::CmpopIsNot>(py, m)?;
    super::init_type::<CmpopIn, crate::generic::CmpopIn>(py, m)?;
    super::init_type::<CmpopNotIn, crate::generic::CmpopNotIn>(py, m)?;
    super::init_type::<Comprehension, crate::generic::Comprehension>(py, m)?;
    super::init_type::<Excepthandler, crate::generic::Excepthandler>(py, m)?;
    super::init_type::<ExcepthandlerExceptHandler, crate::generic::ExcepthandlerExceptHandler>(
        py, m,
    )?;
    super::init_type::<Arguments, crate::generic::Arguments>(py, m)?;
    super::init_type::<Arg, crate::generic::Arg>(py, m)?;
    super::init_type::<Keyword, crate::generic::Keyword>(py, m)?;
    super::init_type::<Alias, crate::generic::Alias>(py, m)?;
    super::init_type::<Withitem, crate::generic::Withitem>(py, m)?;
    super::init_type::<MatchCase, crate::generic::MatchCase>(py, m)?;
    super::init_type::<Pattern, crate::generic::Pattern>(py, m)?;
    super::init_type::<PatternMatchValue, crate::generic::PatternMatchValue>(py, m)?;
    super::init_type::<PatternMatchSingleton, crate::generic::PatternMatchSingleton>(py, m)?;
    super::init_type::<PatternMatchSequence, crate::generic::PatternMatchSequence>(py, m)?;
    super::init_type::<PatternMatchMapping, crate::generic::PatternMatchMapping>(py, m)?;
    super::init_type::<PatternMatchClass, crate::generic::PatternMatchClass>(py, m)?;
    super::init_type::<PatternMatchStar, crate::generic::PatternMatchStar>(py, m)?;
    super::init_type::<PatternMatchAs, crate::generic::PatternMatchAs>(py, m)?;
    super::init_type::<PatternMatchOr, crate::generic::PatternMatchOr>(py, m)?;
    super::init_type::<TypeIgnore, crate::generic::TypeIgnore>(py, m)?;
    super::init_type::<TypeIgnoreTypeIgnore, crate::generic::TypeIgnoreTypeIgnore>(py, m)?;
    Ok(())
}
