// File automatically generated by ast/asdl_rs.py.

#[pyclass(module="rustpython_ast.ranged", name="_mod", extends=super::AST, frozen, subclass)]
#[derive(Clone, Debug)]
pub struct Mod;

impl From<&'static crate::Mod<TextRange>> for Mod {
    fn from(_node: &'static crate::Mod<TextRange>) -> Self {
        Mod
    }
}

#[pymethods]
impl Mod {
    #[new]
    fn new() -> PyClassInitializer<Self> {
        PyClassInitializer::from(AST).add_subclass(Self)
    }
}
impl ToPyObject for Mod {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = Self::new();
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::Mod<TextRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        match &self {
            Self::Module(cons) => cons.to_pyo3_wrapper(py),
            Self::Interactive(cons) => cons.to_pyo3_wrapper(py),
            Self::Expression(cons) => cons.to_pyo3_wrapper(py),
            Self::FunctionType(cons) => cons.to_pyo3_wrapper(py),
        }
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Module", extends=Mod, frozen)]
#[derive(Clone, Debug)]
pub struct ModModule(pub &'static crate::ModModule<TextRange>);

impl From<&'static crate::ModModule<TextRange>> for ModModule {
    fn from(node: &'static crate::ModModule<TextRange>) -> Self {
        ModModule(node)
    }
}

impl ToPyObject for ModModule {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Mod)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ModModule<TextRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ModModule(self).to_object(py))
    }
}

#[pymethods]
impl ModModule {
    #[getter]
    #[inline]
    fn get_body(&self, py: Python) -> PyResult<PyObject> {
        self.0.body.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_type_ignores(&self, py: Python) -> PyResult<PyObject> {
        self.0.type_ignores.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Interactive", extends=Mod, frozen)]
#[derive(Clone, Debug)]
pub struct ModInteractive(pub &'static crate::ModInteractive<TextRange>);

impl From<&'static crate::ModInteractive<TextRange>> for ModInteractive {
    fn from(node: &'static crate::ModInteractive<TextRange>) -> Self {
        ModInteractive(node)
    }
}

impl ToPyObject for ModInteractive {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Mod)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ModInteractive<TextRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ModInteractive(self).to_object(py))
    }
}

#[pymethods]
impl ModInteractive {
    #[getter]
    #[inline]
    fn get_body(&self, py: Python) -> PyResult<PyObject> {
        self.0.body.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Expression", extends=Mod, frozen)]
#[derive(Clone, Debug)]
pub struct ModExpression(pub &'static crate::ModExpression<TextRange>);

impl From<&'static crate::ModExpression<TextRange>> for ModExpression {
    fn from(node: &'static crate::ModExpression<TextRange>) -> Self {
        ModExpression(node)
    }
}

impl ToPyObject for ModExpression {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Mod)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ModExpression<TextRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ModExpression(self).to_object(py))
    }
}

#[pymethods]
impl ModExpression {
    #[getter]
    #[inline]
    fn get_body(&self, py: Python) -> PyResult<PyObject> {
        self.0.body.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_FunctionType", extends=Mod, frozen)]
#[derive(Clone, Debug)]
pub struct ModFunctionType(pub &'static crate::ModFunctionType<TextRange>);

impl From<&'static crate::ModFunctionType<TextRange>> for ModFunctionType {
    fn from(node: &'static crate::ModFunctionType<TextRange>) -> Self {
        ModFunctionType(node)
    }
}

impl ToPyObject for ModFunctionType {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Mod)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ModFunctionType<TextRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ModFunctionType(self).to_object(py))
    }
}

#[pymethods]
impl ModFunctionType {
    #[getter]
    #[inline]
    fn get_argtypes(&self, py: Python) -> PyResult<PyObject> {
        self.0.argtypes.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_returns(&self, py: Python) -> PyResult<PyObject> {
        self.0.returns.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_stmt", extends=super::AST, frozen, subclass)]
#[derive(Clone, Debug)]
pub struct Stmt;

impl From<&'static crate::Stmt<TextRange>> for Stmt {
    fn from(_node: &'static crate::Stmt<TextRange>) -> Self {
        Stmt
    }
}

#[pymethods]
impl Stmt {
    #[new]
    fn new() -> PyClassInitializer<Self> {
        PyClassInitializer::from(AST).add_subclass(Self)
    }
}
impl ToPyObject for Stmt {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = Self::new();
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::Stmt<TextRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        match &self {
            Self::FunctionDef(cons) => cons.to_pyo3_wrapper(py),
            Self::AsyncFunctionDef(cons) => cons.to_pyo3_wrapper(py),
            Self::ClassDef(cons) => cons.to_pyo3_wrapper(py),
            Self::Return(cons) => cons.to_pyo3_wrapper(py),
            Self::Delete(cons) => cons.to_pyo3_wrapper(py),
            Self::Assign(cons) => cons.to_pyo3_wrapper(py),
            Self::AugAssign(cons) => cons.to_pyo3_wrapper(py),
            Self::AnnAssign(cons) => cons.to_pyo3_wrapper(py),
            Self::For(cons) => cons.to_pyo3_wrapper(py),
            Self::AsyncFor(cons) => cons.to_pyo3_wrapper(py),
            Self::While(cons) => cons.to_pyo3_wrapper(py),
            Self::If(cons) => cons.to_pyo3_wrapper(py),
            Self::With(cons) => cons.to_pyo3_wrapper(py),
            Self::AsyncWith(cons) => cons.to_pyo3_wrapper(py),
            Self::Match(cons) => cons.to_pyo3_wrapper(py),
            Self::Raise(cons) => cons.to_pyo3_wrapper(py),
            Self::Try(cons) => cons.to_pyo3_wrapper(py),
            Self::TryStar(cons) => cons.to_pyo3_wrapper(py),
            Self::Assert(cons) => cons.to_pyo3_wrapper(py),
            Self::Import(cons) => cons.to_pyo3_wrapper(py),
            Self::ImportFrom(cons) => cons.to_pyo3_wrapper(py),
            Self::Global(cons) => cons.to_pyo3_wrapper(py),
            Self::Nonlocal(cons) => cons.to_pyo3_wrapper(py),
            Self::Expr(cons) => cons.to_pyo3_wrapper(py),
            Self::Pass(cons) => cons.to_pyo3_wrapper(py),
            Self::Break(cons) => cons.to_pyo3_wrapper(py),
            Self::Continue(cons) => cons.to_pyo3_wrapper(py),
        }
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_FunctionDef", extends=Stmt, frozen)]
#[derive(Clone, Debug)]
pub struct StmtFunctionDef(pub &'static crate::StmtFunctionDef<TextRange>);

impl From<&'static crate::StmtFunctionDef<TextRange>> for StmtFunctionDef {
    fn from(node: &'static crate::StmtFunctionDef<TextRange>) -> Self {
        StmtFunctionDef(node)
    }
}

impl ToPyObject for StmtFunctionDef {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Stmt)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::StmtFunctionDef<TextRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(StmtFunctionDef(self).to_object(py))
    }
}

#[pymethods]
impl StmtFunctionDef {
    #[getter]
    #[inline]
    fn get_name(&self, py: Python) -> PyResult<PyObject> {
        self.0.name.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_args(&self, py: Python) -> PyResult<PyObject> {
        self.0.args.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_body(&self, py: Python) -> PyResult<PyObject> {
        self.0.body.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_decorator_list(&self, py: Python) -> PyResult<PyObject> {
        self.0.decorator_list.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_returns(&self, py: Python) -> PyResult<PyObject> {
        self.0.returns.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_type_comment(&self, py: Python) -> PyResult<PyObject> {
        self.0.type_comment.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_AsyncFunctionDef", extends=Stmt, frozen)]
#[derive(Clone, Debug)]
pub struct StmtAsyncFunctionDef(pub &'static crate::StmtAsyncFunctionDef<TextRange>);

impl From<&'static crate::StmtAsyncFunctionDef<TextRange>> for StmtAsyncFunctionDef {
    fn from(node: &'static crate::StmtAsyncFunctionDef<TextRange>) -> Self {
        StmtAsyncFunctionDef(node)
    }
}

impl ToPyObject for StmtAsyncFunctionDef {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Stmt)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::StmtAsyncFunctionDef<TextRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(StmtAsyncFunctionDef(self).to_object(py))
    }
}

#[pymethods]
impl StmtAsyncFunctionDef {
    #[getter]
    #[inline]
    fn get_name(&self, py: Python) -> PyResult<PyObject> {
        self.0.name.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_args(&self, py: Python) -> PyResult<PyObject> {
        self.0.args.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_body(&self, py: Python) -> PyResult<PyObject> {
        self.0.body.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_decorator_list(&self, py: Python) -> PyResult<PyObject> {
        self.0.decorator_list.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_returns(&self, py: Python) -> PyResult<PyObject> {
        self.0.returns.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_type_comment(&self, py: Python) -> PyResult<PyObject> {
        self.0.type_comment.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_ClassDef", extends=Stmt, frozen)]
#[derive(Clone, Debug)]
pub struct StmtClassDef(pub &'static crate::StmtClassDef<TextRange>);

impl From<&'static crate::StmtClassDef<TextRange>> for StmtClassDef {
    fn from(node: &'static crate::StmtClassDef<TextRange>) -> Self {
        StmtClassDef(node)
    }
}

impl ToPyObject for StmtClassDef {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Stmt)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::StmtClassDef<TextRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(StmtClassDef(self).to_object(py))
    }
}

#[pymethods]
impl StmtClassDef {
    #[getter]
    #[inline]
    fn get_name(&self, py: Python) -> PyResult<PyObject> {
        self.0.name.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_bases(&self, py: Python) -> PyResult<PyObject> {
        self.0.bases.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_keywords(&self, py: Python) -> PyResult<PyObject> {
        self.0.keywords.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_body(&self, py: Python) -> PyResult<PyObject> {
        self.0.body.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_decorator_list(&self, py: Python) -> PyResult<PyObject> {
        self.0.decorator_list.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Return", extends=Stmt, frozen)]
#[derive(Clone, Debug)]
pub struct StmtReturn(pub &'static crate::StmtReturn<TextRange>);

impl From<&'static crate::StmtReturn<TextRange>> for StmtReturn {
    fn from(node: &'static crate::StmtReturn<TextRange>) -> Self {
        StmtReturn(node)
    }
}

impl ToPyObject for StmtReturn {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Stmt)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::StmtReturn<TextRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(StmtReturn(self).to_object(py))
    }
}

#[pymethods]
impl StmtReturn {
    #[getter]
    #[inline]
    fn get_value(&self, py: Python) -> PyResult<PyObject> {
        self.0.value.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Delete", extends=Stmt, frozen)]
#[derive(Clone, Debug)]
pub struct StmtDelete(pub &'static crate::StmtDelete<TextRange>);

impl From<&'static crate::StmtDelete<TextRange>> for StmtDelete {
    fn from(node: &'static crate::StmtDelete<TextRange>) -> Self {
        StmtDelete(node)
    }
}

impl ToPyObject for StmtDelete {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Stmt)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::StmtDelete<TextRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(StmtDelete(self).to_object(py))
    }
}

#[pymethods]
impl StmtDelete {
    #[getter]
    #[inline]
    fn get_targets(&self, py: Python) -> PyResult<PyObject> {
        self.0.targets.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Assign", extends=Stmt, frozen)]
#[derive(Clone, Debug)]
pub struct StmtAssign(pub &'static crate::StmtAssign<TextRange>);

impl From<&'static crate::StmtAssign<TextRange>> for StmtAssign {
    fn from(node: &'static crate::StmtAssign<TextRange>) -> Self {
        StmtAssign(node)
    }
}

impl ToPyObject for StmtAssign {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Stmt)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::StmtAssign<TextRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(StmtAssign(self).to_object(py))
    }
}

#[pymethods]
impl StmtAssign {
    #[getter]
    #[inline]
    fn get_targets(&self, py: Python) -> PyResult<PyObject> {
        self.0.targets.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_value(&self, py: Python) -> PyResult<PyObject> {
        self.0.value.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_type_comment(&self, py: Python) -> PyResult<PyObject> {
        self.0.type_comment.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_AugAssign", extends=Stmt, frozen)]
#[derive(Clone, Debug)]
pub struct StmtAugAssign(pub &'static crate::StmtAugAssign<TextRange>);

impl From<&'static crate::StmtAugAssign<TextRange>> for StmtAugAssign {
    fn from(node: &'static crate::StmtAugAssign<TextRange>) -> Self {
        StmtAugAssign(node)
    }
}

impl ToPyObject for StmtAugAssign {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Stmt)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::StmtAugAssign<TextRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(StmtAugAssign(self).to_object(py))
    }
}

#[pymethods]
impl StmtAugAssign {
    #[getter]
    #[inline]
    fn get_target(&self, py: Python) -> PyResult<PyObject> {
        self.0.target.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_op(&self, py: Python) -> PyResult<PyObject> {
        self.0.op.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_value(&self, py: Python) -> PyResult<PyObject> {
        self.0.value.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_AnnAssign", extends=Stmt, frozen)]
#[derive(Clone, Debug)]
pub struct StmtAnnAssign(pub &'static crate::StmtAnnAssign<TextRange>);

impl From<&'static crate::StmtAnnAssign<TextRange>> for StmtAnnAssign {
    fn from(node: &'static crate::StmtAnnAssign<TextRange>) -> Self {
        StmtAnnAssign(node)
    }
}

impl ToPyObject for StmtAnnAssign {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Stmt)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::StmtAnnAssign<TextRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(StmtAnnAssign(self).to_object(py))
    }
}

#[pymethods]
impl StmtAnnAssign {
    #[getter]
    #[inline]
    fn get_target(&self, py: Python) -> PyResult<PyObject> {
        self.0.target.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_annotation(&self, py: Python) -> PyResult<PyObject> {
        self.0.annotation.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_value(&self, py: Python) -> PyResult<PyObject> {
        self.0.value.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_simple(&self, py: Python) -> PyResult<PyObject> {
        self.0.simple.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_For", extends=Stmt, frozen)]
#[derive(Clone, Debug)]
pub struct StmtFor(pub &'static crate::StmtFor<TextRange>);

impl From<&'static crate::StmtFor<TextRange>> for StmtFor {
    fn from(node: &'static crate::StmtFor<TextRange>) -> Self {
        StmtFor(node)
    }
}

impl ToPyObject for StmtFor {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Stmt)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::StmtFor<TextRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(StmtFor(self).to_object(py))
    }
}

#[pymethods]
impl StmtFor {
    #[getter]
    #[inline]
    fn get_target(&self, py: Python) -> PyResult<PyObject> {
        self.0.target.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_iter(&self, py: Python) -> PyResult<PyObject> {
        self.0.iter.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_body(&self, py: Python) -> PyResult<PyObject> {
        self.0.body.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_orelse(&self, py: Python) -> PyResult<PyObject> {
        self.0.orelse.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_type_comment(&self, py: Python) -> PyResult<PyObject> {
        self.0.type_comment.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_AsyncFor", extends=Stmt, frozen)]
#[derive(Clone, Debug)]
pub struct StmtAsyncFor(pub &'static crate::StmtAsyncFor<TextRange>);

impl From<&'static crate::StmtAsyncFor<TextRange>> for StmtAsyncFor {
    fn from(node: &'static crate::StmtAsyncFor<TextRange>) -> Self {
        StmtAsyncFor(node)
    }
}

impl ToPyObject for StmtAsyncFor {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Stmt)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::StmtAsyncFor<TextRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(StmtAsyncFor(self).to_object(py))
    }
}

#[pymethods]
impl StmtAsyncFor {
    #[getter]
    #[inline]
    fn get_target(&self, py: Python) -> PyResult<PyObject> {
        self.0.target.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_iter(&self, py: Python) -> PyResult<PyObject> {
        self.0.iter.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_body(&self, py: Python) -> PyResult<PyObject> {
        self.0.body.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_orelse(&self, py: Python) -> PyResult<PyObject> {
        self.0.orelse.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_type_comment(&self, py: Python) -> PyResult<PyObject> {
        self.0.type_comment.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_While", extends=Stmt, frozen)]
#[derive(Clone, Debug)]
pub struct StmtWhile(pub &'static crate::StmtWhile<TextRange>);

impl From<&'static crate::StmtWhile<TextRange>> for StmtWhile {
    fn from(node: &'static crate::StmtWhile<TextRange>) -> Self {
        StmtWhile(node)
    }
}

impl ToPyObject for StmtWhile {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Stmt)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::StmtWhile<TextRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(StmtWhile(self).to_object(py))
    }
}

#[pymethods]
impl StmtWhile {
    #[getter]
    #[inline]
    fn get_test(&self, py: Python) -> PyResult<PyObject> {
        self.0.test.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_body(&self, py: Python) -> PyResult<PyObject> {
        self.0.body.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_orelse(&self, py: Python) -> PyResult<PyObject> {
        self.0.orelse.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_If", extends=Stmt, frozen)]
#[derive(Clone, Debug)]
pub struct StmtIf(pub &'static crate::StmtIf<TextRange>);

impl From<&'static crate::StmtIf<TextRange>> for StmtIf {
    fn from(node: &'static crate::StmtIf<TextRange>) -> Self {
        StmtIf(node)
    }
}

impl ToPyObject for StmtIf {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Stmt)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::StmtIf<TextRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(StmtIf(self).to_object(py))
    }
}

#[pymethods]
impl StmtIf {
    #[getter]
    #[inline]
    fn get_test(&self, py: Python) -> PyResult<PyObject> {
        self.0.test.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_body(&self, py: Python) -> PyResult<PyObject> {
        self.0.body.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_orelse(&self, py: Python) -> PyResult<PyObject> {
        self.0.orelse.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_With", extends=Stmt, frozen)]
#[derive(Clone, Debug)]
pub struct StmtWith(pub &'static crate::StmtWith<TextRange>);

impl From<&'static crate::StmtWith<TextRange>> for StmtWith {
    fn from(node: &'static crate::StmtWith<TextRange>) -> Self {
        StmtWith(node)
    }
}

impl ToPyObject for StmtWith {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Stmt)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::StmtWith<TextRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(StmtWith(self).to_object(py))
    }
}

#[pymethods]
impl StmtWith {
    #[getter]
    #[inline]
    fn get_items(&self, py: Python) -> PyResult<PyObject> {
        self.0.items.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_body(&self, py: Python) -> PyResult<PyObject> {
        self.0.body.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_type_comment(&self, py: Python) -> PyResult<PyObject> {
        self.0.type_comment.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_AsyncWith", extends=Stmt, frozen)]
#[derive(Clone, Debug)]
pub struct StmtAsyncWith(pub &'static crate::StmtAsyncWith<TextRange>);

impl From<&'static crate::StmtAsyncWith<TextRange>> for StmtAsyncWith {
    fn from(node: &'static crate::StmtAsyncWith<TextRange>) -> Self {
        StmtAsyncWith(node)
    }
}

impl ToPyObject for StmtAsyncWith {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Stmt)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::StmtAsyncWith<TextRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(StmtAsyncWith(self).to_object(py))
    }
}

#[pymethods]
impl StmtAsyncWith {
    #[getter]
    #[inline]
    fn get_items(&self, py: Python) -> PyResult<PyObject> {
        self.0.items.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_body(&self, py: Python) -> PyResult<PyObject> {
        self.0.body.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_type_comment(&self, py: Python) -> PyResult<PyObject> {
        self.0.type_comment.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Match", extends=Stmt, frozen)]
#[derive(Clone, Debug)]
pub struct StmtMatch(pub &'static crate::StmtMatch<TextRange>);

impl From<&'static crate::StmtMatch<TextRange>> for StmtMatch {
    fn from(node: &'static crate::StmtMatch<TextRange>) -> Self {
        StmtMatch(node)
    }
}

impl ToPyObject for StmtMatch {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Stmt)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::StmtMatch<TextRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(StmtMatch(self).to_object(py))
    }
}

#[pymethods]
impl StmtMatch {
    #[getter]
    #[inline]
    fn get_subject(&self, py: Python) -> PyResult<PyObject> {
        self.0.subject.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_cases(&self, py: Python) -> PyResult<PyObject> {
        self.0.cases.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Raise", extends=Stmt, frozen)]
#[derive(Clone, Debug)]
pub struct StmtRaise(pub &'static crate::StmtRaise<TextRange>);

impl From<&'static crate::StmtRaise<TextRange>> for StmtRaise {
    fn from(node: &'static crate::StmtRaise<TextRange>) -> Self {
        StmtRaise(node)
    }
}

impl ToPyObject for StmtRaise {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Stmt)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::StmtRaise<TextRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(StmtRaise(self).to_object(py))
    }
}

#[pymethods]
impl StmtRaise {
    #[getter]
    #[inline]
    fn get_exc(&self, py: Python) -> PyResult<PyObject> {
        self.0.exc.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_cause(&self, py: Python) -> PyResult<PyObject> {
        self.0.cause.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Try", extends=Stmt, frozen)]
#[derive(Clone, Debug)]
pub struct StmtTry(pub &'static crate::StmtTry<TextRange>);

impl From<&'static crate::StmtTry<TextRange>> for StmtTry {
    fn from(node: &'static crate::StmtTry<TextRange>) -> Self {
        StmtTry(node)
    }
}

impl ToPyObject for StmtTry {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Stmt)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::StmtTry<TextRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(StmtTry(self).to_object(py))
    }
}

#[pymethods]
impl StmtTry {
    #[getter]
    #[inline]
    fn get_body(&self, py: Python) -> PyResult<PyObject> {
        self.0.body.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_handlers(&self, py: Python) -> PyResult<PyObject> {
        self.0.handlers.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_orelse(&self, py: Python) -> PyResult<PyObject> {
        self.0.orelse.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_finalbody(&self, py: Python) -> PyResult<PyObject> {
        self.0.finalbody.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_TryStar", extends=Stmt, frozen)]
#[derive(Clone, Debug)]
pub struct StmtTryStar(pub &'static crate::StmtTryStar<TextRange>);

impl From<&'static crate::StmtTryStar<TextRange>> for StmtTryStar {
    fn from(node: &'static crate::StmtTryStar<TextRange>) -> Self {
        StmtTryStar(node)
    }
}

impl ToPyObject for StmtTryStar {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Stmt)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::StmtTryStar<TextRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(StmtTryStar(self).to_object(py))
    }
}

#[pymethods]
impl StmtTryStar {
    #[getter]
    #[inline]
    fn get_body(&self, py: Python) -> PyResult<PyObject> {
        self.0.body.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_handlers(&self, py: Python) -> PyResult<PyObject> {
        self.0.handlers.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_orelse(&self, py: Python) -> PyResult<PyObject> {
        self.0.orelse.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_finalbody(&self, py: Python) -> PyResult<PyObject> {
        self.0.finalbody.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Assert", extends=Stmt, frozen)]
#[derive(Clone, Debug)]
pub struct StmtAssert(pub &'static crate::StmtAssert<TextRange>);

impl From<&'static crate::StmtAssert<TextRange>> for StmtAssert {
    fn from(node: &'static crate::StmtAssert<TextRange>) -> Self {
        StmtAssert(node)
    }
}

impl ToPyObject for StmtAssert {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Stmt)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::StmtAssert<TextRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(StmtAssert(self).to_object(py))
    }
}

#[pymethods]
impl StmtAssert {
    #[getter]
    #[inline]
    fn get_test(&self, py: Python) -> PyResult<PyObject> {
        self.0.test.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_msg(&self, py: Python) -> PyResult<PyObject> {
        self.0.msg.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Import", extends=Stmt, frozen)]
#[derive(Clone, Debug)]
pub struct StmtImport(pub &'static crate::StmtImport<TextRange>);

impl From<&'static crate::StmtImport<TextRange>> for StmtImport {
    fn from(node: &'static crate::StmtImport<TextRange>) -> Self {
        StmtImport(node)
    }
}

impl ToPyObject for StmtImport {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Stmt)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::StmtImport<TextRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(StmtImport(self).to_object(py))
    }
}

#[pymethods]
impl StmtImport {
    #[getter]
    #[inline]
    fn get_names(&self, py: Python) -> PyResult<PyObject> {
        self.0.names.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_ImportFrom", extends=Stmt, frozen)]
#[derive(Clone, Debug)]
pub struct StmtImportFrom(pub &'static crate::StmtImportFrom<TextRange>);

impl From<&'static crate::StmtImportFrom<TextRange>> for StmtImportFrom {
    fn from(node: &'static crate::StmtImportFrom<TextRange>) -> Self {
        StmtImportFrom(node)
    }
}

impl ToPyObject for StmtImportFrom {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Stmt)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::StmtImportFrom<TextRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(StmtImportFrom(self).to_object(py))
    }
}

#[pymethods]
impl StmtImportFrom {
    #[getter]
    #[inline]
    fn get_module(&self, py: Python) -> PyResult<PyObject> {
        self.0.module.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_names(&self, py: Python) -> PyResult<PyObject> {
        self.0.names.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_level(&self, py: Python) -> PyResult<PyObject> {
        self.0.level.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Global", extends=Stmt, frozen)]
#[derive(Clone, Debug)]
pub struct StmtGlobal(pub &'static crate::StmtGlobal<TextRange>);

impl From<&'static crate::StmtGlobal<TextRange>> for StmtGlobal {
    fn from(node: &'static crate::StmtGlobal<TextRange>) -> Self {
        StmtGlobal(node)
    }
}

impl ToPyObject for StmtGlobal {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Stmt)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::StmtGlobal<TextRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(StmtGlobal(self).to_object(py))
    }
}

#[pymethods]
impl StmtGlobal {
    #[getter]
    #[inline]
    fn get_names(&self, py: Python) -> PyResult<PyObject> {
        self.0.names.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Nonlocal", extends=Stmt, frozen)]
#[derive(Clone, Debug)]
pub struct StmtNonlocal(pub &'static crate::StmtNonlocal<TextRange>);

impl From<&'static crate::StmtNonlocal<TextRange>> for StmtNonlocal {
    fn from(node: &'static crate::StmtNonlocal<TextRange>) -> Self {
        StmtNonlocal(node)
    }
}

impl ToPyObject for StmtNonlocal {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Stmt)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::StmtNonlocal<TextRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(StmtNonlocal(self).to_object(py))
    }
}

#[pymethods]
impl StmtNonlocal {
    #[getter]
    #[inline]
    fn get_names(&self, py: Python) -> PyResult<PyObject> {
        self.0.names.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Expr", extends=Stmt, frozen)]
#[derive(Clone, Debug)]
pub struct StmtExpr(pub &'static crate::StmtExpr<TextRange>);

impl From<&'static crate::StmtExpr<TextRange>> for StmtExpr {
    fn from(node: &'static crate::StmtExpr<TextRange>) -> Self {
        StmtExpr(node)
    }
}

impl ToPyObject for StmtExpr {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Stmt)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::StmtExpr<TextRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(StmtExpr(self).to_object(py))
    }
}

#[pymethods]
impl StmtExpr {
    #[getter]
    #[inline]
    fn get_value(&self, py: Python) -> PyResult<PyObject> {
        self.0.value.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Pass", extends=Stmt, frozen)]
#[derive(Clone, Debug)]
pub struct StmtPass(pub &'static crate::StmtPass<TextRange>);

impl From<&'static crate::StmtPass<TextRange>> for StmtPass {
    fn from(node: &'static crate::StmtPass<TextRange>) -> Self {
        StmtPass(node)
    }
}

impl ToPyObject for StmtPass {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Stmt)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::StmtPass<TextRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(StmtPass(self).to_object(py))
    }
}

#[pymethods]
impl StmtPass {}

#[pyclass(module="rustpython_ast.ranged", name="_Break", extends=Stmt, frozen)]
#[derive(Clone, Debug)]
pub struct StmtBreak(pub &'static crate::StmtBreak<TextRange>);

impl From<&'static crate::StmtBreak<TextRange>> for StmtBreak {
    fn from(node: &'static crate::StmtBreak<TextRange>) -> Self {
        StmtBreak(node)
    }
}

impl ToPyObject for StmtBreak {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Stmt)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::StmtBreak<TextRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(StmtBreak(self).to_object(py))
    }
}

#[pymethods]
impl StmtBreak {}

#[pyclass(module="rustpython_ast.ranged", name="_Continue", extends=Stmt, frozen)]
#[derive(Clone, Debug)]
pub struct StmtContinue(pub &'static crate::StmtContinue<TextRange>);

impl From<&'static crate::StmtContinue<TextRange>> for StmtContinue {
    fn from(node: &'static crate::StmtContinue<TextRange>) -> Self {
        StmtContinue(node)
    }
}

impl ToPyObject for StmtContinue {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Stmt)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::StmtContinue<TextRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(StmtContinue(self).to_object(py))
    }
}

#[pymethods]
impl StmtContinue {}

#[pyclass(module="rustpython_ast.ranged", name="_expr", extends=super::AST, frozen, subclass)]
#[derive(Clone, Debug)]
pub struct Expr;

impl From<&'static crate::Expr<TextRange>> for Expr {
    fn from(_node: &'static crate::Expr<TextRange>) -> Self {
        Expr
    }
}

#[pymethods]
impl Expr {
    #[new]
    fn new() -> PyClassInitializer<Self> {
        PyClassInitializer::from(AST).add_subclass(Self)
    }
}
impl ToPyObject for Expr {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = Self::new();
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::Expr<TextRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        match &self {
            Self::BoolOp(cons) => cons.to_pyo3_wrapper(py),
            Self::NamedExpr(cons) => cons.to_pyo3_wrapper(py),
            Self::BinOp(cons) => cons.to_pyo3_wrapper(py),
            Self::UnaryOp(cons) => cons.to_pyo3_wrapper(py),
            Self::Lambda(cons) => cons.to_pyo3_wrapper(py),
            Self::IfExp(cons) => cons.to_pyo3_wrapper(py),
            Self::Dict(cons) => cons.to_pyo3_wrapper(py),
            Self::Set(cons) => cons.to_pyo3_wrapper(py),
            Self::ListComp(cons) => cons.to_pyo3_wrapper(py),
            Self::SetComp(cons) => cons.to_pyo3_wrapper(py),
            Self::DictComp(cons) => cons.to_pyo3_wrapper(py),
            Self::GeneratorExp(cons) => cons.to_pyo3_wrapper(py),
            Self::Await(cons) => cons.to_pyo3_wrapper(py),
            Self::Yield(cons) => cons.to_pyo3_wrapper(py),
            Self::YieldFrom(cons) => cons.to_pyo3_wrapper(py),
            Self::Compare(cons) => cons.to_pyo3_wrapper(py),
            Self::Call(cons) => cons.to_pyo3_wrapper(py),
            Self::FormattedValue(cons) => cons.to_pyo3_wrapper(py),
            Self::JoinedStr(cons) => cons.to_pyo3_wrapper(py),
            Self::Constant(cons) => cons.to_pyo3_wrapper(py),
            Self::Attribute(cons) => cons.to_pyo3_wrapper(py),
            Self::Subscript(cons) => cons.to_pyo3_wrapper(py),
            Self::Starred(cons) => cons.to_pyo3_wrapper(py),
            Self::Name(cons) => cons.to_pyo3_wrapper(py),
            Self::List(cons) => cons.to_pyo3_wrapper(py),
            Self::Tuple(cons) => cons.to_pyo3_wrapper(py),
            Self::Slice(cons) => cons.to_pyo3_wrapper(py),
        }
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_BoolOp", extends=Expr, frozen)]
#[derive(Clone, Debug)]
pub struct ExprBoolOp(pub &'static crate::ExprBoolOp<TextRange>);

impl From<&'static crate::ExprBoolOp<TextRange>> for ExprBoolOp {
    fn from(node: &'static crate::ExprBoolOp<TextRange>) -> Self {
        ExprBoolOp(node)
    }
}

impl ToPyObject for ExprBoolOp {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Expr)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ExprBoolOp<TextRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ExprBoolOp(self).to_object(py))
    }
}

#[pymethods]
impl ExprBoolOp {
    #[getter]
    #[inline]
    fn get_op(&self, py: Python) -> PyResult<PyObject> {
        self.0.op.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_values(&self, py: Python) -> PyResult<PyObject> {
        self.0.values.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_NamedExpr", extends=Expr, frozen)]
#[derive(Clone, Debug)]
pub struct ExprNamedExpr(pub &'static crate::ExprNamedExpr<TextRange>);

impl From<&'static crate::ExprNamedExpr<TextRange>> for ExprNamedExpr {
    fn from(node: &'static crate::ExprNamedExpr<TextRange>) -> Self {
        ExprNamedExpr(node)
    }
}

impl ToPyObject for ExprNamedExpr {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Expr)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ExprNamedExpr<TextRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ExprNamedExpr(self).to_object(py))
    }
}

#[pymethods]
impl ExprNamedExpr {
    #[getter]
    #[inline]
    fn get_target(&self, py: Python) -> PyResult<PyObject> {
        self.0.target.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_value(&self, py: Python) -> PyResult<PyObject> {
        self.0.value.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_BinOp", extends=Expr, frozen)]
#[derive(Clone, Debug)]
pub struct ExprBinOp(pub &'static crate::ExprBinOp<TextRange>);

impl From<&'static crate::ExprBinOp<TextRange>> for ExprBinOp {
    fn from(node: &'static crate::ExprBinOp<TextRange>) -> Self {
        ExprBinOp(node)
    }
}

impl ToPyObject for ExprBinOp {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Expr)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ExprBinOp<TextRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ExprBinOp(self).to_object(py))
    }
}

#[pymethods]
impl ExprBinOp {
    #[getter]
    #[inline]
    fn get_left(&self, py: Python) -> PyResult<PyObject> {
        self.0.left.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_op(&self, py: Python) -> PyResult<PyObject> {
        self.0.op.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_right(&self, py: Python) -> PyResult<PyObject> {
        self.0.right.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_UnaryOp", extends=Expr, frozen)]
#[derive(Clone, Debug)]
pub struct ExprUnaryOp(pub &'static crate::ExprUnaryOp<TextRange>);

impl From<&'static crate::ExprUnaryOp<TextRange>> for ExprUnaryOp {
    fn from(node: &'static crate::ExprUnaryOp<TextRange>) -> Self {
        ExprUnaryOp(node)
    }
}

impl ToPyObject for ExprUnaryOp {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Expr)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ExprUnaryOp<TextRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ExprUnaryOp(self).to_object(py))
    }
}

#[pymethods]
impl ExprUnaryOp {
    #[getter]
    #[inline]
    fn get_op(&self, py: Python) -> PyResult<PyObject> {
        self.0.op.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_operand(&self, py: Python) -> PyResult<PyObject> {
        self.0.operand.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Lambda", extends=Expr, frozen)]
#[derive(Clone, Debug)]
pub struct ExprLambda(pub &'static crate::ExprLambda<TextRange>);

impl From<&'static crate::ExprLambda<TextRange>> for ExprLambda {
    fn from(node: &'static crate::ExprLambda<TextRange>) -> Self {
        ExprLambda(node)
    }
}

impl ToPyObject for ExprLambda {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Expr)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ExprLambda<TextRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ExprLambda(self).to_object(py))
    }
}

#[pymethods]
impl ExprLambda {
    #[getter]
    #[inline]
    fn get_args(&self, py: Python) -> PyResult<PyObject> {
        self.0.args.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_body(&self, py: Python) -> PyResult<PyObject> {
        self.0.body.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_IfExp", extends=Expr, frozen)]
#[derive(Clone, Debug)]
pub struct ExprIfExp(pub &'static crate::ExprIfExp<TextRange>);

impl From<&'static crate::ExprIfExp<TextRange>> for ExprIfExp {
    fn from(node: &'static crate::ExprIfExp<TextRange>) -> Self {
        ExprIfExp(node)
    }
}

impl ToPyObject for ExprIfExp {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Expr)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ExprIfExp<TextRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ExprIfExp(self).to_object(py))
    }
}

#[pymethods]
impl ExprIfExp {
    #[getter]
    #[inline]
    fn get_test(&self, py: Python) -> PyResult<PyObject> {
        self.0.test.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_body(&self, py: Python) -> PyResult<PyObject> {
        self.0.body.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_orelse(&self, py: Python) -> PyResult<PyObject> {
        self.0.orelse.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Dict", extends=Expr, frozen)]
#[derive(Clone, Debug)]
pub struct ExprDict(pub &'static crate::ExprDict<TextRange>);

impl From<&'static crate::ExprDict<TextRange>> for ExprDict {
    fn from(node: &'static crate::ExprDict<TextRange>) -> Self {
        ExprDict(node)
    }
}

impl ToPyObject for ExprDict {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Expr)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ExprDict<TextRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ExprDict(self).to_object(py))
    }
}

#[pymethods]
impl ExprDict {
    #[getter]
    #[inline]
    fn get_keys(&self, py: Python) -> PyResult<PyObject> {
        self.0.keys.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_values(&self, py: Python) -> PyResult<PyObject> {
        self.0.values.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Set", extends=Expr, frozen)]
#[derive(Clone, Debug)]
pub struct ExprSet(pub &'static crate::ExprSet<TextRange>);

impl From<&'static crate::ExprSet<TextRange>> for ExprSet {
    fn from(node: &'static crate::ExprSet<TextRange>) -> Self {
        ExprSet(node)
    }
}

impl ToPyObject for ExprSet {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Expr)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ExprSet<TextRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ExprSet(self).to_object(py))
    }
}

#[pymethods]
impl ExprSet {
    #[getter]
    #[inline]
    fn get_elts(&self, py: Python) -> PyResult<PyObject> {
        self.0.elts.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_ListComp", extends=Expr, frozen)]
#[derive(Clone, Debug)]
pub struct ExprListComp(pub &'static crate::ExprListComp<TextRange>);

impl From<&'static crate::ExprListComp<TextRange>> for ExprListComp {
    fn from(node: &'static crate::ExprListComp<TextRange>) -> Self {
        ExprListComp(node)
    }
}

impl ToPyObject for ExprListComp {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Expr)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ExprListComp<TextRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ExprListComp(self).to_object(py))
    }
}

#[pymethods]
impl ExprListComp {
    #[getter]
    #[inline]
    fn get_elt(&self, py: Python) -> PyResult<PyObject> {
        self.0.elt.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_generators(&self, py: Python) -> PyResult<PyObject> {
        self.0.generators.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_SetComp", extends=Expr, frozen)]
#[derive(Clone, Debug)]
pub struct ExprSetComp(pub &'static crate::ExprSetComp<TextRange>);

impl From<&'static crate::ExprSetComp<TextRange>> for ExprSetComp {
    fn from(node: &'static crate::ExprSetComp<TextRange>) -> Self {
        ExprSetComp(node)
    }
}

impl ToPyObject for ExprSetComp {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Expr)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ExprSetComp<TextRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ExprSetComp(self).to_object(py))
    }
}

#[pymethods]
impl ExprSetComp {
    #[getter]
    #[inline]
    fn get_elt(&self, py: Python) -> PyResult<PyObject> {
        self.0.elt.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_generators(&self, py: Python) -> PyResult<PyObject> {
        self.0.generators.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_DictComp", extends=Expr, frozen)]
#[derive(Clone, Debug)]
pub struct ExprDictComp(pub &'static crate::ExprDictComp<TextRange>);

impl From<&'static crate::ExprDictComp<TextRange>> for ExprDictComp {
    fn from(node: &'static crate::ExprDictComp<TextRange>) -> Self {
        ExprDictComp(node)
    }
}

impl ToPyObject for ExprDictComp {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Expr)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ExprDictComp<TextRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ExprDictComp(self).to_object(py))
    }
}

#[pymethods]
impl ExprDictComp {
    #[getter]
    #[inline]
    fn get_key(&self, py: Python) -> PyResult<PyObject> {
        self.0.key.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_value(&self, py: Python) -> PyResult<PyObject> {
        self.0.value.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_generators(&self, py: Python) -> PyResult<PyObject> {
        self.0.generators.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_GeneratorExp", extends=Expr, frozen)]
#[derive(Clone, Debug)]
pub struct ExprGeneratorExp(pub &'static crate::ExprGeneratorExp<TextRange>);

impl From<&'static crate::ExprGeneratorExp<TextRange>> for ExprGeneratorExp {
    fn from(node: &'static crate::ExprGeneratorExp<TextRange>) -> Self {
        ExprGeneratorExp(node)
    }
}

impl ToPyObject for ExprGeneratorExp {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Expr)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ExprGeneratorExp<TextRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ExprGeneratorExp(self).to_object(py))
    }
}

#[pymethods]
impl ExprGeneratorExp {
    #[getter]
    #[inline]
    fn get_elt(&self, py: Python) -> PyResult<PyObject> {
        self.0.elt.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_generators(&self, py: Python) -> PyResult<PyObject> {
        self.0.generators.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Await", extends=Expr, frozen)]
#[derive(Clone, Debug)]
pub struct ExprAwait(pub &'static crate::ExprAwait<TextRange>);

impl From<&'static crate::ExprAwait<TextRange>> for ExprAwait {
    fn from(node: &'static crate::ExprAwait<TextRange>) -> Self {
        ExprAwait(node)
    }
}

impl ToPyObject for ExprAwait {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Expr)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ExprAwait<TextRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ExprAwait(self).to_object(py))
    }
}

#[pymethods]
impl ExprAwait {
    #[getter]
    #[inline]
    fn get_value(&self, py: Python) -> PyResult<PyObject> {
        self.0.value.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Yield", extends=Expr, frozen)]
#[derive(Clone, Debug)]
pub struct ExprYield(pub &'static crate::ExprYield<TextRange>);

impl From<&'static crate::ExprYield<TextRange>> for ExprYield {
    fn from(node: &'static crate::ExprYield<TextRange>) -> Self {
        ExprYield(node)
    }
}

impl ToPyObject for ExprYield {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Expr)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ExprYield<TextRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ExprYield(self).to_object(py))
    }
}

#[pymethods]
impl ExprYield {
    #[getter]
    #[inline]
    fn get_value(&self, py: Python) -> PyResult<PyObject> {
        self.0.value.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_YieldFrom", extends=Expr, frozen)]
#[derive(Clone, Debug)]
pub struct ExprYieldFrom(pub &'static crate::ExprYieldFrom<TextRange>);

impl From<&'static crate::ExprYieldFrom<TextRange>> for ExprYieldFrom {
    fn from(node: &'static crate::ExprYieldFrom<TextRange>) -> Self {
        ExprYieldFrom(node)
    }
}

impl ToPyObject for ExprYieldFrom {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Expr)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ExprYieldFrom<TextRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ExprYieldFrom(self).to_object(py))
    }
}

#[pymethods]
impl ExprYieldFrom {
    #[getter]
    #[inline]
    fn get_value(&self, py: Python) -> PyResult<PyObject> {
        self.0.value.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Compare", extends=Expr, frozen)]
#[derive(Clone, Debug)]
pub struct ExprCompare(pub &'static crate::ExprCompare<TextRange>);

impl From<&'static crate::ExprCompare<TextRange>> for ExprCompare {
    fn from(node: &'static crate::ExprCompare<TextRange>) -> Self {
        ExprCompare(node)
    }
}

impl ToPyObject for ExprCompare {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Expr)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ExprCompare<TextRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ExprCompare(self).to_object(py))
    }
}

#[pymethods]
impl ExprCompare {
    #[getter]
    #[inline]
    fn get_left(&self, py: Python) -> PyResult<PyObject> {
        self.0.left.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_ops(&self, py: Python) -> PyResult<PyObject> {
        self.0.ops.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_comparators(&self, py: Python) -> PyResult<PyObject> {
        self.0.comparators.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Call", extends=Expr, frozen)]
#[derive(Clone, Debug)]
pub struct ExprCall(pub &'static crate::ExprCall<TextRange>);

impl From<&'static crate::ExprCall<TextRange>> for ExprCall {
    fn from(node: &'static crate::ExprCall<TextRange>) -> Self {
        ExprCall(node)
    }
}

impl ToPyObject for ExprCall {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Expr)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ExprCall<TextRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ExprCall(self).to_object(py))
    }
}

#[pymethods]
impl ExprCall {
    #[getter]
    #[inline]
    fn get_func(&self, py: Python) -> PyResult<PyObject> {
        self.0.func.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_args(&self, py: Python) -> PyResult<PyObject> {
        self.0.args.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_keywords(&self, py: Python) -> PyResult<PyObject> {
        self.0.keywords.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_FormattedValue", extends=Expr, frozen)]
#[derive(Clone, Debug)]
pub struct ExprFormattedValue(pub &'static crate::ExprFormattedValue<TextRange>);

impl From<&'static crate::ExprFormattedValue<TextRange>> for ExprFormattedValue {
    fn from(node: &'static crate::ExprFormattedValue<TextRange>) -> Self {
        ExprFormattedValue(node)
    }
}

impl ToPyObject for ExprFormattedValue {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Expr)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ExprFormattedValue<TextRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ExprFormattedValue(self).to_object(py))
    }
}

#[pymethods]
impl ExprFormattedValue {
    #[getter]
    #[inline]
    fn get_value(&self, py: Python) -> PyResult<PyObject> {
        self.0.value.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_conversion(&self, py: Python) -> PyResult<PyObject> {
        self.0.conversion.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_format_spec(&self, py: Python) -> PyResult<PyObject> {
        self.0.format_spec.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_JoinedStr", extends=Expr, frozen)]
#[derive(Clone, Debug)]
pub struct ExprJoinedStr(pub &'static crate::ExprJoinedStr<TextRange>);

impl From<&'static crate::ExprJoinedStr<TextRange>> for ExprJoinedStr {
    fn from(node: &'static crate::ExprJoinedStr<TextRange>) -> Self {
        ExprJoinedStr(node)
    }
}

impl ToPyObject for ExprJoinedStr {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Expr)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ExprJoinedStr<TextRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ExprJoinedStr(self).to_object(py))
    }
}

#[pymethods]
impl ExprJoinedStr {
    #[getter]
    #[inline]
    fn get_values(&self, py: Python) -> PyResult<PyObject> {
        self.0.values.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Constant", extends=Expr, frozen)]
#[derive(Clone, Debug)]
pub struct ExprConstant(pub &'static crate::ExprConstant<TextRange>);

impl From<&'static crate::ExprConstant<TextRange>> for ExprConstant {
    fn from(node: &'static crate::ExprConstant<TextRange>) -> Self {
        ExprConstant(node)
    }
}

impl ToPyObject for ExprConstant {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Expr)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ExprConstant<TextRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ExprConstant(self).to_object(py))
    }
}

#[pymethods]
impl ExprConstant {
    #[getter]
    #[inline]
    fn get_value(&self, py: Python) -> PyResult<PyObject> {
        self.0.value.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_kind(&self, py: Python) -> PyResult<PyObject> {
        self.0.kind.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Attribute", extends=Expr, frozen)]
#[derive(Clone, Debug)]
pub struct ExprAttribute(pub &'static crate::ExprAttribute<TextRange>);

impl From<&'static crate::ExprAttribute<TextRange>> for ExprAttribute {
    fn from(node: &'static crate::ExprAttribute<TextRange>) -> Self {
        ExprAttribute(node)
    }
}

impl ToPyObject for ExprAttribute {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Expr)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ExprAttribute<TextRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ExprAttribute(self).to_object(py))
    }
}

#[pymethods]
impl ExprAttribute {
    #[getter]
    #[inline]
    fn get_value(&self, py: Python) -> PyResult<PyObject> {
        self.0.value.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_attr(&self, py: Python) -> PyResult<PyObject> {
        self.0.attr.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_ctx(&self, py: Python) -> PyResult<PyObject> {
        self.0.ctx.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Subscript", extends=Expr, frozen)]
#[derive(Clone, Debug)]
pub struct ExprSubscript(pub &'static crate::ExprSubscript<TextRange>);

impl From<&'static crate::ExprSubscript<TextRange>> for ExprSubscript {
    fn from(node: &'static crate::ExprSubscript<TextRange>) -> Self {
        ExprSubscript(node)
    }
}

impl ToPyObject for ExprSubscript {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Expr)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ExprSubscript<TextRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ExprSubscript(self).to_object(py))
    }
}

#[pymethods]
impl ExprSubscript {
    #[getter]
    #[inline]
    fn get_value(&self, py: Python) -> PyResult<PyObject> {
        self.0.value.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_slice(&self, py: Python) -> PyResult<PyObject> {
        self.0.slice.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_ctx(&self, py: Python) -> PyResult<PyObject> {
        self.0.ctx.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Starred", extends=Expr, frozen)]
#[derive(Clone, Debug)]
pub struct ExprStarred(pub &'static crate::ExprStarred<TextRange>);

impl From<&'static crate::ExprStarred<TextRange>> for ExprStarred {
    fn from(node: &'static crate::ExprStarred<TextRange>) -> Self {
        ExprStarred(node)
    }
}

impl ToPyObject for ExprStarred {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Expr)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ExprStarred<TextRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ExprStarred(self).to_object(py))
    }
}

#[pymethods]
impl ExprStarred {
    #[getter]
    #[inline]
    fn get_value(&self, py: Python) -> PyResult<PyObject> {
        self.0.value.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_ctx(&self, py: Python) -> PyResult<PyObject> {
        self.0.ctx.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Name", extends=Expr, frozen)]
#[derive(Clone, Debug)]
pub struct ExprName(pub &'static crate::ExprName<TextRange>);

impl From<&'static crate::ExprName<TextRange>> for ExprName {
    fn from(node: &'static crate::ExprName<TextRange>) -> Self {
        ExprName(node)
    }
}

impl ToPyObject for ExprName {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Expr)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ExprName<TextRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ExprName(self).to_object(py))
    }
}

#[pymethods]
impl ExprName {
    #[getter]
    #[inline]
    fn get_id(&self, py: Python) -> PyResult<PyObject> {
        self.0.id.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_ctx(&self, py: Python) -> PyResult<PyObject> {
        self.0.ctx.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_List", extends=Expr, frozen)]
#[derive(Clone, Debug)]
pub struct ExprList(pub &'static crate::ExprList<TextRange>);

impl From<&'static crate::ExprList<TextRange>> for ExprList {
    fn from(node: &'static crate::ExprList<TextRange>) -> Self {
        ExprList(node)
    }
}

impl ToPyObject for ExprList {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Expr)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ExprList<TextRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ExprList(self).to_object(py))
    }
}

#[pymethods]
impl ExprList {
    #[getter]
    #[inline]
    fn get_elts(&self, py: Python) -> PyResult<PyObject> {
        self.0.elts.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_ctx(&self, py: Python) -> PyResult<PyObject> {
        self.0.ctx.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Tuple", extends=Expr, frozen)]
#[derive(Clone, Debug)]
pub struct ExprTuple(pub &'static crate::ExprTuple<TextRange>);

impl From<&'static crate::ExprTuple<TextRange>> for ExprTuple {
    fn from(node: &'static crate::ExprTuple<TextRange>) -> Self {
        ExprTuple(node)
    }
}

impl ToPyObject for ExprTuple {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Expr)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ExprTuple<TextRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ExprTuple(self).to_object(py))
    }
}

#[pymethods]
impl ExprTuple {
    #[getter]
    #[inline]
    fn get_elts(&self, py: Python) -> PyResult<PyObject> {
        self.0.elts.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_ctx(&self, py: Python) -> PyResult<PyObject> {
        self.0.ctx.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Slice", extends=Expr, frozen)]
#[derive(Clone, Debug)]
pub struct ExprSlice(pub &'static crate::ExprSlice<TextRange>);

impl From<&'static crate::ExprSlice<TextRange>> for ExprSlice {
    fn from(node: &'static crate::ExprSlice<TextRange>) -> Self {
        ExprSlice(node)
    }
}

impl ToPyObject for ExprSlice {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Expr)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ExprSlice<TextRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ExprSlice(self).to_object(py))
    }
}

#[pymethods]
impl ExprSlice {
    #[getter]
    #[inline]
    fn get_lower(&self, py: Python) -> PyResult<PyObject> {
        self.0.lower.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_upper(&self, py: Python) -> PyResult<PyObject> {
        self.0.upper.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_step(&self, py: Python) -> PyResult<PyObject> {
        self.0.step.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_expr_context", extends=super::AST, frozen, subclass)]
#[derive(Clone, Debug)]
pub struct ExprContext;

impl From<&'static crate::ExprContext> for ExprContext {
    fn from(_node: &'static crate::ExprContext) -> Self {
        ExprContext
    }
}

#[pymethods]
impl ExprContext {
    #[new]
    fn new() -> PyClassInitializer<Self> {
        PyClassInitializer::from(AST).add_subclass(Self)
    }
}
impl ToPyObject for ExprContext {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = Self::new();
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Load", extends=ExprContext)]
pub struct ExprContextLoad;

impl ToPyObject for ExprContextLoad {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(ExprContext)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Store", extends=ExprContext)]
pub struct ExprContextStore;

impl ToPyObject for ExprContextStore {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(ExprContext)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Del", extends=ExprContext)]
pub struct ExprContextDel;

impl ToPyObject for ExprContextDel {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(ExprContext)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_boolop", extends=super::AST, frozen, subclass)]
#[derive(Clone, Debug)]
pub struct Boolop;

impl From<&'static crate::Boolop> for Boolop {
    fn from(_node: &'static crate::Boolop) -> Self {
        Boolop
    }
}

#[pymethods]
impl Boolop {
    #[new]
    fn new() -> PyClassInitializer<Self> {
        PyClassInitializer::from(AST).add_subclass(Self)
    }
}
impl ToPyObject for Boolop {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = Self::new();
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_And", extends=Boolop)]
pub struct BoolopAnd;

impl ToPyObject for BoolopAnd {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Boolop)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Or", extends=Boolop)]
pub struct BoolopOr;

impl ToPyObject for BoolopOr {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Boolop)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_operator", extends=super::AST, frozen, subclass)]
#[derive(Clone, Debug)]
pub struct Operator;

impl From<&'static crate::Operator> for Operator {
    fn from(_node: &'static crate::Operator) -> Self {
        Operator
    }
}

#[pymethods]
impl Operator {
    #[new]
    fn new() -> PyClassInitializer<Self> {
        PyClassInitializer::from(AST).add_subclass(Self)
    }
}
impl ToPyObject for Operator {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = Self::new();
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Add", extends=Operator)]
pub struct OperatorAdd;

impl ToPyObject for OperatorAdd {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Operator)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Sub", extends=Operator)]
pub struct OperatorSub;

impl ToPyObject for OperatorSub {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Operator)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Mult", extends=Operator)]
pub struct OperatorMult;

impl ToPyObject for OperatorMult {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Operator)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_MatMult", extends=Operator)]
pub struct OperatorMatMult;

impl ToPyObject for OperatorMatMult {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Operator)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Div", extends=Operator)]
pub struct OperatorDiv;

impl ToPyObject for OperatorDiv {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Operator)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Mod", extends=Operator)]
pub struct OperatorMod;

impl ToPyObject for OperatorMod {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Operator)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Pow", extends=Operator)]
pub struct OperatorPow;

impl ToPyObject for OperatorPow {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Operator)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_LShift", extends=Operator)]
pub struct OperatorLShift;

impl ToPyObject for OperatorLShift {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Operator)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_RShift", extends=Operator)]
pub struct OperatorRShift;

impl ToPyObject for OperatorRShift {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Operator)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_BitOr", extends=Operator)]
pub struct OperatorBitOr;

impl ToPyObject for OperatorBitOr {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Operator)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_BitXor", extends=Operator)]
pub struct OperatorBitXor;

impl ToPyObject for OperatorBitXor {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Operator)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_BitAnd", extends=Operator)]
pub struct OperatorBitAnd;

impl ToPyObject for OperatorBitAnd {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Operator)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_FloorDiv", extends=Operator)]
pub struct OperatorFloorDiv;

impl ToPyObject for OperatorFloorDiv {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Operator)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_unaryop", extends=super::AST, frozen, subclass)]
#[derive(Clone, Debug)]
pub struct Unaryop;

impl From<&'static crate::Unaryop> for Unaryop {
    fn from(_node: &'static crate::Unaryop) -> Self {
        Unaryop
    }
}

#[pymethods]
impl Unaryop {
    #[new]
    fn new() -> PyClassInitializer<Self> {
        PyClassInitializer::from(AST).add_subclass(Self)
    }
}
impl ToPyObject for Unaryop {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = Self::new();
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Invert", extends=Unaryop)]
pub struct UnaryopInvert;

impl ToPyObject for UnaryopInvert {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Unaryop)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Not", extends=Unaryop)]
pub struct UnaryopNot;

impl ToPyObject for UnaryopNot {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Unaryop)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_UAdd", extends=Unaryop)]
pub struct UnaryopUAdd;

impl ToPyObject for UnaryopUAdd {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Unaryop)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_USub", extends=Unaryop)]
pub struct UnaryopUSub;

impl ToPyObject for UnaryopUSub {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Unaryop)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_cmpop", extends=super::AST, frozen, subclass)]
#[derive(Clone, Debug)]
pub struct Cmpop;

impl From<&'static crate::Cmpop> for Cmpop {
    fn from(_node: &'static crate::Cmpop) -> Self {
        Cmpop
    }
}

#[pymethods]
impl Cmpop {
    #[new]
    fn new() -> PyClassInitializer<Self> {
        PyClassInitializer::from(AST).add_subclass(Self)
    }
}
impl ToPyObject for Cmpop {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = Self::new();
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Eq", extends=Cmpop)]
pub struct CmpopEq;

impl ToPyObject for CmpopEq {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Cmpop)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_NotEq", extends=Cmpop)]
pub struct CmpopNotEq;

impl ToPyObject for CmpopNotEq {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Cmpop)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Lt", extends=Cmpop)]
pub struct CmpopLt;

impl ToPyObject for CmpopLt {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Cmpop)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_LtE", extends=Cmpop)]
pub struct CmpopLtE;

impl ToPyObject for CmpopLtE {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Cmpop)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Gt", extends=Cmpop)]
pub struct CmpopGt;

impl ToPyObject for CmpopGt {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Cmpop)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_GtE", extends=Cmpop)]
pub struct CmpopGtE;

impl ToPyObject for CmpopGtE {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Cmpop)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Is", extends=Cmpop)]
pub struct CmpopIs;

impl ToPyObject for CmpopIs {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Cmpop)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_IsNot", extends=Cmpop)]
pub struct CmpopIsNot;

impl ToPyObject for CmpopIsNot {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Cmpop)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_In", extends=Cmpop)]
pub struct CmpopIn;

impl ToPyObject for CmpopIn {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Cmpop)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_NotIn", extends=Cmpop)]
pub struct CmpopNotIn;

impl ToPyObject for CmpopNotIn {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Cmpop)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_comprehension", extends=super::AST, frozen)]
#[derive(Clone, Debug)]
pub struct Comprehension(pub &'static crate::Comprehension<TextRange>);

impl From<&'static crate::Comprehension<TextRange>> for Comprehension {
    fn from(node: &'static crate::Comprehension<TextRange>) -> Self {
        Comprehension(node)
    }
}

impl ToPyObject for Comprehension {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST).add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::Comprehension<TextRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(Comprehension(self).to_object(py))
    }
}

#[pymethods]
impl Comprehension {
    #[getter]
    #[inline]
    fn get_target(&self, py: Python) -> PyResult<PyObject> {
        self.0.target.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_iter(&self, py: Python) -> PyResult<PyObject> {
        self.0.iter.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_ifs(&self, py: Python) -> PyResult<PyObject> {
        self.0.ifs.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_is_async(&self, py: Python) -> PyResult<PyObject> {
        self.0.is_async.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_excepthandler", extends=super::AST, frozen, subclass)]
#[derive(Clone, Debug)]
pub struct Excepthandler;

impl From<&'static crate::Excepthandler<TextRange>> for Excepthandler {
    fn from(_node: &'static crate::Excepthandler<TextRange>) -> Self {
        Excepthandler
    }
}

#[pymethods]
impl Excepthandler {
    #[new]
    fn new() -> PyClassInitializer<Self> {
        PyClassInitializer::from(AST).add_subclass(Self)
    }
}
impl ToPyObject for Excepthandler {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = Self::new();
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::Excepthandler<TextRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        match &self {
            Self::ExceptHandler(cons) => cons.to_pyo3_wrapper(py),
        }
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_ExceptHandler", extends=Excepthandler, frozen)]
#[derive(Clone, Debug)]
pub struct ExcepthandlerExceptHandler(pub &'static crate::ExcepthandlerExceptHandler<TextRange>);

impl From<&'static crate::ExcepthandlerExceptHandler<TextRange>> for ExcepthandlerExceptHandler {
    fn from(node: &'static crate::ExcepthandlerExceptHandler<TextRange>) -> Self {
        ExcepthandlerExceptHandler(node)
    }
}

impl ToPyObject for ExcepthandlerExceptHandler {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Excepthandler)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ExcepthandlerExceptHandler<TextRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ExcepthandlerExceptHandler(self).to_object(py))
    }
}

#[pymethods]
impl ExcepthandlerExceptHandler {
    #[getter]
    #[inline]
    fn get_type(&self, py: Python) -> PyResult<PyObject> {
        self.0.type_.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_name(&self, py: Python) -> PyResult<PyObject> {
        self.0.name.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_body(&self, py: Python) -> PyResult<PyObject> {
        self.0.body.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_arguments", extends=super::AST, frozen)]
#[derive(Clone, Debug)]
pub struct Arguments(pub &'static crate::Arguments<TextRange>);

impl From<&'static crate::Arguments<TextRange>> for Arguments {
    fn from(node: &'static crate::Arguments<TextRange>) -> Self {
        Arguments(node)
    }
}

impl ToPyObject for Arguments {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST).add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::Arguments<TextRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(Arguments(self).to_object(py))
    }
}

#[pymethods]
impl Arguments {
    #[getter]
    #[inline]
    fn get_posonlyargs(&self, py: Python) -> PyResult<PyObject> {
        self.0.posonlyargs.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_args(&self, py: Python) -> PyResult<PyObject> {
        self.0.args.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_vararg(&self, py: Python) -> PyResult<PyObject> {
        self.0.vararg.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_kwonlyargs(&self, py: Python) -> PyResult<PyObject> {
        self.0.kwonlyargs.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_kw_defaults(&self, py: Python) -> PyResult<PyObject> {
        self.0.kw_defaults.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_kwarg(&self, py: Python) -> PyResult<PyObject> {
        self.0.kwarg.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_defaults(&self, py: Python) -> PyResult<PyObject> {
        self.0.defaults.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_arg", extends=super::AST, frozen)]
#[derive(Clone, Debug)]
pub struct Arg(pub &'static crate::Arg<TextRange>);

impl From<&'static crate::Arg<TextRange>> for Arg {
    fn from(node: &'static crate::Arg<TextRange>) -> Self {
        Arg(node)
    }
}

impl ToPyObject for Arg {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST).add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::Arg<TextRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(Arg(self).to_object(py))
    }
}

#[pymethods]
impl Arg {
    #[getter]
    #[inline]
    fn get_arg(&self, py: Python) -> PyResult<PyObject> {
        self.0.arg.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_annotation(&self, py: Python) -> PyResult<PyObject> {
        self.0.annotation.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_type_comment(&self, py: Python) -> PyResult<PyObject> {
        self.0.type_comment.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_keyword", extends=super::AST, frozen)]
#[derive(Clone, Debug)]
pub struct Keyword(pub &'static crate::Keyword<TextRange>);

impl From<&'static crate::Keyword<TextRange>> for Keyword {
    fn from(node: &'static crate::Keyword<TextRange>) -> Self {
        Keyword(node)
    }
}

impl ToPyObject for Keyword {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST).add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::Keyword<TextRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(Keyword(self).to_object(py))
    }
}

#[pymethods]
impl Keyword {
    #[getter]
    #[inline]
    fn get_arg(&self, py: Python) -> PyResult<PyObject> {
        self.0.arg.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_value(&self, py: Python) -> PyResult<PyObject> {
        self.0.value.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_alias", extends=super::AST, frozen)]
#[derive(Clone, Debug)]
pub struct Alias(pub &'static crate::Alias<TextRange>);

impl From<&'static crate::Alias<TextRange>> for Alias {
    fn from(node: &'static crate::Alias<TextRange>) -> Self {
        Alias(node)
    }
}

impl ToPyObject for Alias {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST).add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::Alias<TextRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(Alias(self).to_object(py))
    }
}

#[pymethods]
impl Alias {
    #[getter]
    #[inline]
    fn get_name(&self, py: Python) -> PyResult<PyObject> {
        self.0.name.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_asname(&self, py: Python) -> PyResult<PyObject> {
        self.0.asname.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_withitem", extends=super::AST, frozen)]
#[derive(Clone, Debug)]
pub struct Withitem(pub &'static crate::Withitem<TextRange>);

impl From<&'static crate::Withitem<TextRange>> for Withitem {
    fn from(node: &'static crate::Withitem<TextRange>) -> Self {
        Withitem(node)
    }
}

impl ToPyObject for Withitem {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST).add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::Withitem<TextRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(Withitem(self).to_object(py))
    }
}

#[pymethods]
impl Withitem {
    #[getter]
    #[inline]
    fn get_context_expr(&self, py: Python) -> PyResult<PyObject> {
        self.0.context_expr.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_optional_vars(&self, py: Python) -> PyResult<PyObject> {
        self.0.optional_vars.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_match_case", extends=super::AST, frozen)]
#[derive(Clone, Debug)]
pub struct MatchCase(pub &'static crate::MatchCase<TextRange>);

impl From<&'static crate::MatchCase<TextRange>> for MatchCase {
    fn from(node: &'static crate::MatchCase<TextRange>) -> Self {
        MatchCase(node)
    }
}

impl ToPyObject for MatchCase {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST).add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::MatchCase<TextRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(MatchCase(self).to_object(py))
    }
}

#[pymethods]
impl MatchCase {
    #[getter]
    #[inline]
    fn get_pattern(&self, py: Python) -> PyResult<PyObject> {
        self.0.pattern.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_guard(&self, py: Python) -> PyResult<PyObject> {
        self.0.guard.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_body(&self, py: Python) -> PyResult<PyObject> {
        self.0.body.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_pattern", extends=super::AST, frozen, subclass)]
#[derive(Clone, Debug)]
pub struct Pattern;

impl From<&'static crate::Pattern<TextRange>> for Pattern {
    fn from(_node: &'static crate::Pattern<TextRange>) -> Self {
        Pattern
    }
}

#[pymethods]
impl Pattern {
    #[new]
    fn new() -> PyClassInitializer<Self> {
        PyClassInitializer::from(AST).add_subclass(Self)
    }
}
impl ToPyObject for Pattern {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = Self::new();
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::Pattern<TextRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        match &self {
            Self::MatchValue(cons) => cons.to_pyo3_wrapper(py),
            Self::MatchSingleton(cons) => cons.to_pyo3_wrapper(py),
            Self::MatchSequence(cons) => cons.to_pyo3_wrapper(py),
            Self::MatchMapping(cons) => cons.to_pyo3_wrapper(py),
            Self::MatchClass(cons) => cons.to_pyo3_wrapper(py),
            Self::MatchStar(cons) => cons.to_pyo3_wrapper(py),
            Self::MatchAs(cons) => cons.to_pyo3_wrapper(py),
            Self::MatchOr(cons) => cons.to_pyo3_wrapper(py),
        }
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_MatchValue", extends=Pattern, frozen)]
#[derive(Clone, Debug)]
pub struct PatternMatchValue(pub &'static crate::PatternMatchValue<TextRange>);

impl From<&'static crate::PatternMatchValue<TextRange>> for PatternMatchValue {
    fn from(node: &'static crate::PatternMatchValue<TextRange>) -> Self {
        PatternMatchValue(node)
    }
}

impl ToPyObject for PatternMatchValue {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Pattern)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::PatternMatchValue<TextRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(PatternMatchValue(self).to_object(py))
    }
}

#[pymethods]
impl PatternMatchValue {
    #[getter]
    #[inline]
    fn get_value(&self, py: Python) -> PyResult<PyObject> {
        self.0.value.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_MatchSingleton", extends=Pattern, frozen)]
#[derive(Clone, Debug)]
pub struct PatternMatchSingleton(pub &'static crate::PatternMatchSingleton<TextRange>);

impl From<&'static crate::PatternMatchSingleton<TextRange>> for PatternMatchSingleton {
    fn from(node: &'static crate::PatternMatchSingleton<TextRange>) -> Self {
        PatternMatchSingleton(node)
    }
}

impl ToPyObject for PatternMatchSingleton {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Pattern)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::PatternMatchSingleton<TextRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(PatternMatchSingleton(self).to_object(py))
    }
}

#[pymethods]
impl PatternMatchSingleton {
    #[getter]
    #[inline]
    fn get_value(&self, py: Python) -> PyResult<PyObject> {
        self.0.value.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_MatchSequence", extends=Pattern, frozen)]
#[derive(Clone, Debug)]
pub struct PatternMatchSequence(pub &'static crate::PatternMatchSequence<TextRange>);

impl From<&'static crate::PatternMatchSequence<TextRange>> for PatternMatchSequence {
    fn from(node: &'static crate::PatternMatchSequence<TextRange>) -> Self {
        PatternMatchSequence(node)
    }
}

impl ToPyObject for PatternMatchSequence {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Pattern)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::PatternMatchSequence<TextRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(PatternMatchSequence(self).to_object(py))
    }
}

#[pymethods]
impl PatternMatchSequence {
    #[getter]
    #[inline]
    fn get_patterns(&self, py: Python) -> PyResult<PyObject> {
        self.0.patterns.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_MatchMapping", extends=Pattern, frozen)]
#[derive(Clone, Debug)]
pub struct PatternMatchMapping(pub &'static crate::PatternMatchMapping<TextRange>);

impl From<&'static crate::PatternMatchMapping<TextRange>> for PatternMatchMapping {
    fn from(node: &'static crate::PatternMatchMapping<TextRange>) -> Self {
        PatternMatchMapping(node)
    }
}

impl ToPyObject for PatternMatchMapping {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Pattern)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::PatternMatchMapping<TextRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(PatternMatchMapping(self).to_object(py))
    }
}

#[pymethods]
impl PatternMatchMapping {
    #[getter]
    #[inline]
    fn get_keys(&self, py: Python) -> PyResult<PyObject> {
        self.0.keys.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_patterns(&self, py: Python) -> PyResult<PyObject> {
        self.0.patterns.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_rest(&self, py: Python) -> PyResult<PyObject> {
        self.0.rest.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_MatchClass", extends=Pattern, frozen)]
#[derive(Clone, Debug)]
pub struct PatternMatchClass(pub &'static crate::PatternMatchClass<TextRange>);

impl From<&'static crate::PatternMatchClass<TextRange>> for PatternMatchClass {
    fn from(node: &'static crate::PatternMatchClass<TextRange>) -> Self {
        PatternMatchClass(node)
    }
}

impl ToPyObject for PatternMatchClass {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Pattern)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::PatternMatchClass<TextRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(PatternMatchClass(self).to_object(py))
    }
}

#[pymethods]
impl PatternMatchClass {
    #[getter]
    #[inline]
    fn get_cls(&self, py: Python) -> PyResult<PyObject> {
        self.0.cls.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_patterns(&self, py: Python) -> PyResult<PyObject> {
        self.0.patterns.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_kwd_attrs(&self, py: Python) -> PyResult<PyObject> {
        self.0.kwd_attrs.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_kwd_patterns(&self, py: Python) -> PyResult<PyObject> {
        self.0.kwd_patterns.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_MatchStar", extends=Pattern, frozen)]
#[derive(Clone, Debug)]
pub struct PatternMatchStar(pub &'static crate::PatternMatchStar<TextRange>);

impl From<&'static crate::PatternMatchStar<TextRange>> for PatternMatchStar {
    fn from(node: &'static crate::PatternMatchStar<TextRange>) -> Self {
        PatternMatchStar(node)
    }
}

impl ToPyObject for PatternMatchStar {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Pattern)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::PatternMatchStar<TextRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(PatternMatchStar(self).to_object(py))
    }
}

#[pymethods]
impl PatternMatchStar {
    #[getter]
    #[inline]
    fn get_name(&self, py: Python) -> PyResult<PyObject> {
        self.0.name.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_MatchAs", extends=Pattern, frozen)]
#[derive(Clone, Debug)]
pub struct PatternMatchAs(pub &'static crate::PatternMatchAs<TextRange>);

impl From<&'static crate::PatternMatchAs<TextRange>> for PatternMatchAs {
    fn from(node: &'static crate::PatternMatchAs<TextRange>) -> Self {
        PatternMatchAs(node)
    }
}

impl ToPyObject for PatternMatchAs {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Pattern)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::PatternMatchAs<TextRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(PatternMatchAs(self).to_object(py))
    }
}

#[pymethods]
impl PatternMatchAs {
    #[getter]
    #[inline]
    fn get_pattern(&self, py: Python) -> PyResult<PyObject> {
        self.0.pattern.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_name(&self, py: Python) -> PyResult<PyObject> {
        self.0.name.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_MatchOr", extends=Pattern, frozen)]
#[derive(Clone, Debug)]
pub struct PatternMatchOr(pub &'static crate::PatternMatchOr<TextRange>);

impl From<&'static crate::PatternMatchOr<TextRange>> for PatternMatchOr {
    fn from(node: &'static crate::PatternMatchOr<TextRange>) -> Self {
        PatternMatchOr(node)
    }
}

impl ToPyObject for PatternMatchOr {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Pattern)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::PatternMatchOr<TextRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(PatternMatchOr(self).to_object(py))
    }
}

#[pymethods]
impl PatternMatchOr {
    #[getter]
    #[inline]
    fn get_patterns(&self, py: Python) -> PyResult<PyObject> {
        self.0.patterns.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_type_ignore", extends=super::AST, frozen, subclass)]
#[derive(Clone, Debug)]
pub struct TypeIgnore;

impl From<&'static crate::TypeIgnore<TextRange>> for TypeIgnore {
    fn from(_node: &'static crate::TypeIgnore<TextRange>) -> Self {
        TypeIgnore
    }
}

#[pymethods]
impl TypeIgnore {
    #[new]
    fn new() -> PyClassInitializer<Self> {
        PyClassInitializer::from(AST).add_subclass(Self)
    }
}
impl ToPyObject for TypeIgnore {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = Self::new();
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::TypeIgnore<TextRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        match &self {
            Self::TypeIgnore(cons) => cons.to_pyo3_wrapper(py),
        }
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_TypeIgnore", extends=TypeIgnore, frozen)]
#[derive(Clone, Debug)]
pub struct TypeIgnoreTypeIgnore(pub &'static crate::TypeIgnoreTypeIgnore<TextRange>);

impl From<&'static crate::TypeIgnoreTypeIgnore<TextRange>> for TypeIgnoreTypeIgnore {
    fn from(node: &'static crate::TypeIgnoreTypeIgnore<TextRange>) -> Self {
        TypeIgnoreTypeIgnore(node)
    }
}

impl ToPyObject for TypeIgnoreTypeIgnore {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(TypeIgnore)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::TypeIgnoreTypeIgnore<TextRange> {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(TypeIgnoreTypeIgnore(self).to_object(py))
    }
}

#[pymethods]
impl TypeIgnoreTypeIgnore {
    #[getter]
    #[inline]
    fn get_lineno(&self, py: Python) -> PyResult<PyObject> {
        self.0.lineno.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_tag(&self, py: Python) -> PyResult<PyObject> {
        self.0.tag.to_pyo3_wrapper(py)
    }
}

pub fn add_to_module(py: Python, m: &PyModule) -> PyResult<()> {
    super::init_module(py, m)?;
    super::init_type::<Mod, crate::generic::Mod>(py, m)?;
    super::init_type::<ModModule, crate::generic::ModModule>(py, m)?;
    super::init_type::<ModInteractive, crate::generic::ModInteractive>(py, m)?;
    super::init_type::<ModExpression, crate::generic::ModExpression>(py, m)?;
    super::init_type::<ModFunctionType, crate::generic::ModFunctionType>(py, m)?;
    super::init_type::<Stmt, crate::generic::Stmt>(py, m)?;
    super::init_type::<StmtFunctionDef, crate::generic::StmtFunctionDef>(py, m)?;
    super::init_type::<StmtAsyncFunctionDef, crate::generic::StmtAsyncFunctionDef>(py, m)?;
    super::init_type::<StmtClassDef, crate::generic::StmtClassDef>(py, m)?;
    super::init_type::<StmtReturn, crate::generic::StmtReturn>(py, m)?;
    super::init_type::<StmtDelete, crate::generic::StmtDelete>(py, m)?;
    super::init_type::<StmtAssign, crate::generic::StmtAssign>(py, m)?;
    super::init_type::<StmtAugAssign, crate::generic::StmtAugAssign>(py, m)?;
    super::init_type::<StmtAnnAssign, crate::generic::StmtAnnAssign>(py, m)?;
    super::init_type::<StmtFor, crate::generic::StmtFor>(py, m)?;
    super::init_type::<StmtAsyncFor, crate::generic::StmtAsyncFor>(py, m)?;
    super::init_type::<StmtWhile, crate::generic::StmtWhile>(py, m)?;
    super::init_type::<StmtIf, crate::generic::StmtIf>(py, m)?;
    super::init_type::<StmtWith, crate::generic::StmtWith>(py, m)?;
    super::init_type::<StmtAsyncWith, crate::generic::StmtAsyncWith>(py, m)?;
    super::init_type::<StmtMatch, crate::generic::StmtMatch>(py, m)?;
    super::init_type::<StmtRaise, crate::generic::StmtRaise>(py, m)?;
    super::init_type::<StmtTry, crate::generic::StmtTry>(py, m)?;
    super::init_type::<StmtTryStar, crate::generic::StmtTryStar>(py, m)?;
    super::init_type::<StmtAssert, crate::generic::StmtAssert>(py, m)?;
    super::init_type::<StmtImport, crate::generic::StmtImport>(py, m)?;
    super::init_type::<StmtImportFrom, crate::generic::StmtImportFrom>(py, m)?;
    super::init_type::<StmtGlobal, crate::generic::StmtGlobal>(py, m)?;
    super::init_type::<StmtNonlocal, crate::generic::StmtNonlocal>(py, m)?;
    super::init_type::<StmtExpr, crate::generic::StmtExpr>(py, m)?;
    super::init_type::<StmtPass, crate::generic::StmtPass>(py, m)?;
    super::init_type::<StmtBreak, crate::generic::StmtBreak>(py, m)?;
    super::init_type::<StmtContinue, crate::generic::StmtContinue>(py, m)?;
    super::init_type::<Expr, crate::generic::Expr>(py, m)?;
    super::init_type::<ExprBoolOp, crate::generic::ExprBoolOp>(py, m)?;
    super::init_type::<ExprNamedExpr, crate::generic::ExprNamedExpr>(py, m)?;
    super::init_type::<ExprBinOp, crate::generic::ExprBinOp>(py, m)?;
    super::init_type::<ExprUnaryOp, crate::generic::ExprUnaryOp>(py, m)?;
    super::init_type::<ExprLambda, crate::generic::ExprLambda>(py, m)?;
    super::init_type::<ExprIfExp, crate::generic::ExprIfExp>(py, m)?;
    super::init_type::<ExprDict, crate::generic::ExprDict>(py, m)?;
    super::init_type::<ExprSet, crate::generic::ExprSet>(py, m)?;
    super::init_type::<ExprListComp, crate::generic::ExprListComp>(py, m)?;
    super::init_type::<ExprSetComp, crate::generic::ExprSetComp>(py, m)?;
    super::init_type::<ExprDictComp, crate::generic::ExprDictComp>(py, m)?;
    super::init_type::<ExprGeneratorExp, crate::generic::ExprGeneratorExp>(py, m)?;
    super::init_type::<ExprAwait, crate::generic::ExprAwait>(py, m)?;
    super::init_type::<ExprYield, crate::generic::ExprYield>(py, m)?;
    super::init_type::<ExprYieldFrom, crate::generic::ExprYieldFrom>(py, m)?;
    super::init_type::<ExprCompare, crate::generic::ExprCompare>(py, m)?;
    super::init_type::<ExprCall, crate::generic::ExprCall>(py, m)?;
    super::init_type::<ExprFormattedValue, crate::generic::ExprFormattedValue>(py, m)?;
    super::init_type::<ExprJoinedStr, crate::generic::ExprJoinedStr>(py, m)?;
    super::init_type::<ExprConstant, crate::generic::ExprConstant>(py, m)?;
    super::init_type::<ExprAttribute, crate::generic::ExprAttribute>(py, m)?;
    super::init_type::<ExprSubscript, crate::generic::ExprSubscript>(py, m)?;
    super::init_type::<ExprStarred, crate::generic::ExprStarred>(py, m)?;
    super::init_type::<ExprName, crate::generic::ExprName>(py, m)?;
    super::init_type::<ExprList, crate::generic::ExprList>(py, m)?;
    super::init_type::<ExprTuple, crate::generic::ExprTuple>(py, m)?;
    super::init_type::<ExprSlice, crate::generic::ExprSlice>(py, m)?;
    super::init_type::<ExprContext, crate::generic::ExprContext>(py, m)?;
    super::init_type::<ExprContextLoad, crate::generic::ExprContextLoad>(py, m)?;
    super::init_type::<ExprContextStore, crate::generic::ExprContextStore>(py, m)?;
    super::init_type::<ExprContextDel, crate::generic::ExprContextDel>(py, m)?;
    super::init_type::<Boolop, crate::generic::Boolop>(py, m)?;
    super::init_type::<BoolopAnd, crate::generic::BoolopAnd>(py, m)?;
    super::init_type::<BoolopOr, crate::generic::BoolopOr>(py, m)?;
    super::init_type::<Operator, crate::generic::Operator>(py, m)?;
    super::init_type::<OperatorAdd, crate::generic::OperatorAdd>(py, m)?;
    super::init_type::<OperatorSub, crate::generic::OperatorSub>(py, m)?;
    super::init_type::<OperatorMult, crate::generic::OperatorMult>(py, m)?;
    super::init_type::<OperatorMatMult, crate::generic::OperatorMatMult>(py, m)?;
    super::init_type::<OperatorDiv, crate::generic::OperatorDiv>(py, m)?;
    super::init_type::<OperatorMod, crate::generic::OperatorMod>(py, m)?;
    super::init_type::<OperatorPow, crate::generic::OperatorPow>(py, m)?;
    super::init_type::<OperatorLShift, crate::generic::OperatorLShift>(py, m)?;
    super::init_type::<OperatorRShift, crate::generic::OperatorRShift>(py, m)?;
    super::init_type::<OperatorBitOr, crate::generic::OperatorBitOr>(py, m)?;
    super::init_type::<OperatorBitXor, crate::generic::OperatorBitXor>(py, m)?;
    super::init_type::<OperatorBitAnd, crate::generic::OperatorBitAnd>(py, m)?;
    super::init_type::<OperatorFloorDiv, crate::generic::OperatorFloorDiv>(py, m)?;
    super::init_type::<Unaryop, crate::generic::Unaryop>(py, m)?;
    super::init_type::<UnaryopInvert, crate::generic::UnaryopInvert>(py, m)?;
    super::init_type::<UnaryopNot, crate::generic::UnaryopNot>(py, m)?;
    super::init_type::<UnaryopUAdd, crate::generic::UnaryopUAdd>(py, m)?;
    super::init_type::<UnaryopUSub, crate::generic::UnaryopUSub>(py, m)?;
    super::init_type::<Cmpop, crate::generic::Cmpop>(py, m)?;
    super::init_type::<CmpopEq, crate::generic::CmpopEq>(py, m)?;
    super::init_type::<CmpopNotEq, crate::generic::CmpopNotEq>(py, m)?;
    super::init_type::<CmpopLt, crate::generic::CmpopLt>(py, m)?;
    super::init_type::<CmpopLtE, crate::generic::CmpopLtE>(py, m)?;
    super::init_type::<CmpopGt, crate::generic::CmpopGt>(py, m)?;
    super::init_type::<CmpopGtE, crate::generic::CmpopGtE>(py, m)?;
    super::init_type::<CmpopIs, crate::generic::CmpopIs>(py, m)?;
    super::init_type::<CmpopIsNot, crate::generic::CmpopIsNot>(py, m)?;
    super::init_type::<CmpopIn, crate::generic::CmpopIn>(py, m)?;
    super::init_type::<CmpopNotIn, crate::generic::CmpopNotIn>(py, m)?;
    super::init_type::<Comprehension, crate::generic::Comprehension>(py, m)?;
    super::init_type::<Excepthandler, crate::generic::Excepthandler>(py, m)?;
    super::init_type::<ExcepthandlerExceptHandler, crate::generic::ExcepthandlerExceptHandler>(
        py, m,
    )?;
    super::init_type::<Arguments, crate::generic::Arguments>(py, m)?;
    super::init_type::<Arg, crate::generic::Arg>(py, m)?;
    super::init_type::<Keyword, crate::generic::Keyword>(py, m)?;
    super::init_type::<Alias, crate::generic::Alias>(py, m)?;
    super::init_type::<Withitem, crate::generic::Withitem>(py, m)?;
    super::init_type::<MatchCase, crate::generic::MatchCase>(py, m)?;
    super::init_type::<Pattern, crate::generic::Pattern>(py, m)?;
    super::init_type::<PatternMatchValue, crate::generic::PatternMatchValue>(py, m)?;
    super::init_type::<PatternMatchSingleton, crate::generic::PatternMatchSingleton>(py, m)?;
    super::init_type::<PatternMatchSequence, crate::generic::PatternMatchSequence>(py, m)?;
    super::init_type::<PatternMatchMapping, crate::generic::PatternMatchMapping>(py, m)?;
    super::init_type::<PatternMatchClass, crate::generic::PatternMatchClass>(py, m)?;
    super::init_type::<PatternMatchStar, crate::generic::PatternMatchStar>(py, m)?;
    super::init_type::<PatternMatchAs, crate::generic::PatternMatchAs>(py, m)?;
    super::init_type::<PatternMatchOr, crate::generic::PatternMatchOr>(py, m)?;
    super::init_type::<TypeIgnore, crate::generic::TypeIgnore>(py, m)?;
    super::init_type::<TypeIgnoreTypeIgnore, crate::generic::TypeIgnoreTypeIgnore>(py, m)?;
    Ok(())
}
