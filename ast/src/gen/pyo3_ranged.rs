// File automatically generated by ast/asdl_rs.py.

#[pyclass(module="rustpython_ast.ranged", name="_mod", extends=super::AST, frozen, subclass)]
#[derive(Clone, Debug)]
pub struct Mod;

impl From<&'static crate::ranged::Mod> for Mod {
    fn from(_node: &'static crate::ranged::Mod) -> Self {
        Mod
    }
}

#[pymethods]
impl Mod {
    #[new]
    fn new() -> PyClassInitializer<Self> {
        PyClassInitializer::from(AST).add_subclass(Self)
    }
}
impl ToPyObject for Mod {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST).add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl Mod {
    #[inline]
    pub fn py_type_cell() -> &'static OnceCell<Py<PyAny>> {
        static PY_TYPE: OnceCell<Py<PyAny>> = OnceCell::new();
        &PY_TYPE
    }
}

impl ToPyo3Wrapper for crate::ranged::Mod {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        match &self {
            Self::Module(cons) => cons.to_pyo3_wrapper(py),
            Self::Interactive(cons) => cons.to_pyo3_wrapper(py),
            Self::Expression(cons) => cons.to_pyo3_wrapper(py),
            Self::FunctionType(cons) => cons.to_pyo3_wrapper(py),
        }
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Module", extends=Mod, frozen)]
#[derive(Clone, Debug)]
pub struct ModModule(pub &'static crate::ranged::ModModule);

impl From<&'static crate::ranged::ModModule> for ModModule {
    fn from(node: &'static crate::ranged::ModModule) -> Self {
        ModModule(node)
    }
}

impl ToPyObject for ModModule {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Mod)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ranged::ModModule {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ModModule(self).to_object(py))
    }
}

impl ModModule {
    #[inline]
    pub fn py_type_cell() -> &'static OnceCell<Py<PyAny>> {
        static PY_TYPE: OnceCell<Py<PyAny>> = OnceCell::new();
        &PY_TYPE
    }
}

#[pymethods]
impl ModModule {
    #[getter]
    #[inline]
    fn get_body(&self, py: Python) -> PyResult<PyObject> {
        self.0.body.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_type_ignores(&self, py: Python) -> PyResult<PyObject> {
        self.0.type_ignores.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Interactive", extends=Mod, frozen)]
#[derive(Clone, Debug)]
pub struct ModInteractive(pub &'static crate::ranged::ModInteractive);

impl From<&'static crate::ranged::ModInteractive> for ModInteractive {
    fn from(node: &'static crate::ranged::ModInteractive) -> Self {
        ModInteractive(node)
    }
}

impl ToPyObject for ModInteractive {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Mod)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ranged::ModInteractive {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ModInteractive(self).to_object(py))
    }
}

impl ModInteractive {
    #[inline]
    pub fn py_type_cell() -> &'static OnceCell<Py<PyAny>> {
        static PY_TYPE: OnceCell<Py<PyAny>> = OnceCell::new();
        &PY_TYPE
    }
}

#[pymethods]
impl ModInteractive {
    #[getter]
    #[inline]
    fn get_body(&self, py: Python) -> PyResult<PyObject> {
        self.0.body.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Expression", extends=Mod, frozen)]
#[derive(Clone, Debug)]
pub struct ModExpression(pub &'static crate::ranged::ModExpression);

impl From<&'static crate::ranged::ModExpression> for ModExpression {
    fn from(node: &'static crate::ranged::ModExpression) -> Self {
        ModExpression(node)
    }
}

impl ToPyObject for ModExpression {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Mod)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ranged::ModExpression {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ModExpression(self).to_object(py))
    }
}

impl ModExpression {
    #[inline]
    pub fn py_type_cell() -> &'static OnceCell<Py<PyAny>> {
        static PY_TYPE: OnceCell<Py<PyAny>> = OnceCell::new();
        &PY_TYPE
    }
}

#[pymethods]
impl ModExpression {
    #[getter]
    #[inline]
    fn get_body(&self, py: Python) -> PyResult<PyObject> {
        self.0.body.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_FunctionType", extends=Mod, frozen)]
#[derive(Clone, Debug)]
pub struct ModFunctionType(pub &'static crate::ranged::ModFunctionType);

impl From<&'static crate::ranged::ModFunctionType> for ModFunctionType {
    fn from(node: &'static crate::ranged::ModFunctionType) -> Self {
        ModFunctionType(node)
    }
}

impl ToPyObject for ModFunctionType {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Mod)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ranged::ModFunctionType {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ModFunctionType(self).to_object(py))
    }
}

impl ModFunctionType {
    #[inline]
    pub fn py_type_cell() -> &'static OnceCell<Py<PyAny>> {
        static PY_TYPE: OnceCell<Py<PyAny>> = OnceCell::new();
        &PY_TYPE
    }
}

#[pymethods]
impl ModFunctionType {
    #[getter]
    #[inline]
    fn get_argtypes(&self, py: Python) -> PyResult<PyObject> {
        self.0.argtypes.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_returns(&self, py: Python) -> PyResult<PyObject> {
        self.0.returns.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_stmt", extends=super::AST, frozen, subclass)]
#[derive(Clone, Debug)]
pub struct Stmt;

impl From<&'static crate::ranged::Stmt> for Stmt {
    fn from(_node: &'static crate::ranged::Stmt) -> Self {
        Stmt
    }
}

#[pymethods]
impl Stmt {
    #[new]
    fn new() -> PyClassInitializer<Self> {
        PyClassInitializer::from(AST).add_subclass(Self)
    }
}
impl ToPyObject for Stmt {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST).add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl Stmt {
    #[inline]
    pub fn py_type_cell() -> &'static OnceCell<Py<PyAny>> {
        static PY_TYPE: OnceCell<Py<PyAny>> = OnceCell::new();
        &PY_TYPE
    }
}

impl ToPyo3Wrapper for crate::ranged::Stmt {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        match &self {
            Self::FunctionDef(cons) => cons.to_pyo3_wrapper(py),
            Self::AsyncFunctionDef(cons) => cons.to_pyo3_wrapper(py),
            Self::ClassDef(cons) => cons.to_pyo3_wrapper(py),
            Self::Return(cons) => cons.to_pyo3_wrapper(py),
            Self::Delete(cons) => cons.to_pyo3_wrapper(py),
            Self::Assign(cons) => cons.to_pyo3_wrapper(py),
            Self::AugAssign(cons) => cons.to_pyo3_wrapper(py),
            Self::AnnAssign(cons) => cons.to_pyo3_wrapper(py),
            Self::For(cons) => cons.to_pyo3_wrapper(py),
            Self::AsyncFor(cons) => cons.to_pyo3_wrapper(py),
            Self::While(cons) => cons.to_pyo3_wrapper(py),
            Self::If(cons) => cons.to_pyo3_wrapper(py),
            Self::With(cons) => cons.to_pyo3_wrapper(py),
            Self::AsyncWith(cons) => cons.to_pyo3_wrapper(py),
            Self::Match(cons) => cons.to_pyo3_wrapper(py),
            Self::Raise(cons) => cons.to_pyo3_wrapper(py),
            Self::Try(cons) => cons.to_pyo3_wrapper(py),
            Self::TryStar(cons) => cons.to_pyo3_wrapper(py),
            Self::Assert(cons) => cons.to_pyo3_wrapper(py),
            Self::Import(cons) => cons.to_pyo3_wrapper(py),
            Self::ImportFrom(cons) => cons.to_pyo3_wrapper(py),
            Self::Global(cons) => cons.to_pyo3_wrapper(py),
            Self::Nonlocal(cons) => cons.to_pyo3_wrapper(py),
            Self::Expr(cons) => cons.to_pyo3_wrapper(py),
            Self::Pass(cons) => cons.to_pyo3_wrapper(py),
            Self::Break(cons) => cons.to_pyo3_wrapper(py),
            Self::Continue(cons) => cons.to_pyo3_wrapper(py),
        }
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_FunctionDef", extends=Stmt, frozen)]
#[derive(Clone, Debug)]
pub struct StmtFunctionDef(pub &'static crate::ranged::StmtFunctionDef);

impl From<&'static crate::ranged::StmtFunctionDef> for StmtFunctionDef {
    fn from(node: &'static crate::ranged::StmtFunctionDef) -> Self {
        StmtFunctionDef(node)
    }
}

impl ToPyObject for StmtFunctionDef {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Stmt)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ranged::StmtFunctionDef {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(StmtFunctionDef(self).to_object(py))
    }
}

impl StmtFunctionDef {
    #[inline]
    pub fn py_type_cell() -> &'static OnceCell<Py<PyAny>> {
        static PY_TYPE: OnceCell<Py<PyAny>> = OnceCell::new();
        &PY_TYPE
    }
}

#[pymethods]
impl StmtFunctionDef {
    #[getter]
    #[inline]
    fn get_name(&self, py: Python) -> PyResult<PyObject> {
        self.0.name.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_args(&self, py: Python) -> PyResult<PyObject> {
        self.0.args.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_body(&self, py: Python) -> PyResult<PyObject> {
        self.0.body.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_decorator_list(&self, py: Python) -> PyResult<PyObject> {
        self.0.decorator_list.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_returns(&self, py: Python) -> PyResult<PyObject> {
        self.0.returns.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_type_comment(&self, py: Python) -> PyResult<PyObject> {
        self.0.type_comment.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_AsyncFunctionDef", extends=Stmt, frozen)]
#[derive(Clone, Debug)]
pub struct StmtAsyncFunctionDef(pub &'static crate::ranged::StmtAsyncFunctionDef);

impl From<&'static crate::ranged::StmtAsyncFunctionDef> for StmtAsyncFunctionDef {
    fn from(node: &'static crate::ranged::StmtAsyncFunctionDef) -> Self {
        StmtAsyncFunctionDef(node)
    }
}

impl ToPyObject for StmtAsyncFunctionDef {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Stmt)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ranged::StmtAsyncFunctionDef {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(StmtAsyncFunctionDef(self).to_object(py))
    }
}

impl StmtAsyncFunctionDef {
    #[inline]
    pub fn py_type_cell() -> &'static OnceCell<Py<PyAny>> {
        static PY_TYPE: OnceCell<Py<PyAny>> = OnceCell::new();
        &PY_TYPE
    }
}

#[pymethods]
impl StmtAsyncFunctionDef {
    #[getter]
    #[inline]
    fn get_name(&self, py: Python) -> PyResult<PyObject> {
        self.0.name.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_args(&self, py: Python) -> PyResult<PyObject> {
        self.0.args.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_body(&self, py: Python) -> PyResult<PyObject> {
        self.0.body.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_decorator_list(&self, py: Python) -> PyResult<PyObject> {
        self.0.decorator_list.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_returns(&self, py: Python) -> PyResult<PyObject> {
        self.0.returns.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_type_comment(&self, py: Python) -> PyResult<PyObject> {
        self.0.type_comment.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_ClassDef", extends=Stmt, frozen)]
#[derive(Clone, Debug)]
pub struct StmtClassDef(pub &'static crate::ranged::StmtClassDef);

impl From<&'static crate::ranged::StmtClassDef> for StmtClassDef {
    fn from(node: &'static crate::ranged::StmtClassDef) -> Self {
        StmtClassDef(node)
    }
}

impl ToPyObject for StmtClassDef {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Stmt)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ranged::StmtClassDef {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(StmtClassDef(self).to_object(py))
    }
}

impl StmtClassDef {
    #[inline]
    pub fn py_type_cell() -> &'static OnceCell<Py<PyAny>> {
        static PY_TYPE: OnceCell<Py<PyAny>> = OnceCell::new();
        &PY_TYPE
    }
}

#[pymethods]
impl StmtClassDef {
    #[getter]
    #[inline]
    fn get_name(&self, py: Python) -> PyResult<PyObject> {
        self.0.name.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_bases(&self, py: Python) -> PyResult<PyObject> {
        self.0.bases.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_keywords(&self, py: Python) -> PyResult<PyObject> {
        self.0.keywords.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_body(&self, py: Python) -> PyResult<PyObject> {
        self.0.body.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_decorator_list(&self, py: Python) -> PyResult<PyObject> {
        self.0.decorator_list.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Return", extends=Stmt, frozen)]
#[derive(Clone, Debug)]
pub struct StmtReturn(pub &'static crate::ranged::StmtReturn);

impl From<&'static crate::ranged::StmtReturn> for StmtReturn {
    fn from(node: &'static crate::ranged::StmtReturn) -> Self {
        StmtReturn(node)
    }
}

impl ToPyObject for StmtReturn {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Stmt)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ranged::StmtReturn {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(StmtReturn(self).to_object(py))
    }
}

impl StmtReturn {
    #[inline]
    pub fn py_type_cell() -> &'static OnceCell<Py<PyAny>> {
        static PY_TYPE: OnceCell<Py<PyAny>> = OnceCell::new();
        &PY_TYPE
    }
}

#[pymethods]
impl StmtReturn {
    #[getter]
    #[inline]
    fn get_value(&self, py: Python) -> PyResult<PyObject> {
        self.0.value.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Delete", extends=Stmt, frozen)]
#[derive(Clone, Debug)]
pub struct StmtDelete(pub &'static crate::ranged::StmtDelete);

impl From<&'static crate::ranged::StmtDelete> for StmtDelete {
    fn from(node: &'static crate::ranged::StmtDelete) -> Self {
        StmtDelete(node)
    }
}

impl ToPyObject for StmtDelete {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Stmt)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ranged::StmtDelete {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(StmtDelete(self).to_object(py))
    }
}

impl StmtDelete {
    #[inline]
    pub fn py_type_cell() -> &'static OnceCell<Py<PyAny>> {
        static PY_TYPE: OnceCell<Py<PyAny>> = OnceCell::new();
        &PY_TYPE
    }
}

#[pymethods]
impl StmtDelete {
    #[getter]
    #[inline]
    fn get_targets(&self, py: Python) -> PyResult<PyObject> {
        self.0.targets.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Assign", extends=Stmt, frozen)]
#[derive(Clone, Debug)]
pub struct StmtAssign(pub &'static crate::ranged::StmtAssign);

impl From<&'static crate::ranged::StmtAssign> for StmtAssign {
    fn from(node: &'static crate::ranged::StmtAssign) -> Self {
        StmtAssign(node)
    }
}

impl ToPyObject for StmtAssign {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Stmt)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ranged::StmtAssign {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(StmtAssign(self).to_object(py))
    }
}

impl StmtAssign {
    #[inline]
    pub fn py_type_cell() -> &'static OnceCell<Py<PyAny>> {
        static PY_TYPE: OnceCell<Py<PyAny>> = OnceCell::new();
        &PY_TYPE
    }
}

#[pymethods]
impl StmtAssign {
    #[getter]
    #[inline]
    fn get_targets(&self, py: Python) -> PyResult<PyObject> {
        self.0.targets.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_value(&self, py: Python) -> PyResult<PyObject> {
        self.0.value.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_type_comment(&self, py: Python) -> PyResult<PyObject> {
        self.0.type_comment.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_AugAssign", extends=Stmt, frozen)]
#[derive(Clone, Debug)]
pub struct StmtAugAssign(pub &'static crate::ranged::StmtAugAssign);

impl From<&'static crate::ranged::StmtAugAssign> for StmtAugAssign {
    fn from(node: &'static crate::ranged::StmtAugAssign) -> Self {
        StmtAugAssign(node)
    }
}

impl ToPyObject for StmtAugAssign {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Stmt)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ranged::StmtAugAssign {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(StmtAugAssign(self).to_object(py))
    }
}

impl StmtAugAssign {
    #[inline]
    pub fn py_type_cell() -> &'static OnceCell<Py<PyAny>> {
        static PY_TYPE: OnceCell<Py<PyAny>> = OnceCell::new();
        &PY_TYPE
    }
}

#[pymethods]
impl StmtAugAssign {
    #[getter]
    #[inline]
    fn get_target(&self, py: Python) -> PyResult<PyObject> {
        self.0.target.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_op(&self, py: Python) -> PyResult<PyObject> {
        self.0.op.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_value(&self, py: Python) -> PyResult<PyObject> {
        self.0.value.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_AnnAssign", extends=Stmt, frozen)]
#[derive(Clone, Debug)]
pub struct StmtAnnAssign(pub &'static crate::ranged::StmtAnnAssign);

impl From<&'static crate::ranged::StmtAnnAssign> for StmtAnnAssign {
    fn from(node: &'static crate::ranged::StmtAnnAssign) -> Self {
        StmtAnnAssign(node)
    }
}

impl ToPyObject for StmtAnnAssign {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Stmt)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ranged::StmtAnnAssign {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(StmtAnnAssign(self).to_object(py))
    }
}

impl StmtAnnAssign {
    #[inline]
    pub fn py_type_cell() -> &'static OnceCell<Py<PyAny>> {
        static PY_TYPE: OnceCell<Py<PyAny>> = OnceCell::new();
        &PY_TYPE
    }
}

#[pymethods]
impl StmtAnnAssign {
    #[getter]
    #[inline]
    fn get_target(&self, py: Python) -> PyResult<PyObject> {
        self.0.target.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_annotation(&self, py: Python) -> PyResult<PyObject> {
        self.0.annotation.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_value(&self, py: Python) -> PyResult<PyObject> {
        self.0.value.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_simple(&self, py: Python) -> PyResult<PyObject> {
        self.0.simple.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_For", extends=Stmt, frozen)]
#[derive(Clone, Debug)]
pub struct StmtFor(pub &'static crate::ranged::StmtFor);

impl From<&'static crate::ranged::StmtFor> for StmtFor {
    fn from(node: &'static crate::ranged::StmtFor) -> Self {
        StmtFor(node)
    }
}

impl ToPyObject for StmtFor {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Stmt)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ranged::StmtFor {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(StmtFor(self).to_object(py))
    }
}

impl StmtFor {
    #[inline]
    pub fn py_type_cell() -> &'static OnceCell<Py<PyAny>> {
        static PY_TYPE: OnceCell<Py<PyAny>> = OnceCell::new();
        &PY_TYPE
    }
}

#[pymethods]
impl StmtFor {
    #[getter]
    #[inline]
    fn get_target(&self, py: Python) -> PyResult<PyObject> {
        self.0.target.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_iter(&self, py: Python) -> PyResult<PyObject> {
        self.0.iter.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_body(&self, py: Python) -> PyResult<PyObject> {
        self.0.body.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_orelse(&self, py: Python) -> PyResult<PyObject> {
        self.0.orelse.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_type_comment(&self, py: Python) -> PyResult<PyObject> {
        self.0.type_comment.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_AsyncFor", extends=Stmt, frozen)]
#[derive(Clone, Debug)]
pub struct StmtAsyncFor(pub &'static crate::ranged::StmtAsyncFor);

impl From<&'static crate::ranged::StmtAsyncFor> for StmtAsyncFor {
    fn from(node: &'static crate::ranged::StmtAsyncFor) -> Self {
        StmtAsyncFor(node)
    }
}

impl ToPyObject for StmtAsyncFor {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Stmt)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ranged::StmtAsyncFor {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(StmtAsyncFor(self).to_object(py))
    }
}

impl StmtAsyncFor {
    #[inline]
    pub fn py_type_cell() -> &'static OnceCell<Py<PyAny>> {
        static PY_TYPE: OnceCell<Py<PyAny>> = OnceCell::new();
        &PY_TYPE
    }
}

#[pymethods]
impl StmtAsyncFor {
    #[getter]
    #[inline]
    fn get_target(&self, py: Python) -> PyResult<PyObject> {
        self.0.target.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_iter(&self, py: Python) -> PyResult<PyObject> {
        self.0.iter.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_body(&self, py: Python) -> PyResult<PyObject> {
        self.0.body.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_orelse(&self, py: Python) -> PyResult<PyObject> {
        self.0.orelse.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_type_comment(&self, py: Python) -> PyResult<PyObject> {
        self.0.type_comment.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_While", extends=Stmt, frozen)]
#[derive(Clone, Debug)]
pub struct StmtWhile(pub &'static crate::ranged::StmtWhile);

impl From<&'static crate::ranged::StmtWhile> for StmtWhile {
    fn from(node: &'static crate::ranged::StmtWhile) -> Self {
        StmtWhile(node)
    }
}

impl ToPyObject for StmtWhile {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Stmt)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ranged::StmtWhile {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(StmtWhile(self).to_object(py))
    }
}

impl StmtWhile {
    #[inline]
    pub fn py_type_cell() -> &'static OnceCell<Py<PyAny>> {
        static PY_TYPE: OnceCell<Py<PyAny>> = OnceCell::new();
        &PY_TYPE
    }
}

#[pymethods]
impl StmtWhile {
    #[getter]
    #[inline]
    fn get_test(&self, py: Python) -> PyResult<PyObject> {
        self.0.test.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_body(&self, py: Python) -> PyResult<PyObject> {
        self.0.body.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_orelse(&self, py: Python) -> PyResult<PyObject> {
        self.0.orelse.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_If", extends=Stmt, frozen)]
#[derive(Clone, Debug)]
pub struct StmtIf(pub &'static crate::ranged::StmtIf);

impl From<&'static crate::ranged::StmtIf> for StmtIf {
    fn from(node: &'static crate::ranged::StmtIf) -> Self {
        StmtIf(node)
    }
}

impl ToPyObject for StmtIf {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Stmt)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ranged::StmtIf {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(StmtIf(self).to_object(py))
    }
}

impl StmtIf {
    #[inline]
    pub fn py_type_cell() -> &'static OnceCell<Py<PyAny>> {
        static PY_TYPE: OnceCell<Py<PyAny>> = OnceCell::new();
        &PY_TYPE
    }
}

#[pymethods]
impl StmtIf {
    #[getter]
    #[inline]
    fn get_test(&self, py: Python) -> PyResult<PyObject> {
        self.0.test.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_body(&self, py: Python) -> PyResult<PyObject> {
        self.0.body.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_orelse(&self, py: Python) -> PyResult<PyObject> {
        self.0.orelse.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_With", extends=Stmt, frozen)]
#[derive(Clone, Debug)]
pub struct StmtWith(pub &'static crate::ranged::StmtWith);

impl From<&'static crate::ranged::StmtWith> for StmtWith {
    fn from(node: &'static crate::ranged::StmtWith) -> Self {
        StmtWith(node)
    }
}

impl ToPyObject for StmtWith {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Stmt)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ranged::StmtWith {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(StmtWith(self).to_object(py))
    }
}

impl StmtWith {
    #[inline]
    pub fn py_type_cell() -> &'static OnceCell<Py<PyAny>> {
        static PY_TYPE: OnceCell<Py<PyAny>> = OnceCell::new();
        &PY_TYPE
    }
}

#[pymethods]
impl StmtWith {
    #[getter]
    #[inline]
    fn get_items(&self, py: Python) -> PyResult<PyObject> {
        self.0.items.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_body(&self, py: Python) -> PyResult<PyObject> {
        self.0.body.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_type_comment(&self, py: Python) -> PyResult<PyObject> {
        self.0.type_comment.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_AsyncWith", extends=Stmt, frozen)]
#[derive(Clone, Debug)]
pub struct StmtAsyncWith(pub &'static crate::ranged::StmtAsyncWith);

impl From<&'static crate::ranged::StmtAsyncWith> for StmtAsyncWith {
    fn from(node: &'static crate::ranged::StmtAsyncWith) -> Self {
        StmtAsyncWith(node)
    }
}

impl ToPyObject for StmtAsyncWith {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Stmt)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ranged::StmtAsyncWith {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(StmtAsyncWith(self).to_object(py))
    }
}

impl StmtAsyncWith {
    #[inline]
    pub fn py_type_cell() -> &'static OnceCell<Py<PyAny>> {
        static PY_TYPE: OnceCell<Py<PyAny>> = OnceCell::new();
        &PY_TYPE
    }
}

#[pymethods]
impl StmtAsyncWith {
    #[getter]
    #[inline]
    fn get_items(&self, py: Python) -> PyResult<PyObject> {
        self.0.items.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_body(&self, py: Python) -> PyResult<PyObject> {
        self.0.body.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_type_comment(&self, py: Python) -> PyResult<PyObject> {
        self.0.type_comment.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Match", extends=Stmt, frozen)]
#[derive(Clone, Debug)]
pub struct StmtMatch(pub &'static crate::ranged::StmtMatch);

impl From<&'static crate::ranged::StmtMatch> for StmtMatch {
    fn from(node: &'static crate::ranged::StmtMatch) -> Self {
        StmtMatch(node)
    }
}

impl ToPyObject for StmtMatch {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Stmt)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ranged::StmtMatch {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(StmtMatch(self).to_object(py))
    }
}

impl StmtMatch {
    #[inline]
    pub fn py_type_cell() -> &'static OnceCell<Py<PyAny>> {
        static PY_TYPE: OnceCell<Py<PyAny>> = OnceCell::new();
        &PY_TYPE
    }
}

#[pymethods]
impl StmtMatch {
    #[getter]
    #[inline]
    fn get_subject(&self, py: Python) -> PyResult<PyObject> {
        self.0.subject.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_cases(&self, py: Python) -> PyResult<PyObject> {
        self.0.cases.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Raise", extends=Stmt, frozen)]
#[derive(Clone, Debug)]
pub struct StmtRaise(pub &'static crate::ranged::StmtRaise);

impl From<&'static crate::ranged::StmtRaise> for StmtRaise {
    fn from(node: &'static crate::ranged::StmtRaise) -> Self {
        StmtRaise(node)
    }
}

impl ToPyObject for StmtRaise {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Stmt)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ranged::StmtRaise {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(StmtRaise(self).to_object(py))
    }
}

impl StmtRaise {
    #[inline]
    pub fn py_type_cell() -> &'static OnceCell<Py<PyAny>> {
        static PY_TYPE: OnceCell<Py<PyAny>> = OnceCell::new();
        &PY_TYPE
    }
}

#[pymethods]
impl StmtRaise {
    #[getter]
    #[inline]
    fn get_exc(&self, py: Python) -> PyResult<PyObject> {
        self.0.exc.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_cause(&self, py: Python) -> PyResult<PyObject> {
        self.0.cause.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Try", extends=Stmt, frozen)]
#[derive(Clone, Debug)]
pub struct StmtTry(pub &'static crate::ranged::StmtTry);

impl From<&'static crate::ranged::StmtTry> for StmtTry {
    fn from(node: &'static crate::ranged::StmtTry) -> Self {
        StmtTry(node)
    }
}

impl ToPyObject for StmtTry {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Stmt)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ranged::StmtTry {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(StmtTry(self).to_object(py))
    }
}

impl StmtTry {
    #[inline]
    pub fn py_type_cell() -> &'static OnceCell<Py<PyAny>> {
        static PY_TYPE: OnceCell<Py<PyAny>> = OnceCell::new();
        &PY_TYPE
    }
}

#[pymethods]
impl StmtTry {
    #[getter]
    #[inline]
    fn get_body(&self, py: Python) -> PyResult<PyObject> {
        self.0.body.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_handlers(&self, py: Python) -> PyResult<PyObject> {
        self.0.handlers.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_orelse(&self, py: Python) -> PyResult<PyObject> {
        self.0.orelse.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_finalbody(&self, py: Python) -> PyResult<PyObject> {
        self.0.finalbody.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_TryStar", extends=Stmt, frozen)]
#[derive(Clone, Debug)]
pub struct StmtTryStar(pub &'static crate::ranged::StmtTryStar);

impl From<&'static crate::ranged::StmtTryStar> for StmtTryStar {
    fn from(node: &'static crate::ranged::StmtTryStar) -> Self {
        StmtTryStar(node)
    }
}

impl ToPyObject for StmtTryStar {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Stmt)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ranged::StmtTryStar {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(StmtTryStar(self).to_object(py))
    }
}

impl StmtTryStar {
    #[inline]
    pub fn py_type_cell() -> &'static OnceCell<Py<PyAny>> {
        static PY_TYPE: OnceCell<Py<PyAny>> = OnceCell::new();
        &PY_TYPE
    }
}

#[pymethods]
impl StmtTryStar {
    #[getter]
    #[inline]
    fn get_body(&self, py: Python) -> PyResult<PyObject> {
        self.0.body.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_handlers(&self, py: Python) -> PyResult<PyObject> {
        self.0.handlers.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_orelse(&self, py: Python) -> PyResult<PyObject> {
        self.0.orelse.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_finalbody(&self, py: Python) -> PyResult<PyObject> {
        self.0.finalbody.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Assert", extends=Stmt, frozen)]
#[derive(Clone, Debug)]
pub struct StmtAssert(pub &'static crate::ranged::StmtAssert);

impl From<&'static crate::ranged::StmtAssert> for StmtAssert {
    fn from(node: &'static crate::ranged::StmtAssert) -> Self {
        StmtAssert(node)
    }
}

impl ToPyObject for StmtAssert {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Stmt)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ranged::StmtAssert {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(StmtAssert(self).to_object(py))
    }
}

impl StmtAssert {
    #[inline]
    pub fn py_type_cell() -> &'static OnceCell<Py<PyAny>> {
        static PY_TYPE: OnceCell<Py<PyAny>> = OnceCell::new();
        &PY_TYPE
    }
}

#[pymethods]
impl StmtAssert {
    #[getter]
    #[inline]
    fn get_test(&self, py: Python) -> PyResult<PyObject> {
        self.0.test.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_msg(&self, py: Python) -> PyResult<PyObject> {
        self.0.msg.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Import", extends=Stmt, frozen)]
#[derive(Clone, Debug)]
pub struct StmtImport(pub &'static crate::ranged::StmtImport);

impl From<&'static crate::ranged::StmtImport> for StmtImport {
    fn from(node: &'static crate::ranged::StmtImport) -> Self {
        StmtImport(node)
    }
}

impl ToPyObject for StmtImport {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Stmt)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ranged::StmtImport {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(StmtImport(self).to_object(py))
    }
}

impl StmtImport {
    #[inline]
    pub fn py_type_cell() -> &'static OnceCell<Py<PyAny>> {
        static PY_TYPE: OnceCell<Py<PyAny>> = OnceCell::new();
        &PY_TYPE
    }
}

#[pymethods]
impl StmtImport {
    #[getter]
    #[inline]
    fn get_names(&self, py: Python) -> PyResult<PyObject> {
        self.0.names.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_ImportFrom", extends=Stmt, frozen)]
#[derive(Clone, Debug)]
pub struct StmtImportFrom(pub &'static crate::ranged::StmtImportFrom);

impl From<&'static crate::ranged::StmtImportFrom> for StmtImportFrom {
    fn from(node: &'static crate::ranged::StmtImportFrom) -> Self {
        StmtImportFrom(node)
    }
}

impl ToPyObject for StmtImportFrom {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Stmt)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ranged::StmtImportFrom {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(StmtImportFrom(self).to_object(py))
    }
}

impl StmtImportFrom {
    #[inline]
    pub fn py_type_cell() -> &'static OnceCell<Py<PyAny>> {
        static PY_TYPE: OnceCell<Py<PyAny>> = OnceCell::new();
        &PY_TYPE
    }
}

#[pymethods]
impl StmtImportFrom {
    #[getter]
    #[inline]
    fn get_module(&self, py: Python) -> PyResult<PyObject> {
        self.0.module.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_names(&self, py: Python) -> PyResult<PyObject> {
        self.0.names.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_level(&self, py: Python) -> PyResult<PyObject> {
        self.0.level.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Global", extends=Stmt, frozen)]
#[derive(Clone, Debug)]
pub struct StmtGlobal(pub &'static crate::ranged::StmtGlobal);

impl From<&'static crate::ranged::StmtGlobal> for StmtGlobal {
    fn from(node: &'static crate::ranged::StmtGlobal) -> Self {
        StmtGlobal(node)
    }
}

impl ToPyObject for StmtGlobal {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Stmt)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ranged::StmtGlobal {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(StmtGlobal(self).to_object(py))
    }
}

impl StmtGlobal {
    #[inline]
    pub fn py_type_cell() -> &'static OnceCell<Py<PyAny>> {
        static PY_TYPE: OnceCell<Py<PyAny>> = OnceCell::new();
        &PY_TYPE
    }
}

#[pymethods]
impl StmtGlobal {
    #[getter]
    #[inline]
    fn get_names(&self, py: Python) -> PyResult<PyObject> {
        self.0.names.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Nonlocal", extends=Stmt, frozen)]
#[derive(Clone, Debug)]
pub struct StmtNonlocal(pub &'static crate::ranged::StmtNonlocal);

impl From<&'static crate::ranged::StmtNonlocal> for StmtNonlocal {
    fn from(node: &'static crate::ranged::StmtNonlocal) -> Self {
        StmtNonlocal(node)
    }
}

impl ToPyObject for StmtNonlocal {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Stmt)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ranged::StmtNonlocal {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(StmtNonlocal(self).to_object(py))
    }
}

impl StmtNonlocal {
    #[inline]
    pub fn py_type_cell() -> &'static OnceCell<Py<PyAny>> {
        static PY_TYPE: OnceCell<Py<PyAny>> = OnceCell::new();
        &PY_TYPE
    }
}

#[pymethods]
impl StmtNonlocal {
    #[getter]
    #[inline]
    fn get_names(&self, py: Python) -> PyResult<PyObject> {
        self.0.names.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Expr", extends=Stmt, frozen)]
#[derive(Clone, Debug)]
pub struct StmtExpr(pub &'static crate::ranged::StmtExpr);

impl From<&'static crate::ranged::StmtExpr> for StmtExpr {
    fn from(node: &'static crate::ranged::StmtExpr) -> Self {
        StmtExpr(node)
    }
}

impl ToPyObject for StmtExpr {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Stmt)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ranged::StmtExpr {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(StmtExpr(self).to_object(py))
    }
}

impl StmtExpr {
    #[inline]
    pub fn py_type_cell() -> &'static OnceCell<Py<PyAny>> {
        static PY_TYPE: OnceCell<Py<PyAny>> = OnceCell::new();
        &PY_TYPE
    }
}

#[pymethods]
impl StmtExpr {
    #[getter]
    #[inline]
    fn get_value(&self, py: Python) -> PyResult<PyObject> {
        self.0.value.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Pass", extends=Stmt, frozen)]
#[derive(Clone, Debug)]
pub struct StmtPass(pub &'static crate::ranged::StmtPass);

impl From<&'static crate::ranged::StmtPass> for StmtPass {
    fn from(node: &'static crate::ranged::StmtPass) -> Self {
        StmtPass(node)
    }
}

impl ToPyObject for StmtPass {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Stmt)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ranged::StmtPass {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(StmtPass(self).to_object(py))
    }
}

impl StmtPass {
    #[inline]
    pub fn py_type_cell() -> &'static OnceCell<Py<PyAny>> {
        static PY_TYPE: OnceCell<Py<PyAny>> = OnceCell::new();
        &PY_TYPE
    }
}

#[pymethods]
impl StmtPass {}

#[pyclass(module="rustpython_ast.ranged", name="_Break", extends=Stmt, frozen)]
#[derive(Clone, Debug)]
pub struct StmtBreak(pub &'static crate::ranged::StmtBreak);

impl From<&'static crate::ranged::StmtBreak> for StmtBreak {
    fn from(node: &'static crate::ranged::StmtBreak) -> Self {
        StmtBreak(node)
    }
}

impl ToPyObject for StmtBreak {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Stmt)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ranged::StmtBreak {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(StmtBreak(self).to_object(py))
    }
}

impl StmtBreak {
    #[inline]
    pub fn py_type_cell() -> &'static OnceCell<Py<PyAny>> {
        static PY_TYPE: OnceCell<Py<PyAny>> = OnceCell::new();
        &PY_TYPE
    }
}

#[pymethods]
impl StmtBreak {}

#[pyclass(module="rustpython_ast.ranged", name="_Continue", extends=Stmt, frozen)]
#[derive(Clone, Debug)]
pub struct StmtContinue(pub &'static crate::ranged::StmtContinue);

impl From<&'static crate::ranged::StmtContinue> for StmtContinue {
    fn from(node: &'static crate::ranged::StmtContinue) -> Self {
        StmtContinue(node)
    }
}

impl ToPyObject for StmtContinue {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Stmt)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ranged::StmtContinue {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(StmtContinue(self).to_object(py))
    }
}

impl StmtContinue {
    #[inline]
    pub fn py_type_cell() -> &'static OnceCell<Py<PyAny>> {
        static PY_TYPE: OnceCell<Py<PyAny>> = OnceCell::new();
        &PY_TYPE
    }
}

#[pymethods]
impl StmtContinue {}

#[pyclass(module="rustpython_ast.ranged", name="_expr", extends=super::AST, frozen, subclass)]
#[derive(Clone, Debug)]
pub struct Expr;

impl From<&'static crate::ranged::Expr> for Expr {
    fn from(_node: &'static crate::ranged::Expr) -> Self {
        Expr
    }
}

#[pymethods]
impl Expr {
    #[new]
    fn new() -> PyClassInitializer<Self> {
        PyClassInitializer::from(AST).add_subclass(Self)
    }
}
impl ToPyObject for Expr {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST).add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl Expr {
    #[inline]
    pub fn py_type_cell() -> &'static OnceCell<Py<PyAny>> {
        static PY_TYPE: OnceCell<Py<PyAny>> = OnceCell::new();
        &PY_TYPE
    }
}

impl ToPyo3Wrapper for crate::ranged::Expr {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        match &self {
            Self::BoolOp(cons) => cons.to_pyo3_wrapper(py),
            Self::NamedExpr(cons) => cons.to_pyo3_wrapper(py),
            Self::BinOp(cons) => cons.to_pyo3_wrapper(py),
            Self::UnaryOp(cons) => cons.to_pyo3_wrapper(py),
            Self::Lambda(cons) => cons.to_pyo3_wrapper(py),
            Self::IfExp(cons) => cons.to_pyo3_wrapper(py),
            Self::Dict(cons) => cons.to_pyo3_wrapper(py),
            Self::Set(cons) => cons.to_pyo3_wrapper(py),
            Self::ListComp(cons) => cons.to_pyo3_wrapper(py),
            Self::SetComp(cons) => cons.to_pyo3_wrapper(py),
            Self::DictComp(cons) => cons.to_pyo3_wrapper(py),
            Self::GeneratorExp(cons) => cons.to_pyo3_wrapper(py),
            Self::Await(cons) => cons.to_pyo3_wrapper(py),
            Self::Yield(cons) => cons.to_pyo3_wrapper(py),
            Self::YieldFrom(cons) => cons.to_pyo3_wrapper(py),
            Self::Compare(cons) => cons.to_pyo3_wrapper(py),
            Self::Call(cons) => cons.to_pyo3_wrapper(py),
            Self::FormattedValue(cons) => cons.to_pyo3_wrapper(py),
            Self::JoinedStr(cons) => cons.to_pyo3_wrapper(py),
            Self::Constant(cons) => cons.to_pyo3_wrapper(py),
            Self::Attribute(cons) => cons.to_pyo3_wrapper(py),
            Self::Subscript(cons) => cons.to_pyo3_wrapper(py),
            Self::Starred(cons) => cons.to_pyo3_wrapper(py),
            Self::Name(cons) => cons.to_pyo3_wrapper(py),
            Self::List(cons) => cons.to_pyo3_wrapper(py),
            Self::Tuple(cons) => cons.to_pyo3_wrapper(py),
            Self::Slice(cons) => cons.to_pyo3_wrapper(py),
        }
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_BoolOp", extends=Expr, frozen)]
#[derive(Clone, Debug)]
pub struct ExprBoolOp(pub &'static crate::ranged::ExprBoolOp);

impl From<&'static crate::ranged::ExprBoolOp> for ExprBoolOp {
    fn from(node: &'static crate::ranged::ExprBoolOp) -> Self {
        ExprBoolOp(node)
    }
}

impl ToPyObject for ExprBoolOp {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Expr)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ranged::ExprBoolOp {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ExprBoolOp(self).to_object(py))
    }
}

impl ExprBoolOp {
    #[inline]
    pub fn py_type_cell() -> &'static OnceCell<Py<PyAny>> {
        static PY_TYPE: OnceCell<Py<PyAny>> = OnceCell::new();
        &PY_TYPE
    }
}

#[pymethods]
impl ExprBoolOp {
    #[getter]
    #[inline]
    fn get_op(&self, py: Python) -> PyResult<PyObject> {
        self.0.op.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_values(&self, py: Python) -> PyResult<PyObject> {
        self.0.values.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_NamedExpr", extends=Expr, frozen)]
#[derive(Clone, Debug)]
pub struct ExprNamedExpr(pub &'static crate::ranged::ExprNamedExpr);

impl From<&'static crate::ranged::ExprNamedExpr> for ExprNamedExpr {
    fn from(node: &'static crate::ranged::ExprNamedExpr) -> Self {
        ExprNamedExpr(node)
    }
}

impl ToPyObject for ExprNamedExpr {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Expr)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ranged::ExprNamedExpr {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ExprNamedExpr(self).to_object(py))
    }
}

impl ExprNamedExpr {
    #[inline]
    pub fn py_type_cell() -> &'static OnceCell<Py<PyAny>> {
        static PY_TYPE: OnceCell<Py<PyAny>> = OnceCell::new();
        &PY_TYPE
    }
}

#[pymethods]
impl ExprNamedExpr {
    #[getter]
    #[inline]
    fn get_target(&self, py: Python) -> PyResult<PyObject> {
        self.0.target.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_value(&self, py: Python) -> PyResult<PyObject> {
        self.0.value.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_BinOp", extends=Expr, frozen)]
#[derive(Clone, Debug)]
pub struct ExprBinOp(pub &'static crate::ranged::ExprBinOp);

impl From<&'static crate::ranged::ExprBinOp> for ExprBinOp {
    fn from(node: &'static crate::ranged::ExprBinOp) -> Self {
        ExprBinOp(node)
    }
}

impl ToPyObject for ExprBinOp {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Expr)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ranged::ExprBinOp {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ExprBinOp(self).to_object(py))
    }
}

impl ExprBinOp {
    #[inline]
    pub fn py_type_cell() -> &'static OnceCell<Py<PyAny>> {
        static PY_TYPE: OnceCell<Py<PyAny>> = OnceCell::new();
        &PY_TYPE
    }
}

#[pymethods]
impl ExprBinOp {
    #[getter]
    #[inline]
    fn get_left(&self, py: Python) -> PyResult<PyObject> {
        self.0.left.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_op(&self, py: Python) -> PyResult<PyObject> {
        self.0.op.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_right(&self, py: Python) -> PyResult<PyObject> {
        self.0.right.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_UnaryOp", extends=Expr, frozen)]
#[derive(Clone, Debug)]
pub struct ExprUnaryOp(pub &'static crate::ranged::ExprUnaryOp);

impl From<&'static crate::ranged::ExprUnaryOp> for ExprUnaryOp {
    fn from(node: &'static crate::ranged::ExprUnaryOp) -> Self {
        ExprUnaryOp(node)
    }
}

impl ToPyObject for ExprUnaryOp {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Expr)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ranged::ExprUnaryOp {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ExprUnaryOp(self).to_object(py))
    }
}

impl ExprUnaryOp {
    #[inline]
    pub fn py_type_cell() -> &'static OnceCell<Py<PyAny>> {
        static PY_TYPE: OnceCell<Py<PyAny>> = OnceCell::new();
        &PY_TYPE
    }
}

#[pymethods]
impl ExprUnaryOp {
    #[getter]
    #[inline]
    fn get_op(&self, py: Python) -> PyResult<PyObject> {
        self.0.op.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_operand(&self, py: Python) -> PyResult<PyObject> {
        self.0.operand.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Lambda", extends=Expr, frozen)]
#[derive(Clone, Debug)]
pub struct ExprLambda(pub &'static crate::ranged::ExprLambda);

impl From<&'static crate::ranged::ExprLambda> for ExprLambda {
    fn from(node: &'static crate::ranged::ExprLambda) -> Self {
        ExprLambda(node)
    }
}

impl ToPyObject for ExprLambda {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Expr)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ranged::ExprLambda {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ExprLambda(self).to_object(py))
    }
}

impl ExprLambda {
    #[inline]
    pub fn py_type_cell() -> &'static OnceCell<Py<PyAny>> {
        static PY_TYPE: OnceCell<Py<PyAny>> = OnceCell::new();
        &PY_TYPE
    }
}

#[pymethods]
impl ExprLambda {
    #[getter]
    #[inline]
    fn get_args(&self, py: Python) -> PyResult<PyObject> {
        self.0.args.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_body(&self, py: Python) -> PyResult<PyObject> {
        self.0.body.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_IfExp", extends=Expr, frozen)]
#[derive(Clone, Debug)]
pub struct ExprIfExp(pub &'static crate::ranged::ExprIfExp);

impl From<&'static crate::ranged::ExprIfExp> for ExprIfExp {
    fn from(node: &'static crate::ranged::ExprIfExp) -> Self {
        ExprIfExp(node)
    }
}

impl ToPyObject for ExprIfExp {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Expr)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ranged::ExprIfExp {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ExprIfExp(self).to_object(py))
    }
}

impl ExprIfExp {
    #[inline]
    pub fn py_type_cell() -> &'static OnceCell<Py<PyAny>> {
        static PY_TYPE: OnceCell<Py<PyAny>> = OnceCell::new();
        &PY_TYPE
    }
}

#[pymethods]
impl ExprIfExp {
    #[getter]
    #[inline]
    fn get_test(&self, py: Python) -> PyResult<PyObject> {
        self.0.test.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_body(&self, py: Python) -> PyResult<PyObject> {
        self.0.body.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_orelse(&self, py: Python) -> PyResult<PyObject> {
        self.0.orelse.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Dict", extends=Expr, frozen)]
#[derive(Clone, Debug)]
pub struct ExprDict(pub &'static crate::ranged::ExprDict);

impl From<&'static crate::ranged::ExprDict> for ExprDict {
    fn from(node: &'static crate::ranged::ExprDict) -> Self {
        ExprDict(node)
    }
}

impl ToPyObject for ExprDict {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Expr)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ranged::ExprDict {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ExprDict(self).to_object(py))
    }
}

impl ExprDict {
    #[inline]
    pub fn py_type_cell() -> &'static OnceCell<Py<PyAny>> {
        static PY_TYPE: OnceCell<Py<PyAny>> = OnceCell::new();
        &PY_TYPE
    }
}

#[pymethods]
impl ExprDict {
    #[getter]
    #[inline]
    fn get_keys(&self, py: Python) -> PyResult<PyObject> {
        self.0.keys.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_values(&self, py: Python) -> PyResult<PyObject> {
        self.0.values.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Set", extends=Expr, frozen)]
#[derive(Clone, Debug)]
pub struct ExprSet(pub &'static crate::ranged::ExprSet);

impl From<&'static crate::ranged::ExprSet> for ExprSet {
    fn from(node: &'static crate::ranged::ExprSet) -> Self {
        ExprSet(node)
    }
}

impl ToPyObject for ExprSet {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Expr)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ranged::ExprSet {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ExprSet(self).to_object(py))
    }
}

impl ExprSet {
    #[inline]
    pub fn py_type_cell() -> &'static OnceCell<Py<PyAny>> {
        static PY_TYPE: OnceCell<Py<PyAny>> = OnceCell::new();
        &PY_TYPE
    }
}

#[pymethods]
impl ExprSet {
    #[getter]
    #[inline]
    fn get_elts(&self, py: Python) -> PyResult<PyObject> {
        self.0.elts.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_ListComp", extends=Expr, frozen)]
#[derive(Clone, Debug)]
pub struct ExprListComp(pub &'static crate::ranged::ExprListComp);

impl From<&'static crate::ranged::ExprListComp> for ExprListComp {
    fn from(node: &'static crate::ranged::ExprListComp) -> Self {
        ExprListComp(node)
    }
}

impl ToPyObject for ExprListComp {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Expr)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ranged::ExprListComp {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ExprListComp(self).to_object(py))
    }
}

impl ExprListComp {
    #[inline]
    pub fn py_type_cell() -> &'static OnceCell<Py<PyAny>> {
        static PY_TYPE: OnceCell<Py<PyAny>> = OnceCell::new();
        &PY_TYPE
    }
}

#[pymethods]
impl ExprListComp {
    #[getter]
    #[inline]
    fn get_elt(&self, py: Python) -> PyResult<PyObject> {
        self.0.elt.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_generators(&self, py: Python) -> PyResult<PyObject> {
        self.0.generators.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_SetComp", extends=Expr, frozen)]
#[derive(Clone, Debug)]
pub struct ExprSetComp(pub &'static crate::ranged::ExprSetComp);

impl From<&'static crate::ranged::ExprSetComp> for ExprSetComp {
    fn from(node: &'static crate::ranged::ExprSetComp) -> Self {
        ExprSetComp(node)
    }
}

impl ToPyObject for ExprSetComp {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Expr)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ranged::ExprSetComp {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ExprSetComp(self).to_object(py))
    }
}

impl ExprSetComp {
    #[inline]
    pub fn py_type_cell() -> &'static OnceCell<Py<PyAny>> {
        static PY_TYPE: OnceCell<Py<PyAny>> = OnceCell::new();
        &PY_TYPE
    }
}

#[pymethods]
impl ExprSetComp {
    #[getter]
    #[inline]
    fn get_elt(&self, py: Python) -> PyResult<PyObject> {
        self.0.elt.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_generators(&self, py: Python) -> PyResult<PyObject> {
        self.0.generators.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_DictComp", extends=Expr, frozen)]
#[derive(Clone, Debug)]
pub struct ExprDictComp(pub &'static crate::ranged::ExprDictComp);

impl From<&'static crate::ranged::ExprDictComp> for ExprDictComp {
    fn from(node: &'static crate::ranged::ExprDictComp) -> Self {
        ExprDictComp(node)
    }
}

impl ToPyObject for ExprDictComp {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Expr)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ranged::ExprDictComp {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ExprDictComp(self).to_object(py))
    }
}

impl ExprDictComp {
    #[inline]
    pub fn py_type_cell() -> &'static OnceCell<Py<PyAny>> {
        static PY_TYPE: OnceCell<Py<PyAny>> = OnceCell::new();
        &PY_TYPE
    }
}

#[pymethods]
impl ExprDictComp {
    #[getter]
    #[inline]
    fn get_key(&self, py: Python) -> PyResult<PyObject> {
        self.0.key.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_value(&self, py: Python) -> PyResult<PyObject> {
        self.0.value.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_generators(&self, py: Python) -> PyResult<PyObject> {
        self.0.generators.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_GeneratorExp", extends=Expr, frozen)]
#[derive(Clone, Debug)]
pub struct ExprGeneratorExp(pub &'static crate::ranged::ExprGeneratorExp);

impl From<&'static crate::ranged::ExprGeneratorExp> for ExprGeneratorExp {
    fn from(node: &'static crate::ranged::ExprGeneratorExp) -> Self {
        ExprGeneratorExp(node)
    }
}

impl ToPyObject for ExprGeneratorExp {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Expr)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ranged::ExprGeneratorExp {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ExprGeneratorExp(self).to_object(py))
    }
}

impl ExprGeneratorExp {
    #[inline]
    pub fn py_type_cell() -> &'static OnceCell<Py<PyAny>> {
        static PY_TYPE: OnceCell<Py<PyAny>> = OnceCell::new();
        &PY_TYPE
    }
}

#[pymethods]
impl ExprGeneratorExp {
    #[getter]
    #[inline]
    fn get_elt(&self, py: Python) -> PyResult<PyObject> {
        self.0.elt.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_generators(&self, py: Python) -> PyResult<PyObject> {
        self.0.generators.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Await", extends=Expr, frozen)]
#[derive(Clone, Debug)]
pub struct ExprAwait(pub &'static crate::ranged::ExprAwait);

impl From<&'static crate::ranged::ExprAwait> for ExprAwait {
    fn from(node: &'static crate::ranged::ExprAwait) -> Self {
        ExprAwait(node)
    }
}

impl ToPyObject for ExprAwait {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Expr)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ranged::ExprAwait {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ExprAwait(self).to_object(py))
    }
}

impl ExprAwait {
    #[inline]
    pub fn py_type_cell() -> &'static OnceCell<Py<PyAny>> {
        static PY_TYPE: OnceCell<Py<PyAny>> = OnceCell::new();
        &PY_TYPE
    }
}

#[pymethods]
impl ExprAwait {
    #[getter]
    #[inline]
    fn get_value(&self, py: Python) -> PyResult<PyObject> {
        self.0.value.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Yield", extends=Expr, frozen)]
#[derive(Clone, Debug)]
pub struct ExprYield(pub &'static crate::ranged::ExprYield);

impl From<&'static crate::ranged::ExprYield> for ExprYield {
    fn from(node: &'static crate::ranged::ExprYield) -> Self {
        ExprYield(node)
    }
}

impl ToPyObject for ExprYield {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Expr)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ranged::ExprYield {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ExprYield(self).to_object(py))
    }
}

impl ExprYield {
    #[inline]
    pub fn py_type_cell() -> &'static OnceCell<Py<PyAny>> {
        static PY_TYPE: OnceCell<Py<PyAny>> = OnceCell::new();
        &PY_TYPE
    }
}

#[pymethods]
impl ExprYield {
    #[getter]
    #[inline]
    fn get_value(&self, py: Python) -> PyResult<PyObject> {
        self.0.value.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_YieldFrom", extends=Expr, frozen)]
#[derive(Clone, Debug)]
pub struct ExprYieldFrom(pub &'static crate::ranged::ExprYieldFrom);

impl From<&'static crate::ranged::ExprYieldFrom> for ExprYieldFrom {
    fn from(node: &'static crate::ranged::ExprYieldFrom) -> Self {
        ExprYieldFrom(node)
    }
}

impl ToPyObject for ExprYieldFrom {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Expr)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ranged::ExprYieldFrom {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ExprYieldFrom(self).to_object(py))
    }
}

impl ExprYieldFrom {
    #[inline]
    pub fn py_type_cell() -> &'static OnceCell<Py<PyAny>> {
        static PY_TYPE: OnceCell<Py<PyAny>> = OnceCell::new();
        &PY_TYPE
    }
}

#[pymethods]
impl ExprYieldFrom {
    #[getter]
    #[inline]
    fn get_value(&self, py: Python) -> PyResult<PyObject> {
        self.0.value.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Compare", extends=Expr, frozen)]
#[derive(Clone, Debug)]
pub struct ExprCompare(pub &'static crate::ranged::ExprCompare);

impl From<&'static crate::ranged::ExprCompare> for ExprCompare {
    fn from(node: &'static crate::ranged::ExprCompare) -> Self {
        ExprCompare(node)
    }
}

impl ToPyObject for ExprCompare {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Expr)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ranged::ExprCompare {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ExprCompare(self).to_object(py))
    }
}

impl ExprCompare {
    #[inline]
    pub fn py_type_cell() -> &'static OnceCell<Py<PyAny>> {
        static PY_TYPE: OnceCell<Py<PyAny>> = OnceCell::new();
        &PY_TYPE
    }
}

#[pymethods]
impl ExprCompare {
    #[getter]
    #[inline]
    fn get_left(&self, py: Python) -> PyResult<PyObject> {
        self.0.left.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_ops(&self, py: Python) -> PyResult<PyObject> {
        self.0.ops.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_comparators(&self, py: Python) -> PyResult<PyObject> {
        self.0.comparators.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Call", extends=Expr, frozen)]
#[derive(Clone, Debug)]
pub struct ExprCall(pub &'static crate::ranged::ExprCall);

impl From<&'static crate::ranged::ExprCall> for ExprCall {
    fn from(node: &'static crate::ranged::ExprCall) -> Self {
        ExprCall(node)
    }
}

impl ToPyObject for ExprCall {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Expr)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ranged::ExprCall {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ExprCall(self).to_object(py))
    }
}

impl ExprCall {
    #[inline]
    pub fn py_type_cell() -> &'static OnceCell<Py<PyAny>> {
        static PY_TYPE: OnceCell<Py<PyAny>> = OnceCell::new();
        &PY_TYPE
    }
}

#[pymethods]
impl ExprCall {
    #[getter]
    #[inline]
    fn get_func(&self, py: Python) -> PyResult<PyObject> {
        self.0.func.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_args(&self, py: Python) -> PyResult<PyObject> {
        self.0.args.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_keywords(&self, py: Python) -> PyResult<PyObject> {
        self.0.keywords.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_FormattedValue", extends=Expr, frozen)]
#[derive(Clone, Debug)]
pub struct ExprFormattedValue(pub &'static crate::ranged::ExprFormattedValue);

impl From<&'static crate::ranged::ExprFormattedValue> for ExprFormattedValue {
    fn from(node: &'static crate::ranged::ExprFormattedValue) -> Self {
        ExprFormattedValue(node)
    }
}

impl ToPyObject for ExprFormattedValue {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Expr)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ranged::ExprFormattedValue {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ExprFormattedValue(self).to_object(py))
    }
}

impl ExprFormattedValue {
    #[inline]
    pub fn py_type_cell() -> &'static OnceCell<Py<PyAny>> {
        static PY_TYPE: OnceCell<Py<PyAny>> = OnceCell::new();
        &PY_TYPE
    }
}

#[pymethods]
impl ExprFormattedValue {
    #[getter]
    #[inline]
    fn get_value(&self, py: Python) -> PyResult<PyObject> {
        self.0.value.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_conversion(&self, py: Python) -> PyResult<PyObject> {
        self.0.conversion.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_format_spec(&self, py: Python) -> PyResult<PyObject> {
        self.0.format_spec.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_JoinedStr", extends=Expr, frozen)]
#[derive(Clone, Debug)]
pub struct ExprJoinedStr(pub &'static crate::ranged::ExprJoinedStr);

impl From<&'static crate::ranged::ExprJoinedStr> for ExprJoinedStr {
    fn from(node: &'static crate::ranged::ExprJoinedStr) -> Self {
        ExprJoinedStr(node)
    }
}

impl ToPyObject for ExprJoinedStr {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Expr)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ranged::ExprJoinedStr {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ExprJoinedStr(self).to_object(py))
    }
}

impl ExprJoinedStr {
    #[inline]
    pub fn py_type_cell() -> &'static OnceCell<Py<PyAny>> {
        static PY_TYPE: OnceCell<Py<PyAny>> = OnceCell::new();
        &PY_TYPE
    }
}

#[pymethods]
impl ExprJoinedStr {
    #[getter]
    #[inline]
    fn get_values(&self, py: Python) -> PyResult<PyObject> {
        self.0.values.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Constant", extends=Expr, frozen)]
#[derive(Clone, Debug)]
pub struct ExprConstant(pub &'static crate::ranged::ExprConstant);

impl From<&'static crate::ranged::ExprConstant> for ExprConstant {
    fn from(node: &'static crate::ranged::ExprConstant) -> Self {
        ExprConstant(node)
    }
}

impl ToPyObject for ExprConstant {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Expr)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ranged::ExprConstant {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ExprConstant(self).to_object(py))
    }
}

impl ExprConstant {
    #[inline]
    pub fn py_type_cell() -> &'static OnceCell<Py<PyAny>> {
        static PY_TYPE: OnceCell<Py<PyAny>> = OnceCell::new();
        &PY_TYPE
    }
}

#[pymethods]
impl ExprConstant {
    #[getter]
    #[inline]
    fn get_value(&self, py: Python) -> PyResult<PyObject> {
        self.0.value.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_kind(&self, py: Python) -> PyResult<PyObject> {
        self.0.kind.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Attribute", extends=Expr, frozen)]
#[derive(Clone, Debug)]
pub struct ExprAttribute(pub &'static crate::ranged::ExprAttribute);

impl From<&'static crate::ranged::ExprAttribute> for ExprAttribute {
    fn from(node: &'static crate::ranged::ExprAttribute) -> Self {
        ExprAttribute(node)
    }
}

impl ToPyObject for ExprAttribute {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Expr)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ranged::ExprAttribute {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ExprAttribute(self).to_object(py))
    }
}

impl ExprAttribute {
    #[inline]
    pub fn py_type_cell() -> &'static OnceCell<Py<PyAny>> {
        static PY_TYPE: OnceCell<Py<PyAny>> = OnceCell::new();
        &PY_TYPE
    }
}

#[pymethods]
impl ExprAttribute {
    #[getter]
    #[inline]
    fn get_value(&self, py: Python) -> PyResult<PyObject> {
        self.0.value.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_attr(&self, py: Python) -> PyResult<PyObject> {
        self.0.attr.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_ctx(&self, py: Python) -> PyResult<PyObject> {
        self.0.ctx.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Subscript", extends=Expr, frozen)]
#[derive(Clone, Debug)]
pub struct ExprSubscript(pub &'static crate::ranged::ExprSubscript);

impl From<&'static crate::ranged::ExprSubscript> for ExprSubscript {
    fn from(node: &'static crate::ranged::ExprSubscript) -> Self {
        ExprSubscript(node)
    }
}

impl ToPyObject for ExprSubscript {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Expr)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ranged::ExprSubscript {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ExprSubscript(self).to_object(py))
    }
}

impl ExprSubscript {
    #[inline]
    pub fn py_type_cell() -> &'static OnceCell<Py<PyAny>> {
        static PY_TYPE: OnceCell<Py<PyAny>> = OnceCell::new();
        &PY_TYPE
    }
}

#[pymethods]
impl ExprSubscript {
    #[getter]
    #[inline]
    fn get_value(&self, py: Python) -> PyResult<PyObject> {
        self.0.value.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_slice(&self, py: Python) -> PyResult<PyObject> {
        self.0.slice.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_ctx(&self, py: Python) -> PyResult<PyObject> {
        self.0.ctx.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Starred", extends=Expr, frozen)]
#[derive(Clone, Debug)]
pub struct ExprStarred(pub &'static crate::ranged::ExprStarred);

impl From<&'static crate::ranged::ExprStarred> for ExprStarred {
    fn from(node: &'static crate::ranged::ExprStarred) -> Self {
        ExprStarred(node)
    }
}

impl ToPyObject for ExprStarred {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Expr)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ranged::ExprStarred {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ExprStarred(self).to_object(py))
    }
}

impl ExprStarred {
    #[inline]
    pub fn py_type_cell() -> &'static OnceCell<Py<PyAny>> {
        static PY_TYPE: OnceCell<Py<PyAny>> = OnceCell::new();
        &PY_TYPE
    }
}

#[pymethods]
impl ExprStarred {
    #[getter]
    #[inline]
    fn get_value(&self, py: Python) -> PyResult<PyObject> {
        self.0.value.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_ctx(&self, py: Python) -> PyResult<PyObject> {
        self.0.ctx.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Name", extends=Expr, frozen)]
#[derive(Clone, Debug)]
pub struct ExprName(pub &'static crate::ranged::ExprName);

impl From<&'static crate::ranged::ExprName> for ExprName {
    fn from(node: &'static crate::ranged::ExprName) -> Self {
        ExprName(node)
    }
}

impl ToPyObject for ExprName {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Expr)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ranged::ExprName {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ExprName(self).to_object(py))
    }
}

impl ExprName {
    #[inline]
    pub fn py_type_cell() -> &'static OnceCell<Py<PyAny>> {
        static PY_TYPE: OnceCell<Py<PyAny>> = OnceCell::new();
        &PY_TYPE
    }
}

#[pymethods]
impl ExprName {
    #[getter]
    #[inline]
    fn get_id(&self, py: Python) -> PyResult<PyObject> {
        self.0.id.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_ctx(&self, py: Python) -> PyResult<PyObject> {
        self.0.ctx.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_List", extends=Expr, frozen)]
#[derive(Clone, Debug)]
pub struct ExprList(pub &'static crate::ranged::ExprList);

impl From<&'static crate::ranged::ExprList> for ExprList {
    fn from(node: &'static crate::ranged::ExprList) -> Self {
        ExprList(node)
    }
}

impl ToPyObject for ExprList {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Expr)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ranged::ExprList {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ExprList(self).to_object(py))
    }
}

impl ExprList {
    #[inline]
    pub fn py_type_cell() -> &'static OnceCell<Py<PyAny>> {
        static PY_TYPE: OnceCell<Py<PyAny>> = OnceCell::new();
        &PY_TYPE
    }
}

#[pymethods]
impl ExprList {
    #[getter]
    #[inline]
    fn get_elts(&self, py: Python) -> PyResult<PyObject> {
        self.0.elts.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_ctx(&self, py: Python) -> PyResult<PyObject> {
        self.0.ctx.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Tuple", extends=Expr, frozen)]
#[derive(Clone, Debug)]
pub struct ExprTuple(pub &'static crate::ranged::ExprTuple);

impl From<&'static crate::ranged::ExprTuple> for ExprTuple {
    fn from(node: &'static crate::ranged::ExprTuple) -> Self {
        ExprTuple(node)
    }
}

impl ToPyObject for ExprTuple {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Expr)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ranged::ExprTuple {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ExprTuple(self).to_object(py))
    }
}

impl ExprTuple {
    #[inline]
    pub fn py_type_cell() -> &'static OnceCell<Py<PyAny>> {
        static PY_TYPE: OnceCell<Py<PyAny>> = OnceCell::new();
        &PY_TYPE
    }
}

#[pymethods]
impl ExprTuple {
    #[getter]
    #[inline]
    fn get_elts(&self, py: Python) -> PyResult<PyObject> {
        self.0.elts.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_ctx(&self, py: Python) -> PyResult<PyObject> {
        self.0.ctx.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Slice", extends=Expr, frozen)]
#[derive(Clone, Debug)]
pub struct ExprSlice(pub &'static crate::ranged::ExprSlice);

impl From<&'static crate::ranged::ExprSlice> for ExprSlice {
    fn from(node: &'static crate::ranged::ExprSlice) -> Self {
        ExprSlice(node)
    }
}

impl ToPyObject for ExprSlice {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Expr)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ranged::ExprSlice {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ExprSlice(self).to_object(py))
    }
}

impl ExprSlice {
    #[inline]
    pub fn py_type_cell() -> &'static OnceCell<Py<PyAny>> {
        static PY_TYPE: OnceCell<Py<PyAny>> = OnceCell::new();
        &PY_TYPE
    }
}

#[pymethods]
impl ExprSlice {
    #[getter]
    #[inline]
    fn get_lower(&self, py: Python) -> PyResult<PyObject> {
        self.0.lower.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_upper(&self, py: Python) -> PyResult<PyObject> {
        self.0.upper.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_step(&self, py: Python) -> PyResult<PyObject> {
        self.0.step.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_expr_context", extends=super::AST, frozen, subclass)]
#[derive(Clone, Debug)]
pub struct ExprContext;

impl From<&'static crate::ranged::ExprContext> for ExprContext {
    fn from(_node: &'static crate::ranged::ExprContext) -> Self {
        ExprContext
    }
}

#[pymethods]
impl ExprContext {
    #[new]
    fn new() -> PyClassInitializer<Self> {
        PyClassInitializer::from(AST).add_subclass(Self)
    }
}
impl ToPyObject for ExprContext {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST).add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ExprContext {
    #[inline]
    pub fn py_type_cell() -> &'static OnceCell<Py<PyAny>> {
        static PY_TYPE: OnceCell<Py<PyAny>> = OnceCell::new();
        &PY_TYPE
    }
}

impl ToPyo3Wrapper for crate::ranged::ExprContext {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        match &self {
            Self::Load => Ok(ExprContextLoad.to_object(py)),
            Self::Store => Ok(ExprContextStore.to_object(py)),
            Self::Del => Ok(ExprContextDel.to_object(py)),
        }
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Load", extends=ExprContext)]
pub struct ExprContextLoad;

impl ToPyObject for ExprContextLoad {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(ExprContext)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ExprContextLoad {
    #[inline]
    pub fn py_type_cell() -> &'static OnceCell<Py<PyAny>> {
        static PY_TYPE: OnceCell<Py<PyAny>> = OnceCell::new();
        &PY_TYPE
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Store", extends=ExprContext)]
pub struct ExprContextStore;

impl ToPyObject for ExprContextStore {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(ExprContext)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ExprContextStore {
    #[inline]
    pub fn py_type_cell() -> &'static OnceCell<Py<PyAny>> {
        static PY_TYPE: OnceCell<Py<PyAny>> = OnceCell::new();
        &PY_TYPE
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Del", extends=ExprContext)]
pub struct ExprContextDel;

impl ToPyObject for ExprContextDel {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(ExprContext)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ExprContextDel {
    #[inline]
    pub fn py_type_cell() -> &'static OnceCell<Py<PyAny>> {
        static PY_TYPE: OnceCell<Py<PyAny>> = OnceCell::new();
        &PY_TYPE
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_boolop", extends=super::AST, frozen, subclass)]
#[derive(Clone, Debug)]
pub struct Boolop;

impl From<&'static crate::ranged::Boolop> for Boolop {
    fn from(_node: &'static crate::ranged::Boolop) -> Self {
        Boolop
    }
}

#[pymethods]
impl Boolop {
    #[new]
    fn new() -> PyClassInitializer<Self> {
        PyClassInitializer::from(AST).add_subclass(Self)
    }
}
impl ToPyObject for Boolop {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST).add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl Boolop {
    #[inline]
    pub fn py_type_cell() -> &'static OnceCell<Py<PyAny>> {
        static PY_TYPE: OnceCell<Py<PyAny>> = OnceCell::new();
        &PY_TYPE
    }
}

impl ToPyo3Wrapper for crate::ranged::Boolop {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        match &self {
            Self::And => Ok(BoolopAnd.to_object(py)),
            Self::Or => Ok(BoolopOr.to_object(py)),
        }
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_And", extends=Boolop)]
pub struct BoolopAnd;

impl ToPyObject for BoolopAnd {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Boolop)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl BoolopAnd {
    #[inline]
    pub fn py_type_cell() -> &'static OnceCell<Py<PyAny>> {
        static PY_TYPE: OnceCell<Py<PyAny>> = OnceCell::new();
        &PY_TYPE
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Or", extends=Boolop)]
pub struct BoolopOr;

impl ToPyObject for BoolopOr {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Boolop)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl BoolopOr {
    #[inline]
    pub fn py_type_cell() -> &'static OnceCell<Py<PyAny>> {
        static PY_TYPE: OnceCell<Py<PyAny>> = OnceCell::new();
        &PY_TYPE
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_operator", extends=super::AST, frozen, subclass)]
#[derive(Clone, Debug)]
pub struct Operator;

impl From<&'static crate::ranged::Operator> for Operator {
    fn from(_node: &'static crate::ranged::Operator) -> Self {
        Operator
    }
}

#[pymethods]
impl Operator {
    #[new]
    fn new() -> PyClassInitializer<Self> {
        PyClassInitializer::from(AST).add_subclass(Self)
    }
}
impl ToPyObject for Operator {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST).add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl Operator {
    #[inline]
    pub fn py_type_cell() -> &'static OnceCell<Py<PyAny>> {
        static PY_TYPE: OnceCell<Py<PyAny>> = OnceCell::new();
        &PY_TYPE
    }
}

impl ToPyo3Wrapper for crate::ranged::Operator {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        match &self {
            Self::Add => Ok(OperatorAdd.to_object(py)),
            Self::Sub => Ok(OperatorSub.to_object(py)),
            Self::Mult => Ok(OperatorMult.to_object(py)),
            Self::MatMult => Ok(OperatorMatMult.to_object(py)),
            Self::Div => Ok(OperatorDiv.to_object(py)),
            Self::Mod => Ok(OperatorMod.to_object(py)),
            Self::Pow => Ok(OperatorPow.to_object(py)),
            Self::LShift => Ok(OperatorLShift.to_object(py)),
            Self::RShift => Ok(OperatorRShift.to_object(py)),
            Self::BitOr => Ok(OperatorBitOr.to_object(py)),
            Self::BitXor => Ok(OperatorBitXor.to_object(py)),
            Self::BitAnd => Ok(OperatorBitAnd.to_object(py)),
            Self::FloorDiv => Ok(OperatorFloorDiv.to_object(py)),
        }
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Add", extends=Operator)]
pub struct OperatorAdd;

impl ToPyObject for OperatorAdd {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Operator)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl OperatorAdd {
    #[inline]
    pub fn py_type_cell() -> &'static OnceCell<Py<PyAny>> {
        static PY_TYPE: OnceCell<Py<PyAny>> = OnceCell::new();
        &PY_TYPE
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Sub", extends=Operator)]
pub struct OperatorSub;

impl ToPyObject for OperatorSub {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Operator)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl OperatorSub {
    #[inline]
    pub fn py_type_cell() -> &'static OnceCell<Py<PyAny>> {
        static PY_TYPE: OnceCell<Py<PyAny>> = OnceCell::new();
        &PY_TYPE
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Mult", extends=Operator)]
pub struct OperatorMult;

impl ToPyObject for OperatorMult {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Operator)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl OperatorMult {
    #[inline]
    pub fn py_type_cell() -> &'static OnceCell<Py<PyAny>> {
        static PY_TYPE: OnceCell<Py<PyAny>> = OnceCell::new();
        &PY_TYPE
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_MatMult", extends=Operator)]
pub struct OperatorMatMult;

impl ToPyObject for OperatorMatMult {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Operator)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl OperatorMatMult {
    #[inline]
    pub fn py_type_cell() -> &'static OnceCell<Py<PyAny>> {
        static PY_TYPE: OnceCell<Py<PyAny>> = OnceCell::new();
        &PY_TYPE
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Div", extends=Operator)]
pub struct OperatorDiv;

impl ToPyObject for OperatorDiv {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Operator)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl OperatorDiv {
    #[inline]
    pub fn py_type_cell() -> &'static OnceCell<Py<PyAny>> {
        static PY_TYPE: OnceCell<Py<PyAny>> = OnceCell::new();
        &PY_TYPE
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Mod", extends=Operator)]
pub struct OperatorMod;

impl ToPyObject for OperatorMod {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Operator)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl OperatorMod {
    #[inline]
    pub fn py_type_cell() -> &'static OnceCell<Py<PyAny>> {
        static PY_TYPE: OnceCell<Py<PyAny>> = OnceCell::new();
        &PY_TYPE
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Pow", extends=Operator)]
pub struct OperatorPow;

impl ToPyObject for OperatorPow {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Operator)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl OperatorPow {
    #[inline]
    pub fn py_type_cell() -> &'static OnceCell<Py<PyAny>> {
        static PY_TYPE: OnceCell<Py<PyAny>> = OnceCell::new();
        &PY_TYPE
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_LShift", extends=Operator)]
pub struct OperatorLShift;

impl ToPyObject for OperatorLShift {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Operator)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl OperatorLShift {
    #[inline]
    pub fn py_type_cell() -> &'static OnceCell<Py<PyAny>> {
        static PY_TYPE: OnceCell<Py<PyAny>> = OnceCell::new();
        &PY_TYPE
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_RShift", extends=Operator)]
pub struct OperatorRShift;

impl ToPyObject for OperatorRShift {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Operator)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl OperatorRShift {
    #[inline]
    pub fn py_type_cell() -> &'static OnceCell<Py<PyAny>> {
        static PY_TYPE: OnceCell<Py<PyAny>> = OnceCell::new();
        &PY_TYPE
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_BitOr", extends=Operator)]
pub struct OperatorBitOr;

impl ToPyObject for OperatorBitOr {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Operator)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl OperatorBitOr {
    #[inline]
    pub fn py_type_cell() -> &'static OnceCell<Py<PyAny>> {
        static PY_TYPE: OnceCell<Py<PyAny>> = OnceCell::new();
        &PY_TYPE
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_BitXor", extends=Operator)]
pub struct OperatorBitXor;

impl ToPyObject for OperatorBitXor {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Operator)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl OperatorBitXor {
    #[inline]
    pub fn py_type_cell() -> &'static OnceCell<Py<PyAny>> {
        static PY_TYPE: OnceCell<Py<PyAny>> = OnceCell::new();
        &PY_TYPE
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_BitAnd", extends=Operator)]
pub struct OperatorBitAnd;

impl ToPyObject for OperatorBitAnd {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Operator)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl OperatorBitAnd {
    #[inline]
    pub fn py_type_cell() -> &'static OnceCell<Py<PyAny>> {
        static PY_TYPE: OnceCell<Py<PyAny>> = OnceCell::new();
        &PY_TYPE
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_FloorDiv", extends=Operator)]
pub struct OperatorFloorDiv;

impl ToPyObject for OperatorFloorDiv {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Operator)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl OperatorFloorDiv {
    #[inline]
    pub fn py_type_cell() -> &'static OnceCell<Py<PyAny>> {
        static PY_TYPE: OnceCell<Py<PyAny>> = OnceCell::new();
        &PY_TYPE
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_unaryop", extends=super::AST, frozen, subclass)]
#[derive(Clone, Debug)]
pub struct Unaryop;

impl From<&'static crate::ranged::Unaryop> for Unaryop {
    fn from(_node: &'static crate::ranged::Unaryop) -> Self {
        Unaryop
    }
}

#[pymethods]
impl Unaryop {
    #[new]
    fn new() -> PyClassInitializer<Self> {
        PyClassInitializer::from(AST).add_subclass(Self)
    }
}
impl ToPyObject for Unaryop {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST).add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl Unaryop {
    #[inline]
    pub fn py_type_cell() -> &'static OnceCell<Py<PyAny>> {
        static PY_TYPE: OnceCell<Py<PyAny>> = OnceCell::new();
        &PY_TYPE
    }
}

impl ToPyo3Wrapper for crate::ranged::Unaryop {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        match &self {
            Self::Invert => Ok(UnaryopInvert.to_object(py)),
            Self::Not => Ok(UnaryopNot.to_object(py)),
            Self::UAdd => Ok(UnaryopUAdd.to_object(py)),
            Self::USub => Ok(UnaryopUSub.to_object(py)),
        }
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Invert", extends=Unaryop)]
pub struct UnaryopInvert;

impl ToPyObject for UnaryopInvert {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Unaryop)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl UnaryopInvert {
    #[inline]
    pub fn py_type_cell() -> &'static OnceCell<Py<PyAny>> {
        static PY_TYPE: OnceCell<Py<PyAny>> = OnceCell::new();
        &PY_TYPE
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Not", extends=Unaryop)]
pub struct UnaryopNot;

impl ToPyObject for UnaryopNot {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Unaryop)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl UnaryopNot {
    #[inline]
    pub fn py_type_cell() -> &'static OnceCell<Py<PyAny>> {
        static PY_TYPE: OnceCell<Py<PyAny>> = OnceCell::new();
        &PY_TYPE
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_UAdd", extends=Unaryop)]
pub struct UnaryopUAdd;

impl ToPyObject for UnaryopUAdd {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Unaryop)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl UnaryopUAdd {
    #[inline]
    pub fn py_type_cell() -> &'static OnceCell<Py<PyAny>> {
        static PY_TYPE: OnceCell<Py<PyAny>> = OnceCell::new();
        &PY_TYPE
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_USub", extends=Unaryop)]
pub struct UnaryopUSub;

impl ToPyObject for UnaryopUSub {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Unaryop)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl UnaryopUSub {
    #[inline]
    pub fn py_type_cell() -> &'static OnceCell<Py<PyAny>> {
        static PY_TYPE: OnceCell<Py<PyAny>> = OnceCell::new();
        &PY_TYPE
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_cmpop", extends=super::AST, frozen, subclass)]
#[derive(Clone, Debug)]
pub struct Cmpop;

impl From<&'static crate::ranged::Cmpop> for Cmpop {
    fn from(_node: &'static crate::ranged::Cmpop) -> Self {
        Cmpop
    }
}

#[pymethods]
impl Cmpop {
    #[new]
    fn new() -> PyClassInitializer<Self> {
        PyClassInitializer::from(AST).add_subclass(Self)
    }
}
impl ToPyObject for Cmpop {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST).add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl Cmpop {
    #[inline]
    pub fn py_type_cell() -> &'static OnceCell<Py<PyAny>> {
        static PY_TYPE: OnceCell<Py<PyAny>> = OnceCell::new();
        &PY_TYPE
    }
}

impl ToPyo3Wrapper for crate::ranged::Cmpop {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        match &self {
            Self::Eq => Ok(CmpopEq.to_object(py)),
            Self::NotEq => Ok(CmpopNotEq.to_object(py)),
            Self::Lt => Ok(CmpopLt.to_object(py)),
            Self::LtE => Ok(CmpopLtE.to_object(py)),
            Self::Gt => Ok(CmpopGt.to_object(py)),
            Self::GtE => Ok(CmpopGtE.to_object(py)),
            Self::Is => Ok(CmpopIs.to_object(py)),
            Self::IsNot => Ok(CmpopIsNot.to_object(py)),
            Self::In => Ok(CmpopIn.to_object(py)),
            Self::NotIn => Ok(CmpopNotIn.to_object(py)),
        }
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Eq", extends=Cmpop)]
pub struct CmpopEq;

impl ToPyObject for CmpopEq {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Cmpop)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl CmpopEq {
    #[inline]
    pub fn py_type_cell() -> &'static OnceCell<Py<PyAny>> {
        static PY_TYPE: OnceCell<Py<PyAny>> = OnceCell::new();
        &PY_TYPE
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_NotEq", extends=Cmpop)]
pub struct CmpopNotEq;

impl ToPyObject for CmpopNotEq {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Cmpop)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl CmpopNotEq {
    #[inline]
    pub fn py_type_cell() -> &'static OnceCell<Py<PyAny>> {
        static PY_TYPE: OnceCell<Py<PyAny>> = OnceCell::new();
        &PY_TYPE
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Lt", extends=Cmpop)]
pub struct CmpopLt;

impl ToPyObject for CmpopLt {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Cmpop)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl CmpopLt {
    #[inline]
    pub fn py_type_cell() -> &'static OnceCell<Py<PyAny>> {
        static PY_TYPE: OnceCell<Py<PyAny>> = OnceCell::new();
        &PY_TYPE
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_LtE", extends=Cmpop)]
pub struct CmpopLtE;

impl ToPyObject for CmpopLtE {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Cmpop)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl CmpopLtE {
    #[inline]
    pub fn py_type_cell() -> &'static OnceCell<Py<PyAny>> {
        static PY_TYPE: OnceCell<Py<PyAny>> = OnceCell::new();
        &PY_TYPE
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Gt", extends=Cmpop)]
pub struct CmpopGt;

impl ToPyObject for CmpopGt {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Cmpop)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl CmpopGt {
    #[inline]
    pub fn py_type_cell() -> &'static OnceCell<Py<PyAny>> {
        static PY_TYPE: OnceCell<Py<PyAny>> = OnceCell::new();
        &PY_TYPE
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_GtE", extends=Cmpop)]
pub struct CmpopGtE;

impl ToPyObject for CmpopGtE {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Cmpop)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl CmpopGtE {
    #[inline]
    pub fn py_type_cell() -> &'static OnceCell<Py<PyAny>> {
        static PY_TYPE: OnceCell<Py<PyAny>> = OnceCell::new();
        &PY_TYPE
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_Is", extends=Cmpop)]
pub struct CmpopIs;

impl ToPyObject for CmpopIs {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Cmpop)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl CmpopIs {
    #[inline]
    pub fn py_type_cell() -> &'static OnceCell<Py<PyAny>> {
        static PY_TYPE: OnceCell<Py<PyAny>> = OnceCell::new();
        &PY_TYPE
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_IsNot", extends=Cmpop)]
pub struct CmpopIsNot;

impl ToPyObject for CmpopIsNot {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Cmpop)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl CmpopIsNot {
    #[inline]
    pub fn py_type_cell() -> &'static OnceCell<Py<PyAny>> {
        static PY_TYPE: OnceCell<Py<PyAny>> = OnceCell::new();
        &PY_TYPE
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_In", extends=Cmpop)]
pub struct CmpopIn;

impl ToPyObject for CmpopIn {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Cmpop)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl CmpopIn {
    #[inline]
    pub fn py_type_cell() -> &'static OnceCell<Py<PyAny>> {
        static PY_TYPE: OnceCell<Py<PyAny>> = OnceCell::new();
        &PY_TYPE
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_NotIn", extends=Cmpop)]
pub struct CmpopNotIn;

impl ToPyObject for CmpopNotIn {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Cmpop)
            .add_subclass(Self);
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl CmpopNotIn {
    #[inline]
    pub fn py_type_cell() -> &'static OnceCell<Py<PyAny>> {
        static PY_TYPE: OnceCell<Py<PyAny>> = OnceCell::new();
        &PY_TYPE
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_comprehension", extends=super::AST, frozen)]
#[derive(Clone, Debug)]
pub struct Comprehension(pub &'static crate::ranged::Comprehension);

impl From<&'static crate::ranged::Comprehension> for Comprehension {
    fn from(node: &'static crate::ranged::Comprehension) -> Self {
        Comprehension(node)
    }
}

impl ToPyObject for Comprehension {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST).add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ranged::Comprehension {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(Comprehension(self).to_object(py))
    }
}

impl Comprehension {
    #[inline]
    pub fn py_type_cell() -> &'static OnceCell<Py<PyAny>> {
        static PY_TYPE: OnceCell<Py<PyAny>> = OnceCell::new();
        &PY_TYPE
    }
}

#[pymethods]
impl Comprehension {
    #[getter]
    #[inline]
    fn get_target(&self, py: Python) -> PyResult<PyObject> {
        self.0.target.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_iter(&self, py: Python) -> PyResult<PyObject> {
        self.0.iter.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_ifs(&self, py: Python) -> PyResult<PyObject> {
        self.0.ifs.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_is_async(&self, py: Python) -> PyResult<PyObject> {
        self.0.is_async.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_excepthandler", extends=super::AST, frozen, subclass)]
#[derive(Clone, Debug)]
pub struct Excepthandler;

impl From<&'static crate::ranged::Excepthandler> for Excepthandler {
    fn from(_node: &'static crate::ranged::Excepthandler) -> Self {
        Excepthandler
    }
}

#[pymethods]
impl Excepthandler {
    #[new]
    fn new() -> PyClassInitializer<Self> {
        PyClassInitializer::from(AST).add_subclass(Self)
    }
}
impl ToPyObject for Excepthandler {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST).add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl Excepthandler {
    #[inline]
    pub fn py_type_cell() -> &'static OnceCell<Py<PyAny>> {
        static PY_TYPE: OnceCell<Py<PyAny>> = OnceCell::new();
        &PY_TYPE
    }
}

impl ToPyo3Wrapper for crate::ranged::Excepthandler {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        match &self {
            Self::ExceptHandler(cons) => cons.to_pyo3_wrapper(py),
        }
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_ExceptHandler", extends=Excepthandler, frozen)]
#[derive(Clone, Debug)]
pub struct ExcepthandlerExceptHandler(pub &'static crate::ranged::ExcepthandlerExceptHandler);

impl From<&'static crate::ranged::ExcepthandlerExceptHandler> for ExcepthandlerExceptHandler {
    fn from(node: &'static crate::ranged::ExcepthandlerExceptHandler) -> Self {
        ExcepthandlerExceptHandler(node)
    }
}

impl ToPyObject for ExcepthandlerExceptHandler {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Excepthandler)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ranged::ExcepthandlerExceptHandler {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(ExcepthandlerExceptHandler(self).to_object(py))
    }
}

impl ExcepthandlerExceptHandler {
    #[inline]
    pub fn py_type_cell() -> &'static OnceCell<Py<PyAny>> {
        static PY_TYPE: OnceCell<Py<PyAny>> = OnceCell::new();
        &PY_TYPE
    }
}

#[pymethods]
impl ExcepthandlerExceptHandler {
    #[getter]
    #[inline]
    fn get_type(&self, py: Python) -> PyResult<PyObject> {
        self.0.type_.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_name(&self, py: Python) -> PyResult<PyObject> {
        self.0.name.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_body(&self, py: Python) -> PyResult<PyObject> {
        self.0.body.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_arguments", extends=super::AST, frozen)]
#[derive(Clone, Debug)]
pub struct Arguments(pub &'static crate::ranged::Arguments);

impl From<&'static crate::ranged::Arguments> for Arguments {
    fn from(node: &'static crate::ranged::Arguments) -> Self {
        Arguments(node)
    }
}

impl ToPyObject for Arguments {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST).add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ranged::Arguments {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(Arguments(self).to_object(py))
    }
}

impl Arguments {
    #[inline]
    pub fn py_type_cell() -> &'static OnceCell<Py<PyAny>> {
        static PY_TYPE: OnceCell<Py<PyAny>> = OnceCell::new();
        &PY_TYPE
    }
}

#[pymethods]
impl Arguments {
    #[getter]
    #[inline]
    fn get_posonlyargs(&self, py: Python) -> PyResult<PyObject> {
        self.0.posonlyargs.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_args(&self, py: Python) -> PyResult<PyObject> {
        self.0.args.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_vararg(&self, py: Python) -> PyResult<PyObject> {
        self.0.vararg.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_kwonlyargs(&self, py: Python) -> PyResult<PyObject> {
        self.0.kwonlyargs.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_kw_defaults(&self, py: Python) -> PyResult<PyObject> {
        self.0.kw_defaults.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_kwarg(&self, py: Python) -> PyResult<PyObject> {
        self.0.kwarg.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_defaults(&self, py: Python) -> PyResult<PyObject> {
        self.0.defaults.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_arg", extends=super::AST, frozen)]
#[derive(Clone, Debug)]
pub struct Arg(pub &'static crate::ranged::Arg);

impl From<&'static crate::ranged::Arg> for Arg {
    fn from(node: &'static crate::ranged::Arg) -> Self {
        Arg(node)
    }
}

impl ToPyObject for Arg {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST).add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ranged::Arg {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(Arg(self).to_object(py))
    }
}

impl Arg {
    #[inline]
    pub fn py_type_cell() -> &'static OnceCell<Py<PyAny>> {
        static PY_TYPE: OnceCell<Py<PyAny>> = OnceCell::new();
        &PY_TYPE
    }
}

#[pymethods]
impl Arg {
    #[getter]
    #[inline]
    fn get_arg(&self, py: Python) -> PyResult<PyObject> {
        self.0.arg.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_annotation(&self, py: Python) -> PyResult<PyObject> {
        self.0.annotation.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_type_comment(&self, py: Python) -> PyResult<PyObject> {
        self.0.type_comment.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_keyword", extends=super::AST, frozen)]
#[derive(Clone, Debug)]
pub struct Keyword(pub &'static crate::ranged::Keyword);

impl From<&'static crate::ranged::Keyword> for Keyword {
    fn from(node: &'static crate::ranged::Keyword) -> Self {
        Keyword(node)
    }
}

impl ToPyObject for Keyword {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST).add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ranged::Keyword {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(Keyword(self).to_object(py))
    }
}

impl Keyword {
    #[inline]
    pub fn py_type_cell() -> &'static OnceCell<Py<PyAny>> {
        static PY_TYPE: OnceCell<Py<PyAny>> = OnceCell::new();
        &PY_TYPE
    }
}

#[pymethods]
impl Keyword {
    #[getter]
    #[inline]
    fn get_arg(&self, py: Python) -> PyResult<PyObject> {
        self.0.arg.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_value(&self, py: Python) -> PyResult<PyObject> {
        self.0.value.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_alias", extends=super::AST, frozen)]
#[derive(Clone, Debug)]
pub struct Alias(pub &'static crate::ranged::Alias);

impl From<&'static crate::ranged::Alias> for Alias {
    fn from(node: &'static crate::ranged::Alias) -> Self {
        Alias(node)
    }
}

impl ToPyObject for Alias {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST).add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ranged::Alias {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(Alias(self).to_object(py))
    }
}

impl Alias {
    #[inline]
    pub fn py_type_cell() -> &'static OnceCell<Py<PyAny>> {
        static PY_TYPE: OnceCell<Py<PyAny>> = OnceCell::new();
        &PY_TYPE
    }
}

#[pymethods]
impl Alias {
    #[getter]
    #[inline]
    fn get_name(&self, py: Python) -> PyResult<PyObject> {
        self.0.name.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_asname(&self, py: Python) -> PyResult<PyObject> {
        self.0.asname.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_withitem", extends=super::AST, frozen)]
#[derive(Clone, Debug)]
pub struct Withitem(pub &'static crate::ranged::Withitem);

impl From<&'static crate::ranged::Withitem> for Withitem {
    fn from(node: &'static crate::ranged::Withitem) -> Self {
        Withitem(node)
    }
}

impl ToPyObject for Withitem {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST).add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ranged::Withitem {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(Withitem(self).to_object(py))
    }
}

impl Withitem {
    #[inline]
    pub fn py_type_cell() -> &'static OnceCell<Py<PyAny>> {
        static PY_TYPE: OnceCell<Py<PyAny>> = OnceCell::new();
        &PY_TYPE
    }
}

#[pymethods]
impl Withitem {
    #[getter]
    #[inline]
    fn get_context_expr(&self, py: Python) -> PyResult<PyObject> {
        self.0.context_expr.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_optional_vars(&self, py: Python) -> PyResult<PyObject> {
        self.0.optional_vars.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_match_case", extends=super::AST, frozen)]
#[derive(Clone, Debug)]
pub struct MatchCase(pub &'static crate::ranged::MatchCase);

impl From<&'static crate::ranged::MatchCase> for MatchCase {
    fn from(node: &'static crate::ranged::MatchCase) -> Self {
        MatchCase(node)
    }
}

impl ToPyObject for MatchCase {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST).add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ranged::MatchCase {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(MatchCase(self).to_object(py))
    }
}

impl MatchCase {
    #[inline]
    pub fn py_type_cell() -> &'static OnceCell<Py<PyAny>> {
        static PY_TYPE: OnceCell<Py<PyAny>> = OnceCell::new();
        &PY_TYPE
    }
}

#[pymethods]
impl MatchCase {
    #[getter]
    #[inline]
    fn get_pattern(&self, py: Python) -> PyResult<PyObject> {
        self.0.pattern.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_guard(&self, py: Python) -> PyResult<PyObject> {
        self.0.guard.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_body(&self, py: Python) -> PyResult<PyObject> {
        self.0.body.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_pattern", extends=super::AST, frozen, subclass)]
#[derive(Clone, Debug)]
pub struct Pattern;

impl From<&'static crate::ranged::Pattern> for Pattern {
    fn from(_node: &'static crate::ranged::Pattern) -> Self {
        Pattern
    }
}

#[pymethods]
impl Pattern {
    #[new]
    fn new() -> PyClassInitializer<Self> {
        PyClassInitializer::from(AST).add_subclass(Self)
    }
}
impl ToPyObject for Pattern {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST).add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl Pattern {
    #[inline]
    pub fn py_type_cell() -> &'static OnceCell<Py<PyAny>> {
        static PY_TYPE: OnceCell<Py<PyAny>> = OnceCell::new();
        &PY_TYPE
    }
}

impl ToPyo3Wrapper for crate::ranged::Pattern {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        match &self {
            Self::MatchValue(cons) => cons.to_pyo3_wrapper(py),
            Self::MatchSingleton(cons) => cons.to_pyo3_wrapper(py),
            Self::MatchSequence(cons) => cons.to_pyo3_wrapper(py),
            Self::MatchMapping(cons) => cons.to_pyo3_wrapper(py),
            Self::MatchClass(cons) => cons.to_pyo3_wrapper(py),
            Self::MatchStar(cons) => cons.to_pyo3_wrapper(py),
            Self::MatchAs(cons) => cons.to_pyo3_wrapper(py),
            Self::MatchOr(cons) => cons.to_pyo3_wrapper(py),
        }
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_MatchValue", extends=Pattern, frozen)]
#[derive(Clone, Debug)]
pub struct PatternMatchValue(pub &'static crate::ranged::PatternMatchValue);

impl From<&'static crate::ranged::PatternMatchValue> for PatternMatchValue {
    fn from(node: &'static crate::ranged::PatternMatchValue) -> Self {
        PatternMatchValue(node)
    }
}

impl ToPyObject for PatternMatchValue {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Pattern)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ranged::PatternMatchValue {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(PatternMatchValue(self).to_object(py))
    }
}

impl PatternMatchValue {
    #[inline]
    pub fn py_type_cell() -> &'static OnceCell<Py<PyAny>> {
        static PY_TYPE: OnceCell<Py<PyAny>> = OnceCell::new();
        &PY_TYPE
    }
}

#[pymethods]
impl PatternMatchValue {
    #[getter]
    #[inline]
    fn get_value(&self, py: Python) -> PyResult<PyObject> {
        self.0.value.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_MatchSingleton", extends=Pattern, frozen)]
#[derive(Clone, Debug)]
pub struct PatternMatchSingleton(pub &'static crate::ranged::PatternMatchSingleton);

impl From<&'static crate::ranged::PatternMatchSingleton> for PatternMatchSingleton {
    fn from(node: &'static crate::ranged::PatternMatchSingleton) -> Self {
        PatternMatchSingleton(node)
    }
}

impl ToPyObject for PatternMatchSingleton {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Pattern)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ranged::PatternMatchSingleton {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(PatternMatchSingleton(self).to_object(py))
    }
}

impl PatternMatchSingleton {
    #[inline]
    pub fn py_type_cell() -> &'static OnceCell<Py<PyAny>> {
        static PY_TYPE: OnceCell<Py<PyAny>> = OnceCell::new();
        &PY_TYPE
    }
}

#[pymethods]
impl PatternMatchSingleton {
    #[getter]
    #[inline]
    fn get_value(&self, py: Python) -> PyResult<PyObject> {
        self.0.value.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_MatchSequence", extends=Pattern, frozen)]
#[derive(Clone, Debug)]
pub struct PatternMatchSequence(pub &'static crate::ranged::PatternMatchSequence);

impl From<&'static crate::ranged::PatternMatchSequence> for PatternMatchSequence {
    fn from(node: &'static crate::ranged::PatternMatchSequence) -> Self {
        PatternMatchSequence(node)
    }
}

impl ToPyObject for PatternMatchSequence {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Pattern)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ranged::PatternMatchSequence {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(PatternMatchSequence(self).to_object(py))
    }
}

impl PatternMatchSequence {
    #[inline]
    pub fn py_type_cell() -> &'static OnceCell<Py<PyAny>> {
        static PY_TYPE: OnceCell<Py<PyAny>> = OnceCell::new();
        &PY_TYPE
    }
}

#[pymethods]
impl PatternMatchSequence {
    #[getter]
    #[inline]
    fn get_patterns(&self, py: Python) -> PyResult<PyObject> {
        self.0.patterns.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_MatchMapping", extends=Pattern, frozen)]
#[derive(Clone, Debug)]
pub struct PatternMatchMapping(pub &'static crate::ranged::PatternMatchMapping);

impl From<&'static crate::ranged::PatternMatchMapping> for PatternMatchMapping {
    fn from(node: &'static crate::ranged::PatternMatchMapping) -> Self {
        PatternMatchMapping(node)
    }
}

impl ToPyObject for PatternMatchMapping {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Pattern)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ranged::PatternMatchMapping {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(PatternMatchMapping(self).to_object(py))
    }
}

impl PatternMatchMapping {
    #[inline]
    pub fn py_type_cell() -> &'static OnceCell<Py<PyAny>> {
        static PY_TYPE: OnceCell<Py<PyAny>> = OnceCell::new();
        &PY_TYPE
    }
}

#[pymethods]
impl PatternMatchMapping {
    #[getter]
    #[inline]
    fn get_keys(&self, py: Python) -> PyResult<PyObject> {
        self.0.keys.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_patterns(&self, py: Python) -> PyResult<PyObject> {
        self.0.patterns.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_rest(&self, py: Python) -> PyResult<PyObject> {
        self.0.rest.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_MatchClass", extends=Pattern, frozen)]
#[derive(Clone, Debug)]
pub struct PatternMatchClass(pub &'static crate::ranged::PatternMatchClass);

impl From<&'static crate::ranged::PatternMatchClass> for PatternMatchClass {
    fn from(node: &'static crate::ranged::PatternMatchClass) -> Self {
        PatternMatchClass(node)
    }
}

impl ToPyObject for PatternMatchClass {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Pattern)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ranged::PatternMatchClass {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(PatternMatchClass(self).to_object(py))
    }
}

impl PatternMatchClass {
    #[inline]
    pub fn py_type_cell() -> &'static OnceCell<Py<PyAny>> {
        static PY_TYPE: OnceCell<Py<PyAny>> = OnceCell::new();
        &PY_TYPE
    }
}

#[pymethods]
impl PatternMatchClass {
    #[getter]
    #[inline]
    fn get_cls(&self, py: Python) -> PyResult<PyObject> {
        self.0.cls.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_patterns(&self, py: Python) -> PyResult<PyObject> {
        self.0.patterns.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_kwd_attrs(&self, py: Python) -> PyResult<PyObject> {
        self.0.kwd_attrs.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_kwd_patterns(&self, py: Python) -> PyResult<PyObject> {
        self.0.kwd_patterns.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_MatchStar", extends=Pattern, frozen)]
#[derive(Clone, Debug)]
pub struct PatternMatchStar(pub &'static crate::ranged::PatternMatchStar);

impl From<&'static crate::ranged::PatternMatchStar> for PatternMatchStar {
    fn from(node: &'static crate::ranged::PatternMatchStar) -> Self {
        PatternMatchStar(node)
    }
}

impl ToPyObject for PatternMatchStar {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Pattern)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ranged::PatternMatchStar {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(PatternMatchStar(self).to_object(py))
    }
}

impl PatternMatchStar {
    #[inline]
    pub fn py_type_cell() -> &'static OnceCell<Py<PyAny>> {
        static PY_TYPE: OnceCell<Py<PyAny>> = OnceCell::new();
        &PY_TYPE
    }
}

#[pymethods]
impl PatternMatchStar {
    #[getter]
    #[inline]
    fn get_name(&self, py: Python) -> PyResult<PyObject> {
        self.0.name.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_MatchAs", extends=Pattern, frozen)]
#[derive(Clone, Debug)]
pub struct PatternMatchAs(pub &'static crate::ranged::PatternMatchAs);

impl From<&'static crate::ranged::PatternMatchAs> for PatternMatchAs {
    fn from(node: &'static crate::ranged::PatternMatchAs) -> Self {
        PatternMatchAs(node)
    }
}

impl ToPyObject for PatternMatchAs {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Pattern)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ranged::PatternMatchAs {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(PatternMatchAs(self).to_object(py))
    }
}

impl PatternMatchAs {
    #[inline]
    pub fn py_type_cell() -> &'static OnceCell<Py<PyAny>> {
        static PY_TYPE: OnceCell<Py<PyAny>> = OnceCell::new();
        &PY_TYPE
    }
}

#[pymethods]
impl PatternMatchAs {
    #[getter]
    #[inline]
    fn get_pattern(&self, py: Python) -> PyResult<PyObject> {
        self.0.pattern.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_name(&self, py: Python) -> PyResult<PyObject> {
        self.0.name.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_MatchOr", extends=Pattern, frozen)]
#[derive(Clone, Debug)]
pub struct PatternMatchOr(pub &'static crate::ranged::PatternMatchOr);

impl From<&'static crate::ranged::PatternMatchOr> for PatternMatchOr {
    fn from(node: &'static crate::ranged::PatternMatchOr) -> Self {
        PatternMatchOr(node)
    }
}

impl ToPyObject for PatternMatchOr {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(Pattern)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ranged::PatternMatchOr {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(PatternMatchOr(self).to_object(py))
    }
}

impl PatternMatchOr {
    #[inline]
    pub fn py_type_cell() -> &'static OnceCell<Py<PyAny>> {
        static PY_TYPE: OnceCell<Py<PyAny>> = OnceCell::new();
        &PY_TYPE
    }
}

#[pymethods]
impl PatternMatchOr {
    #[getter]
    #[inline]
    fn get_patterns(&self, py: Python) -> PyResult<PyObject> {
        self.0.patterns.to_pyo3_wrapper(py)
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_type_ignore", extends=super::AST, frozen, subclass)]
#[derive(Clone, Debug)]
pub struct TypeIgnore;

impl From<&'static crate::ranged::TypeIgnore> for TypeIgnore {
    fn from(_node: &'static crate::ranged::TypeIgnore) -> Self {
        TypeIgnore
    }
}

#[pymethods]
impl TypeIgnore {
    #[new]
    fn new() -> PyClassInitializer<Self> {
        PyClassInitializer::from(AST).add_subclass(Self)
    }
}
impl ToPyObject for TypeIgnore {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST).add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl TypeIgnore {
    #[inline]
    pub fn py_type_cell() -> &'static OnceCell<Py<PyAny>> {
        static PY_TYPE: OnceCell<Py<PyAny>> = OnceCell::new();
        &PY_TYPE
    }
}

impl ToPyo3Wrapper for crate::ranged::TypeIgnore {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        match &self {
            Self::TypeIgnore(cons) => cons.to_pyo3_wrapper(py),
        }
    }
}

#[pyclass(module="rustpython_ast.ranged", name="_TypeIgnore", extends=TypeIgnore, frozen)]
#[derive(Clone, Debug)]
pub struct TypeIgnoreTypeIgnore(pub &'static crate::ranged::TypeIgnoreTypeIgnore);

impl From<&'static crate::ranged::TypeIgnoreTypeIgnore> for TypeIgnoreTypeIgnore {
    fn from(node: &'static crate::ranged::TypeIgnoreTypeIgnore) -> Self {
        TypeIgnoreTypeIgnore(node)
    }
}

impl ToPyObject for TypeIgnoreTypeIgnore {
    fn to_object(&self, py: Python) -> PyObject {
        let initializer = PyClassInitializer::from(AST)
            .add_subclass(TypeIgnore)
            .add_subclass(self.clone());
        Py::new(py, initializer).unwrap().into_py(py)
    }
}

impl ToPyo3Wrapper for crate::ranged::TypeIgnoreTypeIgnore {
    #[inline]
    fn to_pyo3_wrapper(&'static self, py: Python) -> PyResult<Py<PyAny>> {
        Ok(TypeIgnoreTypeIgnore(self).to_object(py))
    }
}

impl TypeIgnoreTypeIgnore {
    #[inline]
    pub fn py_type_cell() -> &'static OnceCell<Py<PyAny>> {
        static PY_TYPE: OnceCell<Py<PyAny>> = OnceCell::new();
        &PY_TYPE
    }
}

#[pymethods]
impl TypeIgnoreTypeIgnore {
    #[getter]
    #[inline]
    fn get_lineno(&self, py: Python) -> PyResult<PyObject> {
        self.0.lineno.to_pyo3_wrapper(py)
    }

    #[getter]
    #[inline]
    fn get_tag(&self, py: Python) -> PyResult<PyObject> {
        self.0.tag.to_pyo3_wrapper(py)
    }
}

use once_cell::sync::OnceCell;

pub fn add_to_module(py: Python, m: &PyModule) -> PyResult<()> {
    super::init_module(py, m)?;

    let ast_module = PyModule::import(py, "_ast")?;

    Mod::py_type_cell().get_or_init(|| {
        ast_module
            .getattr("mod")
            .unwrap()
            .call0()
            .unwrap()
            .into_py(py)
    });

    ModModule::py_type_cell().get_or_init(|| ast_module.getattr("Module").unwrap().into_py(py));

    {
        m.add_class::<ModModule>()?;
        let node = m.getattr("_Module")?;
        m.setattr("Module", node)?;
        let names: Vec<&'static str> = crate::ranged::ModModule::FIELD_NAMES.to_vec();
        let fields = PyTuple::new(py, names);
        node.setattr("_fields", fields)?;
    }

    ModInteractive::py_type_cell()
        .get_or_init(|| ast_module.getattr("Interactive").unwrap().into_py(py));

    {
        m.add_class::<ModInteractive>()?;
        let node = m.getattr("_Interactive")?;
        m.setattr("Interactive", node)?;
        let names: Vec<&'static str> = crate::ranged::ModInteractive::FIELD_NAMES.to_vec();
        let fields = PyTuple::new(py, names);
        node.setattr("_fields", fields)?;
    }

    ModExpression::py_type_cell()
        .get_or_init(|| ast_module.getattr("Expression").unwrap().into_py(py));

    {
        m.add_class::<ModExpression>()?;
        let node = m.getattr("_Expression")?;
        m.setattr("Expression", node)?;
        let names: Vec<&'static str> = crate::ranged::ModExpression::FIELD_NAMES.to_vec();
        let fields = PyTuple::new(py, names);
        node.setattr("_fields", fields)?;
    }

    ModFunctionType::py_type_cell()
        .get_or_init(|| ast_module.getattr("FunctionType").unwrap().into_py(py));

    {
        m.add_class::<ModFunctionType>()?;
        let node = m.getattr("_FunctionType")?;
        m.setattr("FunctionType", node)?;
        let names: Vec<&'static str> = crate::ranged::ModFunctionType::FIELD_NAMES.to_vec();
        let fields = PyTuple::new(py, names);
        node.setattr("_fields", fields)?;
    }

    Stmt::py_type_cell().get_or_init(|| {
        ast_module
            .getattr("stmt")
            .unwrap()
            .call0()
            .unwrap()
            .into_py(py)
    });

    StmtFunctionDef::py_type_cell()
        .get_or_init(|| ast_module.getattr("FunctionDef").unwrap().into_py(py));

    {
        m.add_class::<StmtFunctionDef>()?;
        let node = m.getattr("_FunctionDef")?;
        m.setattr("FunctionDef", node)?;
        let names: Vec<&'static str> = crate::ranged::StmtFunctionDef::FIELD_NAMES.to_vec();
        let fields = PyTuple::new(py, names);
        node.setattr("_fields", fields)?;
    }

    StmtAsyncFunctionDef::py_type_cell()
        .get_or_init(|| ast_module.getattr("AsyncFunctionDef").unwrap().into_py(py));

    {
        m.add_class::<StmtAsyncFunctionDef>()?;
        let node = m.getattr("_AsyncFunctionDef")?;
        m.setattr("AsyncFunctionDef", node)?;
        let names: Vec<&'static str> = crate::ranged::StmtAsyncFunctionDef::FIELD_NAMES.to_vec();
        let fields = PyTuple::new(py, names);
        node.setattr("_fields", fields)?;
    }

    StmtClassDef::py_type_cell()
        .get_or_init(|| ast_module.getattr("ClassDef").unwrap().into_py(py));

    {
        m.add_class::<StmtClassDef>()?;
        let node = m.getattr("_ClassDef")?;
        m.setattr("ClassDef", node)?;
        let names: Vec<&'static str> = crate::ranged::StmtClassDef::FIELD_NAMES.to_vec();
        let fields = PyTuple::new(py, names);
        node.setattr("_fields", fields)?;
    }

    StmtReturn::py_type_cell().get_or_init(|| ast_module.getattr("Return").unwrap().into_py(py));

    {
        m.add_class::<StmtReturn>()?;
        let node = m.getattr("_Return")?;
        m.setattr("Return", node)?;
        let names: Vec<&'static str> = crate::ranged::StmtReturn::FIELD_NAMES.to_vec();
        let fields = PyTuple::new(py, names);
        node.setattr("_fields", fields)?;
    }

    StmtDelete::py_type_cell().get_or_init(|| ast_module.getattr("Delete").unwrap().into_py(py));

    {
        m.add_class::<StmtDelete>()?;
        let node = m.getattr("_Delete")?;
        m.setattr("Delete", node)?;
        let names: Vec<&'static str> = crate::ranged::StmtDelete::FIELD_NAMES.to_vec();
        let fields = PyTuple::new(py, names);
        node.setattr("_fields", fields)?;
    }

    StmtAssign::py_type_cell().get_or_init(|| ast_module.getattr("Assign").unwrap().into_py(py));

    {
        m.add_class::<StmtAssign>()?;
        let node = m.getattr("_Assign")?;
        m.setattr("Assign", node)?;
        let names: Vec<&'static str> = crate::ranged::StmtAssign::FIELD_NAMES.to_vec();
        let fields = PyTuple::new(py, names);
        node.setattr("_fields", fields)?;
    }

    StmtAugAssign::py_type_cell()
        .get_or_init(|| ast_module.getattr("AugAssign").unwrap().into_py(py));

    {
        m.add_class::<StmtAugAssign>()?;
        let node = m.getattr("_AugAssign")?;
        m.setattr("AugAssign", node)?;
        let names: Vec<&'static str> = crate::ranged::StmtAugAssign::FIELD_NAMES.to_vec();
        let fields = PyTuple::new(py, names);
        node.setattr("_fields", fields)?;
    }

    StmtAnnAssign::py_type_cell()
        .get_or_init(|| ast_module.getattr("AnnAssign").unwrap().into_py(py));

    {
        m.add_class::<StmtAnnAssign>()?;
        let node = m.getattr("_AnnAssign")?;
        m.setattr("AnnAssign", node)?;
        let names: Vec<&'static str> = crate::ranged::StmtAnnAssign::FIELD_NAMES.to_vec();
        let fields = PyTuple::new(py, names);
        node.setattr("_fields", fields)?;
    }

    StmtFor::py_type_cell().get_or_init(|| ast_module.getattr("For").unwrap().into_py(py));

    {
        m.add_class::<StmtFor>()?;
        let node = m.getattr("_For")?;
        m.setattr("For", node)?;
        let names: Vec<&'static str> = crate::ranged::StmtFor::FIELD_NAMES.to_vec();
        let fields = PyTuple::new(py, names);
        node.setattr("_fields", fields)?;
    }

    StmtAsyncFor::py_type_cell()
        .get_or_init(|| ast_module.getattr("AsyncFor").unwrap().into_py(py));

    {
        m.add_class::<StmtAsyncFor>()?;
        let node = m.getattr("_AsyncFor")?;
        m.setattr("AsyncFor", node)?;
        let names: Vec<&'static str> = crate::ranged::StmtAsyncFor::FIELD_NAMES.to_vec();
        let fields = PyTuple::new(py, names);
        node.setattr("_fields", fields)?;
    }

    StmtWhile::py_type_cell().get_or_init(|| ast_module.getattr("While").unwrap().into_py(py));

    {
        m.add_class::<StmtWhile>()?;
        let node = m.getattr("_While")?;
        m.setattr("While", node)?;
        let names: Vec<&'static str> = crate::ranged::StmtWhile::FIELD_NAMES.to_vec();
        let fields = PyTuple::new(py, names);
        node.setattr("_fields", fields)?;
    }

    StmtIf::py_type_cell().get_or_init(|| ast_module.getattr("If").unwrap().into_py(py));

    {
        m.add_class::<StmtIf>()?;
        let node = m.getattr("_If")?;
        m.setattr("If", node)?;
        let names: Vec<&'static str> = crate::ranged::StmtIf::FIELD_NAMES.to_vec();
        let fields = PyTuple::new(py, names);
        node.setattr("_fields", fields)?;
    }

    StmtWith::py_type_cell().get_or_init(|| ast_module.getattr("With").unwrap().into_py(py));

    {
        m.add_class::<StmtWith>()?;
        let node = m.getattr("_With")?;
        m.setattr("With", node)?;
        let names: Vec<&'static str> = crate::ranged::StmtWith::FIELD_NAMES.to_vec();
        let fields = PyTuple::new(py, names);
        node.setattr("_fields", fields)?;
    }

    StmtAsyncWith::py_type_cell()
        .get_or_init(|| ast_module.getattr("AsyncWith").unwrap().into_py(py));

    {
        m.add_class::<StmtAsyncWith>()?;
        let node = m.getattr("_AsyncWith")?;
        m.setattr("AsyncWith", node)?;
        let names: Vec<&'static str> = crate::ranged::StmtAsyncWith::FIELD_NAMES.to_vec();
        let fields = PyTuple::new(py, names);
        node.setattr("_fields", fields)?;
    }

    StmtMatch::py_type_cell().get_or_init(|| ast_module.getattr("Match").unwrap().into_py(py));

    {
        m.add_class::<StmtMatch>()?;
        let node = m.getattr("_Match")?;
        m.setattr("Match", node)?;
        let names: Vec<&'static str> = crate::ranged::StmtMatch::FIELD_NAMES.to_vec();
        let fields = PyTuple::new(py, names);
        node.setattr("_fields", fields)?;
    }

    StmtRaise::py_type_cell().get_or_init(|| ast_module.getattr("Raise").unwrap().into_py(py));

    {
        m.add_class::<StmtRaise>()?;
        let node = m.getattr("_Raise")?;
        m.setattr("Raise", node)?;
        let names: Vec<&'static str> = crate::ranged::StmtRaise::FIELD_NAMES.to_vec();
        let fields = PyTuple::new(py, names);
        node.setattr("_fields", fields)?;
    }

    StmtTry::py_type_cell().get_or_init(|| ast_module.getattr("Try").unwrap().into_py(py));

    {
        m.add_class::<StmtTry>()?;
        let node = m.getattr("_Try")?;
        m.setattr("Try", node)?;
        let names: Vec<&'static str> = crate::ranged::StmtTry::FIELD_NAMES.to_vec();
        let fields = PyTuple::new(py, names);
        node.setattr("_fields", fields)?;
    }

    StmtTryStar::py_type_cell().get_or_init(|| ast_module.getattr("TryStar").unwrap().into_py(py));

    {
        m.add_class::<StmtTryStar>()?;
        let node = m.getattr("_TryStar")?;
        m.setattr("TryStar", node)?;
        let names: Vec<&'static str> = crate::ranged::StmtTryStar::FIELD_NAMES.to_vec();
        let fields = PyTuple::new(py, names);
        node.setattr("_fields", fields)?;
    }

    StmtAssert::py_type_cell().get_or_init(|| ast_module.getattr("Assert").unwrap().into_py(py));

    {
        m.add_class::<StmtAssert>()?;
        let node = m.getattr("_Assert")?;
        m.setattr("Assert", node)?;
        let names: Vec<&'static str> = crate::ranged::StmtAssert::FIELD_NAMES.to_vec();
        let fields = PyTuple::new(py, names);
        node.setattr("_fields", fields)?;
    }

    StmtImport::py_type_cell().get_or_init(|| ast_module.getattr("Import").unwrap().into_py(py));

    {
        m.add_class::<StmtImport>()?;
        let node = m.getattr("_Import")?;
        m.setattr("Import", node)?;
        let names: Vec<&'static str> = crate::ranged::StmtImport::FIELD_NAMES.to_vec();
        let fields = PyTuple::new(py, names);
        node.setattr("_fields", fields)?;
    }

    StmtImportFrom::py_type_cell()
        .get_or_init(|| ast_module.getattr("ImportFrom").unwrap().into_py(py));

    {
        m.add_class::<StmtImportFrom>()?;
        let node = m.getattr("_ImportFrom")?;
        m.setattr("ImportFrom", node)?;
        let names: Vec<&'static str> = crate::ranged::StmtImportFrom::FIELD_NAMES.to_vec();
        let fields = PyTuple::new(py, names);
        node.setattr("_fields", fields)?;
    }

    StmtGlobal::py_type_cell().get_or_init(|| ast_module.getattr("Global").unwrap().into_py(py));

    {
        m.add_class::<StmtGlobal>()?;
        let node = m.getattr("_Global")?;
        m.setattr("Global", node)?;
        let names: Vec<&'static str> = crate::ranged::StmtGlobal::FIELD_NAMES.to_vec();
        let fields = PyTuple::new(py, names);
        node.setattr("_fields", fields)?;
    }

    StmtNonlocal::py_type_cell()
        .get_or_init(|| ast_module.getattr("Nonlocal").unwrap().into_py(py));

    {
        m.add_class::<StmtNonlocal>()?;
        let node = m.getattr("_Nonlocal")?;
        m.setattr("Nonlocal", node)?;
        let names: Vec<&'static str> = crate::ranged::StmtNonlocal::FIELD_NAMES.to_vec();
        let fields = PyTuple::new(py, names);
        node.setattr("_fields", fields)?;
    }

    StmtExpr::py_type_cell().get_or_init(|| ast_module.getattr("Expr").unwrap().into_py(py));

    {
        m.add_class::<StmtExpr>()?;
        let node = m.getattr("_Expr")?;
        m.setattr("Expr", node)?;
        let names: Vec<&'static str> = crate::ranged::StmtExpr::FIELD_NAMES.to_vec();
        let fields = PyTuple::new(py, names);
        node.setattr("_fields", fields)?;
    }

    StmtPass::py_type_cell().get_or_init(|| ast_module.getattr("Pass").unwrap().into_py(py));

    {
        m.add_class::<StmtPass>()?;
        let node = m.getattr("_Pass")?;
        m.setattr("Pass", node)?;
        let names: Vec<&'static str> = crate::ranged::StmtPass::FIELD_NAMES.to_vec();
        let fields = PyTuple::new(py, names);
        node.setattr("_fields", fields)?;
    }

    StmtBreak::py_type_cell().get_or_init(|| ast_module.getattr("Break").unwrap().into_py(py));

    {
        m.add_class::<StmtBreak>()?;
        let node = m.getattr("_Break")?;
        m.setattr("Break", node)?;
        let names: Vec<&'static str> = crate::ranged::StmtBreak::FIELD_NAMES.to_vec();
        let fields = PyTuple::new(py, names);
        node.setattr("_fields", fields)?;
    }

    StmtContinue::py_type_cell()
        .get_or_init(|| ast_module.getattr("Continue").unwrap().into_py(py));

    {
        m.add_class::<StmtContinue>()?;
        let node = m.getattr("_Continue")?;
        m.setattr("Continue", node)?;
        let names: Vec<&'static str> = crate::ranged::StmtContinue::FIELD_NAMES.to_vec();
        let fields = PyTuple::new(py, names);
        node.setattr("_fields", fields)?;
    }

    Expr::py_type_cell().get_or_init(|| {
        ast_module
            .getattr("expr")
            .unwrap()
            .call0()
            .unwrap()
            .into_py(py)
    });

    ExprBoolOp::py_type_cell().get_or_init(|| ast_module.getattr("BoolOp").unwrap().into_py(py));

    {
        m.add_class::<ExprBoolOp>()?;
        let node = m.getattr("_BoolOp")?;
        m.setattr("BoolOp", node)?;
        let names: Vec<&'static str> = crate::ranged::ExprBoolOp::FIELD_NAMES.to_vec();
        let fields = PyTuple::new(py, names);
        node.setattr("_fields", fields)?;
    }

    ExprNamedExpr::py_type_cell()
        .get_or_init(|| ast_module.getattr("NamedExpr").unwrap().into_py(py));

    {
        m.add_class::<ExprNamedExpr>()?;
        let node = m.getattr("_NamedExpr")?;
        m.setattr("NamedExpr", node)?;
        let names: Vec<&'static str> = crate::ranged::ExprNamedExpr::FIELD_NAMES.to_vec();
        let fields = PyTuple::new(py, names);
        node.setattr("_fields", fields)?;
    }

    ExprBinOp::py_type_cell().get_or_init(|| ast_module.getattr("BinOp").unwrap().into_py(py));

    {
        m.add_class::<ExprBinOp>()?;
        let node = m.getattr("_BinOp")?;
        m.setattr("BinOp", node)?;
        let names: Vec<&'static str> = crate::ranged::ExprBinOp::FIELD_NAMES.to_vec();
        let fields = PyTuple::new(py, names);
        node.setattr("_fields", fields)?;
    }

    ExprUnaryOp::py_type_cell().get_or_init(|| ast_module.getattr("UnaryOp").unwrap().into_py(py));

    {
        m.add_class::<ExprUnaryOp>()?;
        let node = m.getattr("_UnaryOp")?;
        m.setattr("UnaryOp", node)?;
        let names: Vec<&'static str> = crate::ranged::ExprUnaryOp::FIELD_NAMES.to_vec();
        let fields = PyTuple::new(py, names);
        node.setattr("_fields", fields)?;
    }

    ExprLambda::py_type_cell().get_or_init(|| ast_module.getattr("Lambda").unwrap().into_py(py));

    {
        m.add_class::<ExprLambda>()?;
        let node = m.getattr("_Lambda")?;
        m.setattr("Lambda", node)?;
        let names: Vec<&'static str> = crate::ranged::ExprLambda::FIELD_NAMES.to_vec();
        let fields = PyTuple::new(py, names);
        node.setattr("_fields", fields)?;
    }

    ExprIfExp::py_type_cell().get_or_init(|| ast_module.getattr("IfExp").unwrap().into_py(py));

    {
        m.add_class::<ExprIfExp>()?;
        let node = m.getattr("_IfExp")?;
        m.setattr("IfExp", node)?;
        let names: Vec<&'static str> = crate::ranged::ExprIfExp::FIELD_NAMES.to_vec();
        let fields = PyTuple::new(py, names);
        node.setattr("_fields", fields)?;
    }

    ExprDict::py_type_cell().get_or_init(|| ast_module.getattr("Dict").unwrap().into_py(py));

    {
        m.add_class::<ExprDict>()?;
        let node = m.getattr("_Dict")?;
        m.setattr("Dict", node)?;
        let names: Vec<&'static str> = crate::ranged::ExprDict::FIELD_NAMES.to_vec();
        let fields = PyTuple::new(py, names);
        node.setattr("_fields", fields)?;
    }

    ExprSet::py_type_cell().get_or_init(|| ast_module.getattr("Set").unwrap().into_py(py));

    {
        m.add_class::<ExprSet>()?;
        let node = m.getattr("_Set")?;
        m.setattr("Set", node)?;
        let names: Vec<&'static str> = crate::ranged::ExprSet::FIELD_NAMES.to_vec();
        let fields = PyTuple::new(py, names);
        node.setattr("_fields", fields)?;
    }

    ExprListComp::py_type_cell()
        .get_or_init(|| ast_module.getattr("ListComp").unwrap().into_py(py));

    {
        m.add_class::<ExprListComp>()?;
        let node = m.getattr("_ListComp")?;
        m.setattr("ListComp", node)?;
        let names: Vec<&'static str> = crate::ranged::ExprListComp::FIELD_NAMES.to_vec();
        let fields = PyTuple::new(py, names);
        node.setattr("_fields", fields)?;
    }

    ExprSetComp::py_type_cell().get_or_init(|| ast_module.getattr("SetComp").unwrap().into_py(py));

    {
        m.add_class::<ExprSetComp>()?;
        let node = m.getattr("_SetComp")?;
        m.setattr("SetComp", node)?;
        let names: Vec<&'static str> = crate::ranged::ExprSetComp::FIELD_NAMES.to_vec();
        let fields = PyTuple::new(py, names);
        node.setattr("_fields", fields)?;
    }

    ExprDictComp::py_type_cell()
        .get_or_init(|| ast_module.getattr("DictComp").unwrap().into_py(py));

    {
        m.add_class::<ExprDictComp>()?;
        let node = m.getattr("_DictComp")?;
        m.setattr("DictComp", node)?;
        let names: Vec<&'static str> = crate::ranged::ExprDictComp::FIELD_NAMES.to_vec();
        let fields = PyTuple::new(py, names);
        node.setattr("_fields", fields)?;
    }

    ExprGeneratorExp::py_type_cell()
        .get_or_init(|| ast_module.getattr("GeneratorExp").unwrap().into_py(py));

    {
        m.add_class::<ExprGeneratorExp>()?;
        let node = m.getattr("_GeneratorExp")?;
        m.setattr("GeneratorExp", node)?;
        let names: Vec<&'static str> = crate::ranged::ExprGeneratorExp::FIELD_NAMES.to_vec();
        let fields = PyTuple::new(py, names);
        node.setattr("_fields", fields)?;
    }

    ExprAwait::py_type_cell().get_or_init(|| ast_module.getattr("Await").unwrap().into_py(py));

    {
        m.add_class::<ExprAwait>()?;
        let node = m.getattr("_Await")?;
        m.setattr("Await", node)?;
        let names: Vec<&'static str> = crate::ranged::ExprAwait::FIELD_NAMES.to_vec();
        let fields = PyTuple::new(py, names);
        node.setattr("_fields", fields)?;
    }

    ExprYield::py_type_cell().get_or_init(|| ast_module.getattr("Yield").unwrap().into_py(py));

    {
        m.add_class::<ExprYield>()?;
        let node = m.getattr("_Yield")?;
        m.setattr("Yield", node)?;
        let names: Vec<&'static str> = crate::ranged::ExprYield::FIELD_NAMES.to_vec();
        let fields = PyTuple::new(py, names);
        node.setattr("_fields", fields)?;
    }

    ExprYieldFrom::py_type_cell()
        .get_or_init(|| ast_module.getattr("YieldFrom").unwrap().into_py(py));

    {
        m.add_class::<ExprYieldFrom>()?;
        let node = m.getattr("_YieldFrom")?;
        m.setattr("YieldFrom", node)?;
        let names: Vec<&'static str> = crate::ranged::ExprYieldFrom::FIELD_NAMES.to_vec();
        let fields = PyTuple::new(py, names);
        node.setattr("_fields", fields)?;
    }

    ExprCompare::py_type_cell().get_or_init(|| ast_module.getattr("Compare").unwrap().into_py(py));

    {
        m.add_class::<ExprCompare>()?;
        let node = m.getattr("_Compare")?;
        m.setattr("Compare", node)?;
        let names: Vec<&'static str> = crate::ranged::ExprCompare::FIELD_NAMES.to_vec();
        let fields = PyTuple::new(py, names);
        node.setattr("_fields", fields)?;
    }

    ExprCall::py_type_cell().get_or_init(|| ast_module.getattr("Call").unwrap().into_py(py));

    {
        m.add_class::<ExprCall>()?;
        let node = m.getattr("_Call")?;
        m.setattr("Call", node)?;
        let names: Vec<&'static str> = crate::ranged::ExprCall::FIELD_NAMES.to_vec();
        let fields = PyTuple::new(py, names);
        node.setattr("_fields", fields)?;
    }

    ExprFormattedValue::py_type_cell()
        .get_or_init(|| ast_module.getattr("FormattedValue").unwrap().into_py(py));

    {
        m.add_class::<ExprFormattedValue>()?;
        let node = m.getattr("_FormattedValue")?;
        m.setattr("FormattedValue", node)?;
        let names: Vec<&'static str> = crate::ranged::ExprFormattedValue::FIELD_NAMES.to_vec();
        let fields = PyTuple::new(py, names);
        node.setattr("_fields", fields)?;
    }

    ExprJoinedStr::py_type_cell()
        .get_or_init(|| ast_module.getattr("JoinedStr").unwrap().into_py(py));

    {
        m.add_class::<ExprJoinedStr>()?;
        let node = m.getattr("_JoinedStr")?;
        m.setattr("JoinedStr", node)?;
        let names: Vec<&'static str> = crate::ranged::ExprJoinedStr::FIELD_NAMES.to_vec();
        let fields = PyTuple::new(py, names);
        node.setattr("_fields", fields)?;
    }

    ExprConstant::py_type_cell()
        .get_or_init(|| ast_module.getattr("Constant").unwrap().into_py(py));

    {
        m.add_class::<ExprConstant>()?;
        let node = m.getattr("_Constant")?;
        m.setattr("Constant", node)?;
        let names: Vec<&'static str> = crate::ranged::ExprConstant::FIELD_NAMES.to_vec();
        let fields = PyTuple::new(py, names);
        node.setattr("_fields", fields)?;
    }

    ExprAttribute::py_type_cell()
        .get_or_init(|| ast_module.getattr("Attribute").unwrap().into_py(py));

    {
        m.add_class::<ExprAttribute>()?;
        let node = m.getattr("_Attribute")?;
        m.setattr("Attribute", node)?;
        let names: Vec<&'static str> = crate::ranged::ExprAttribute::FIELD_NAMES.to_vec();
        let fields = PyTuple::new(py, names);
        node.setattr("_fields", fields)?;
    }

    ExprSubscript::py_type_cell()
        .get_or_init(|| ast_module.getattr("Subscript").unwrap().into_py(py));

    {
        m.add_class::<ExprSubscript>()?;
        let node = m.getattr("_Subscript")?;
        m.setattr("Subscript", node)?;
        let names: Vec<&'static str> = crate::ranged::ExprSubscript::FIELD_NAMES.to_vec();
        let fields = PyTuple::new(py, names);
        node.setattr("_fields", fields)?;
    }

    ExprStarred::py_type_cell().get_or_init(|| ast_module.getattr("Starred").unwrap().into_py(py));

    {
        m.add_class::<ExprStarred>()?;
        let node = m.getattr("_Starred")?;
        m.setattr("Starred", node)?;
        let names: Vec<&'static str> = crate::ranged::ExprStarred::FIELD_NAMES.to_vec();
        let fields = PyTuple::new(py, names);
        node.setattr("_fields", fields)?;
    }

    ExprName::py_type_cell().get_or_init(|| ast_module.getattr("Name").unwrap().into_py(py));

    {
        m.add_class::<ExprName>()?;
        let node = m.getattr("_Name")?;
        m.setattr("Name", node)?;
        let names: Vec<&'static str> = crate::ranged::ExprName::FIELD_NAMES.to_vec();
        let fields = PyTuple::new(py, names);
        node.setattr("_fields", fields)?;
    }

    ExprList::py_type_cell().get_or_init(|| ast_module.getattr("List").unwrap().into_py(py));

    {
        m.add_class::<ExprList>()?;
        let node = m.getattr("_List")?;
        m.setattr("List", node)?;
        let names: Vec<&'static str> = crate::ranged::ExprList::FIELD_NAMES.to_vec();
        let fields = PyTuple::new(py, names);
        node.setattr("_fields", fields)?;
    }

    ExprTuple::py_type_cell().get_or_init(|| ast_module.getattr("Tuple").unwrap().into_py(py));

    {
        m.add_class::<ExprTuple>()?;
        let node = m.getattr("_Tuple")?;
        m.setattr("Tuple", node)?;
        let names: Vec<&'static str> = crate::ranged::ExprTuple::FIELD_NAMES.to_vec();
        let fields = PyTuple::new(py, names);
        node.setattr("_fields", fields)?;
    }

    ExprSlice::py_type_cell().get_or_init(|| ast_module.getattr("Slice").unwrap().into_py(py));

    {
        m.add_class::<ExprSlice>()?;
        let node = m.getattr("_Slice")?;
        m.setattr("Slice", node)?;
        let names: Vec<&'static str> = crate::ranged::ExprSlice::FIELD_NAMES.to_vec();
        let fields = PyTuple::new(py, names);
        node.setattr("_fields", fields)?;
    }

    ExprContext::py_type_cell().get_or_init(|| {
        ast_module
            .getattr("expr_context")
            .unwrap()
            .call0()
            .unwrap()
            .into_py(py)
    });

    ExprContextLoad::py_type_cell().get_or_init(|| {
        ast_module
            .getattr("Load")
            .unwrap()
            .call0()
            .unwrap()
            .into_py(py)
    });

    ExprContextStore::py_type_cell().get_or_init(|| {
        ast_module
            .getattr("Store")
            .unwrap()
            .call0()
            .unwrap()
            .into_py(py)
    });

    ExprContextDel::py_type_cell().get_or_init(|| {
        ast_module
            .getattr("Del")
            .unwrap()
            .call0()
            .unwrap()
            .into_py(py)
    });

    Boolop::py_type_cell().get_or_init(|| {
        ast_module
            .getattr("boolop")
            .unwrap()
            .call0()
            .unwrap()
            .into_py(py)
    });

    BoolopAnd::py_type_cell().get_or_init(|| {
        ast_module
            .getattr("And")
            .unwrap()
            .call0()
            .unwrap()
            .into_py(py)
    });

    BoolopOr::py_type_cell().get_or_init(|| {
        ast_module
            .getattr("Or")
            .unwrap()
            .call0()
            .unwrap()
            .into_py(py)
    });

    Operator::py_type_cell().get_or_init(|| {
        ast_module
            .getattr("operator")
            .unwrap()
            .call0()
            .unwrap()
            .into_py(py)
    });

    OperatorAdd::py_type_cell().get_or_init(|| {
        ast_module
            .getattr("Add")
            .unwrap()
            .call0()
            .unwrap()
            .into_py(py)
    });

    OperatorSub::py_type_cell().get_or_init(|| {
        ast_module
            .getattr("Sub")
            .unwrap()
            .call0()
            .unwrap()
            .into_py(py)
    });

    OperatorMult::py_type_cell().get_or_init(|| {
        ast_module
            .getattr("Mult")
            .unwrap()
            .call0()
            .unwrap()
            .into_py(py)
    });

    OperatorMatMult::py_type_cell().get_or_init(|| {
        ast_module
            .getattr("MatMult")
            .unwrap()
            .call0()
            .unwrap()
            .into_py(py)
    });

    OperatorDiv::py_type_cell().get_or_init(|| {
        ast_module
            .getattr("Div")
            .unwrap()
            .call0()
            .unwrap()
            .into_py(py)
    });

    OperatorMod::py_type_cell().get_or_init(|| {
        ast_module
            .getattr("Mod")
            .unwrap()
            .call0()
            .unwrap()
            .into_py(py)
    });

    OperatorPow::py_type_cell().get_or_init(|| {
        ast_module
            .getattr("Pow")
            .unwrap()
            .call0()
            .unwrap()
            .into_py(py)
    });

    OperatorLShift::py_type_cell().get_or_init(|| {
        ast_module
            .getattr("LShift")
            .unwrap()
            .call0()
            .unwrap()
            .into_py(py)
    });

    OperatorRShift::py_type_cell().get_or_init(|| {
        ast_module
            .getattr("RShift")
            .unwrap()
            .call0()
            .unwrap()
            .into_py(py)
    });

    OperatorBitOr::py_type_cell().get_or_init(|| {
        ast_module
            .getattr("BitOr")
            .unwrap()
            .call0()
            .unwrap()
            .into_py(py)
    });

    OperatorBitXor::py_type_cell().get_or_init(|| {
        ast_module
            .getattr("BitXor")
            .unwrap()
            .call0()
            .unwrap()
            .into_py(py)
    });

    OperatorBitAnd::py_type_cell().get_or_init(|| {
        ast_module
            .getattr("BitAnd")
            .unwrap()
            .call0()
            .unwrap()
            .into_py(py)
    });

    OperatorFloorDiv::py_type_cell().get_or_init(|| {
        ast_module
            .getattr("FloorDiv")
            .unwrap()
            .call0()
            .unwrap()
            .into_py(py)
    });

    Unaryop::py_type_cell().get_or_init(|| {
        ast_module
            .getattr("unaryop")
            .unwrap()
            .call0()
            .unwrap()
            .into_py(py)
    });

    UnaryopInvert::py_type_cell().get_or_init(|| {
        ast_module
            .getattr("Invert")
            .unwrap()
            .call0()
            .unwrap()
            .into_py(py)
    });

    UnaryopNot::py_type_cell().get_or_init(|| {
        ast_module
            .getattr("Not")
            .unwrap()
            .call0()
            .unwrap()
            .into_py(py)
    });

    UnaryopUAdd::py_type_cell().get_or_init(|| {
        ast_module
            .getattr("UAdd")
            .unwrap()
            .call0()
            .unwrap()
            .into_py(py)
    });

    UnaryopUSub::py_type_cell().get_or_init(|| {
        ast_module
            .getattr("USub")
            .unwrap()
            .call0()
            .unwrap()
            .into_py(py)
    });

    Cmpop::py_type_cell().get_or_init(|| {
        ast_module
            .getattr("cmpop")
            .unwrap()
            .call0()
            .unwrap()
            .into_py(py)
    });

    CmpopEq::py_type_cell().get_or_init(|| {
        ast_module
            .getattr("Eq")
            .unwrap()
            .call0()
            .unwrap()
            .into_py(py)
    });

    CmpopNotEq::py_type_cell().get_or_init(|| {
        ast_module
            .getattr("NotEq")
            .unwrap()
            .call0()
            .unwrap()
            .into_py(py)
    });

    CmpopLt::py_type_cell().get_or_init(|| {
        ast_module
            .getattr("Lt")
            .unwrap()
            .call0()
            .unwrap()
            .into_py(py)
    });

    CmpopLtE::py_type_cell().get_or_init(|| {
        ast_module
            .getattr("LtE")
            .unwrap()
            .call0()
            .unwrap()
            .into_py(py)
    });

    CmpopGt::py_type_cell().get_or_init(|| {
        ast_module
            .getattr("Gt")
            .unwrap()
            .call0()
            .unwrap()
            .into_py(py)
    });

    CmpopGtE::py_type_cell().get_or_init(|| {
        ast_module
            .getattr("GtE")
            .unwrap()
            .call0()
            .unwrap()
            .into_py(py)
    });

    CmpopIs::py_type_cell().get_or_init(|| {
        ast_module
            .getattr("Is")
            .unwrap()
            .call0()
            .unwrap()
            .into_py(py)
    });

    CmpopIsNot::py_type_cell().get_or_init(|| {
        ast_module
            .getattr("IsNot")
            .unwrap()
            .call0()
            .unwrap()
            .into_py(py)
    });

    CmpopIn::py_type_cell().get_or_init(|| {
        ast_module
            .getattr("In")
            .unwrap()
            .call0()
            .unwrap()
            .into_py(py)
    });

    CmpopNotIn::py_type_cell().get_or_init(|| {
        ast_module
            .getattr("NotIn")
            .unwrap()
            .call0()
            .unwrap()
            .into_py(py)
    });

    Comprehension::py_type_cell()
        .get_or_init(|| ast_module.getattr("comprehension").unwrap().into_py(py));

    {
        m.add_class::<Comprehension>()?;
        let node = m.getattr("_comprehension")?;
        m.setattr("comprehension", node)?;
        let names: Vec<&'static str> = crate::ranged::Comprehension::FIELD_NAMES.to_vec();
        let fields = PyTuple::new(py, names);
        node.setattr("_fields", fields)?;
    }

    Excepthandler::py_type_cell().get_or_init(|| {
        ast_module
            .getattr("excepthandler")
            .unwrap()
            .call0()
            .unwrap()
            .into_py(py)
    });

    ExcepthandlerExceptHandler::py_type_cell()
        .get_or_init(|| ast_module.getattr("ExceptHandler").unwrap().into_py(py));

    {
        m.add_class::<ExcepthandlerExceptHandler>()?;
        let node = m.getattr("_ExceptHandler")?;
        m.setattr("ExceptHandler", node)?;
        let names: Vec<&'static str> =
            crate::ranged::ExcepthandlerExceptHandler::FIELD_NAMES.to_vec();
        let fields = PyTuple::new(py, names);
        node.setattr("_fields", fields)?;
    }

    Arguments::py_type_cell().get_or_init(|| ast_module.getattr("arguments").unwrap().into_py(py));

    {
        m.add_class::<Arguments>()?;
        let node = m.getattr("_arguments")?;
        m.setattr("arguments", node)?;
        let names: Vec<&'static str> = crate::ranged::Arguments::FIELD_NAMES.to_vec();
        let fields = PyTuple::new(py, names);
        node.setattr("_fields", fields)?;
    }

    Arg::py_type_cell().get_or_init(|| ast_module.getattr("arg").unwrap().into_py(py));

    {
        m.add_class::<Arg>()?;
        let node = m.getattr("_arg")?;
        m.setattr("arg", node)?;
        let names: Vec<&'static str> = crate::ranged::Arg::FIELD_NAMES.to_vec();
        let fields = PyTuple::new(py, names);
        node.setattr("_fields", fields)?;
    }

    Keyword::py_type_cell().get_or_init(|| ast_module.getattr("keyword").unwrap().into_py(py));

    {
        m.add_class::<Keyword>()?;
        let node = m.getattr("_keyword")?;
        m.setattr("keyword", node)?;
        let names: Vec<&'static str> = crate::ranged::Keyword::FIELD_NAMES.to_vec();
        let fields = PyTuple::new(py, names);
        node.setattr("_fields", fields)?;
    }

    Alias::py_type_cell().get_or_init(|| ast_module.getattr("alias").unwrap().into_py(py));

    {
        m.add_class::<Alias>()?;
        let node = m.getattr("_alias")?;
        m.setattr("alias", node)?;
        let names: Vec<&'static str> = crate::ranged::Alias::FIELD_NAMES.to_vec();
        let fields = PyTuple::new(py, names);
        node.setattr("_fields", fields)?;
    }

    Withitem::py_type_cell().get_or_init(|| ast_module.getattr("withitem").unwrap().into_py(py));

    {
        m.add_class::<Withitem>()?;
        let node = m.getattr("_withitem")?;
        m.setattr("withitem", node)?;
        let names: Vec<&'static str> = crate::ranged::Withitem::FIELD_NAMES.to_vec();
        let fields = PyTuple::new(py, names);
        node.setattr("_fields", fields)?;
    }

    MatchCase::py_type_cell().get_or_init(|| ast_module.getattr("match_case").unwrap().into_py(py));

    {
        m.add_class::<MatchCase>()?;
        let node = m.getattr("_match_case")?;
        m.setattr("match_case", node)?;
        let names: Vec<&'static str> = crate::ranged::MatchCase::FIELD_NAMES.to_vec();
        let fields = PyTuple::new(py, names);
        node.setattr("_fields", fields)?;
    }

    Pattern::py_type_cell().get_or_init(|| {
        ast_module
            .getattr("pattern")
            .unwrap()
            .call0()
            .unwrap()
            .into_py(py)
    });

    PatternMatchValue::py_type_cell()
        .get_or_init(|| ast_module.getattr("MatchValue").unwrap().into_py(py));

    {
        m.add_class::<PatternMatchValue>()?;
        let node = m.getattr("_MatchValue")?;
        m.setattr("MatchValue", node)?;
        let names: Vec<&'static str> = crate::ranged::PatternMatchValue::FIELD_NAMES.to_vec();
        let fields = PyTuple::new(py, names);
        node.setattr("_fields", fields)?;
    }

    PatternMatchSingleton::py_type_cell()
        .get_or_init(|| ast_module.getattr("MatchSingleton").unwrap().into_py(py));

    {
        m.add_class::<PatternMatchSingleton>()?;
        let node = m.getattr("_MatchSingleton")?;
        m.setattr("MatchSingleton", node)?;
        let names: Vec<&'static str> = crate::ranged::PatternMatchSingleton::FIELD_NAMES.to_vec();
        let fields = PyTuple::new(py, names);
        node.setattr("_fields", fields)?;
    }

    PatternMatchSequence::py_type_cell()
        .get_or_init(|| ast_module.getattr("MatchSequence").unwrap().into_py(py));

    {
        m.add_class::<PatternMatchSequence>()?;
        let node = m.getattr("_MatchSequence")?;
        m.setattr("MatchSequence", node)?;
        let names: Vec<&'static str> = crate::ranged::PatternMatchSequence::FIELD_NAMES.to_vec();
        let fields = PyTuple::new(py, names);
        node.setattr("_fields", fields)?;
    }

    PatternMatchMapping::py_type_cell()
        .get_or_init(|| ast_module.getattr("MatchMapping").unwrap().into_py(py));

    {
        m.add_class::<PatternMatchMapping>()?;
        let node = m.getattr("_MatchMapping")?;
        m.setattr("MatchMapping", node)?;
        let names: Vec<&'static str> = crate::ranged::PatternMatchMapping::FIELD_NAMES.to_vec();
        let fields = PyTuple::new(py, names);
        node.setattr("_fields", fields)?;
    }

    PatternMatchClass::py_type_cell()
        .get_or_init(|| ast_module.getattr("MatchClass").unwrap().into_py(py));

    {
        m.add_class::<PatternMatchClass>()?;
        let node = m.getattr("_MatchClass")?;
        m.setattr("MatchClass", node)?;
        let names: Vec<&'static str> = crate::ranged::PatternMatchClass::FIELD_NAMES.to_vec();
        let fields = PyTuple::new(py, names);
        node.setattr("_fields", fields)?;
    }

    PatternMatchStar::py_type_cell()
        .get_or_init(|| ast_module.getattr("MatchStar").unwrap().into_py(py));

    {
        m.add_class::<PatternMatchStar>()?;
        let node = m.getattr("_MatchStar")?;
        m.setattr("MatchStar", node)?;
        let names: Vec<&'static str> = crate::ranged::PatternMatchStar::FIELD_NAMES.to_vec();
        let fields = PyTuple::new(py, names);
        node.setattr("_fields", fields)?;
    }

    PatternMatchAs::py_type_cell()
        .get_or_init(|| ast_module.getattr("MatchAs").unwrap().into_py(py));

    {
        m.add_class::<PatternMatchAs>()?;
        let node = m.getattr("_MatchAs")?;
        m.setattr("MatchAs", node)?;
        let names: Vec<&'static str> = crate::ranged::PatternMatchAs::FIELD_NAMES.to_vec();
        let fields = PyTuple::new(py, names);
        node.setattr("_fields", fields)?;
    }

    PatternMatchOr::py_type_cell()
        .get_or_init(|| ast_module.getattr("MatchOr").unwrap().into_py(py));

    {
        m.add_class::<PatternMatchOr>()?;
        let node = m.getattr("_MatchOr")?;
        m.setattr("MatchOr", node)?;
        let names: Vec<&'static str> = crate::ranged::PatternMatchOr::FIELD_NAMES.to_vec();
        let fields = PyTuple::new(py, names);
        node.setattr("_fields", fields)?;
    }

    TypeIgnore::py_type_cell().get_or_init(|| {
        ast_module
            .getattr("type_ignore")
            .unwrap()
            .call0()
            .unwrap()
            .into_py(py)
    });

    TypeIgnoreTypeIgnore::py_type_cell()
        .get_or_init(|| ast_module.getattr("TypeIgnore").unwrap().into_py(py));

    {
        m.add_class::<TypeIgnoreTypeIgnore>()?;
        let node = m.getattr("_TypeIgnore")?;
        m.setattr("TypeIgnore", node)?;
        let names: Vec<&'static str> = crate::ranged::TypeIgnoreTypeIgnore::FIELD_NAMES.to_vec();
        let fields = PyTuple::new(py, names);
        node.setattr("_fields", fields)?;
    }

    Ok(())
}
