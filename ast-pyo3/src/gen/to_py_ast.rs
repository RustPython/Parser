// File automatically generated by ast/asdl_rs.py.

impl<R> PyNode for ast::Mod<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> PyNode for ast::ModModule<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> PyNode for ast::ModInteractive<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> PyNode for ast::ModExpression<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> PyNode for ast::ModFunctionType<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> PyNode for ast::Stmt<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> PyNode for ast::StmtFunctionDef<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> PyNode for ast::StmtAsyncFunctionDef<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> PyNode for ast::StmtClassDef<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> PyNode for ast::StmtReturn<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> PyNode for ast::StmtDelete<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> PyNode for ast::StmtAssign<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> PyNode for ast::StmtAugAssign<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> PyNode for ast::StmtAnnAssign<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> PyNode for ast::StmtFor<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> PyNode for ast::StmtAsyncFor<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> PyNode for ast::StmtWhile<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> PyNode for ast::StmtIf<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> PyNode for ast::StmtWith<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> PyNode for ast::StmtAsyncWith<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> PyNode for ast::StmtMatch<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> PyNode for ast::StmtRaise<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> PyNode for ast::StmtTry<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> PyNode for ast::StmtTryStar<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> PyNode for ast::StmtAssert<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> PyNode for ast::StmtImport<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> PyNode for ast::StmtImportFrom<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> PyNode for ast::StmtGlobal<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> PyNode for ast::StmtNonlocal<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> PyNode for ast::StmtExpr<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> PyNode for ast::StmtPass<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> PyNode for ast::StmtBreak<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> PyNode for ast::StmtContinue<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> PyNode for ast::Expr<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> PyNode for ast::ExprBoolOp<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> PyNode for ast::ExprNamedExpr<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> PyNode for ast::ExprBinOp<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> PyNode for ast::ExprUnaryOp<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> PyNode for ast::ExprLambda<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> PyNode for ast::ExprIfExp<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> PyNode for ast::ExprDict<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> PyNode for ast::ExprSet<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> PyNode for ast::ExprListComp<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> PyNode for ast::ExprSetComp<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> PyNode for ast::ExprDictComp<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> PyNode for ast::ExprGeneratorExp<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> PyNode for ast::ExprAwait<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> PyNode for ast::ExprYield<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> PyNode for ast::ExprYieldFrom<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> PyNode for ast::ExprCompare<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> PyNode for ast::ExprCall<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> PyNode for ast::ExprFormattedValue<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> PyNode for ast::ExprJoinedStr<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> PyNode for ast::ExprConstant<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> PyNode for ast::ExprAttribute<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> PyNode for ast::ExprSubscript<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> PyNode for ast::ExprStarred<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> PyNode for ast::ExprName<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> PyNode for ast::ExprList<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> PyNode for ast::ExprTuple<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> PyNode for ast::ExprSlice<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl PyNode for ast::ExprContext {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl PyNode for ast::ExprContextLoad {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl PyNode for ast::ExprContextStore {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl PyNode for ast::ExprContextDel {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl PyNode for ast::BoolOp {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl PyNode for ast::BoolOpAnd {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl PyNode for ast::BoolOpOr {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl PyNode for ast::Operator {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl PyNode for ast::OperatorAdd {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl PyNode for ast::OperatorSub {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl PyNode for ast::OperatorMult {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl PyNode for ast::OperatorMatMult {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl PyNode for ast::OperatorDiv {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl PyNode for ast::OperatorMod {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl PyNode for ast::OperatorPow {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl PyNode for ast::OperatorLShift {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl PyNode for ast::OperatorRShift {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl PyNode for ast::OperatorBitOr {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl PyNode for ast::OperatorBitXor {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl PyNode for ast::OperatorBitAnd {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl PyNode for ast::OperatorFloorDiv {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl PyNode for ast::UnaryOp {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl PyNode for ast::UnaryOpInvert {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl PyNode for ast::UnaryOpNot {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl PyNode for ast::UnaryOpUAdd {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl PyNode for ast::UnaryOpUSub {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl PyNode for ast::CmpOp {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl PyNode for ast::CmpOpEq {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl PyNode for ast::CmpOpNotEq {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl PyNode for ast::CmpOpLt {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl PyNode for ast::CmpOpLtE {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl PyNode for ast::CmpOpGt {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl PyNode for ast::CmpOpGtE {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl PyNode for ast::CmpOpIs {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl PyNode for ast::CmpOpIsNot {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl PyNode for ast::CmpOpIn {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl PyNode for ast::CmpOpNotIn {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> PyNode for ast::Comprehension<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> PyNode for ast::ExceptHandler<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> PyNode for ast::ExceptHandlerExceptHandler<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> PyNode for ast::PythonArguments<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> PyNode for ast::Arg<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> PyNode for ast::Keyword<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> PyNode for ast::Alias<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> PyNode for ast::WithItem<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> PyNode for ast::MatchCase<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> PyNode for ast::Pattern<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> PyNode for ast::PatternMatchValue<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> PyNode for ast::PatternMatchSingleton<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> PyNode for ast::PatternMatchSequence<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> PyNode for ast::PatternMatchMapping<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> PyNode for ast::PatternMatchClass<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> PyNode for ast::PatternMatchStar<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> PyNode for ast::PatternMatchAs<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> PyNode for ast::PatternMatchOr<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> PyNode for ast::TypeIgnore<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl<R> PyNode for ast::TypeIgnoreTypeIgnore<R> {
    #[inline]
    fn py_type_cache() -> &'static OnceCell<(Py<PyAny>, Py<PyAny>)> {
        static PY_TYPE: OnceCell<(Py<PyAny>, Py<PyAny>)> = OnceCell::new();
        &PY_TYPE
    }
}

impl ToPyAst for ast::ExprContext {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cell = match &self {
            ast::ExprContext::Load => ast::ExprContextLoad::py_type_cache(),
            ast::ExprContext::Store => ast::ExprContextStore::py_type_cache(),
            ast::ExprContext::Del => ast::ExprContextDel::py_type_cache(),
        };
        Ok(Py::<PyAny>::as_ref(&cell.get().unwrap().1, py))
    }
}

impl ToPyAst for ast::BoolOp {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cell = match &self {
            ast::BoolOp::And => ast::BoolOpAnd::py_type_cache(),
            ast::BoolOp::Or => ast::BoolOpOr::py_type_cache(),
        };
        Ok(Py::<PyAny>::as_ref(&cell.get().unwrap().1, py))
    }
}

impl ToPyAst for ast::Operator {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cell = match &self {
            ast::Operator::Add => ast::OperatorAdd::py_type_cache(),
            ast::Operator::Sub => ast::OperatorSub::py_type_cache(),
            ast::Operator::Mult => ast::OperatorMult::py_type_cache(),
            ast::Operator::MatMult => ast::OperatorMatMult::py_type_cache(),
            ast::Operator::Div => ast::OperatorDiv::py_type_cache(),
            ast::Operator::Mod => ast::OperatorMod::py_type_cache(),
            ast::Operator::Pow => ast::OperatorPow::py_type_cache(),
            ast::Operator::LShift => ast::OperatorLShift::py_type_cache(),
            ast::Operator::RShift => ast::OperatorRShift::py_type_cache(),
            ast::Operator::BitOr => ast::OperatorBitOr::py_type_cache(),
            ast::Operator::BitXor => ast::OperatorBitXor::py_type_cache(),
            ast::Operator::BitAnd => ast::OperatorBitAnd::py_type_cache(),
            ast::Operator::FloorDiv => ast::OperatorFloorDiv::py_type_cache(),
        };
        Ok(Py::<PyAny>::as_ref(&cell.get().unwrap().1, py))
    }
}

impl ToPyAst for ast::UnaryOp {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cell = match &self {
            ast::UnaryOp::Invert => ast::UnaryOpInvert::py_type_cache(),
            ast::UnaryOp::Not => ast::UnaryOpNot::py_type_cache(),
            ast::UnaryOp::UAdd => ast::UnaryOpUAdd::py_type_cache(),
            ast::UnaryOp::USub => ast::UnaryOpUSub::py_type_cache(),
        };
        Ok(Py::<PyAny>::as_ref(&cell.get().unwrap().1, py))
    }
}

impl ToPyAst for ast::CmpOp {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cell = match &self {
            ast::CmpOp::Eq => ast::CmpOpEq::py_type_cache(),
            ast::CmpOp::NotEq => ast::CmpOpNotEq::py_type_cache(),
            ast::CmpOp::Lt => ast::CmpOpLt::py_type_cache(),
            ast::CmpOp::LtE => ast::CmpOpLtE::py_type_cache(),
            ast::CmpOp::Gt => ast::CmpOpGt::py_type_cache(),
            ast::CmpOp::GtE => ast::CmpOpGtE::py_type_cache(),
            ast::CmpOp::Is => ast::CmpOpIs::py_type_cache(),
            ast::CmpOp::IsNot => ast::CmpOpIsNot::py_type_cache(),
            ast::CmpOp::In => ast::CmpOpIn::py_type_cache(),
            ast::CmpOp::NotIn => ast::CmpOpNotIn::py_type_cache(),
        };
        Ok(Py::<PyAny>::as_ref(&cell.get().unwrap().1, py))
    }
}

impl ToPyAst for ast::Mod<TextRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let instance = match &self {
            ast::Mod::Module(cons) => cons.to_py_ast(py)?,
            ast::Mod::Interactive(cons) => cons.to_py_ast(py)?,
            ast::Mod::Expression(cons) => cons.to_py_ast(py)?,
            ast::Mod::FunctionType(cons) => cons.to_py_ast(py)?,
        };
        Ok(instance)
    }
}

impl ToPyAst for ast::ModModule<TextRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            body,
            type_ignores,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py)
            .call1((body.to_py_ast(py)?, type_ignores.to_py_ast(py)?))?;

        Ok(instance)
    }
}

impl ToPyAst for ast::ModInteractive<TextRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            body,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py).call1((body.to_py_ast(py)?,))?;

        Ok(instance)
    }
}

impl ToPyAst for ast::ModExpression<TextRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            body,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py).call1((body.to_py_ast(py)?,))?;

        Ok(instance)
    }
}

impl ToPyAst for ast::ModFunctionType<TextRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            argtypes,
            returns,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py)
            .call1((argtypes.to_py_ast(py)?, returns.to_py_ast(py)?))?;

        Ok(instance)
    }
}

impl ToPyAst for ast::Stmt<TextRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let instance = match &self {
            ast::Stmt::FunctionDef(cons) => cons.to_py_ast(py)?,
            ast::Stmt::AsyncFunctionDef(cons) => cons.to_py_ast(py)?,
            ast::Stmt::ClassDef(cons) => cons.to_py_ast(py)?,
            ast::Stmt::Return(cons) => cons.to_py_ast(py)?,
            ast::Stmt::Delete(cons) => cons.to_py_ast(py)?,
            ast::Stmt::Assign(cons) => cons.to_py_ast(py)?,
            ast::Stmt::AugAssign(cons) => cons.to_py_ast(py)?,
            ast::Stmt::AnnAssign(cons) => cons.to_py_ast(py)?,
            ast::Stmt::For(cons) => cons.to_py_ast(py)?,
            ast::Stmt::AsyncFor(cons) => cons.to_py_ast(py)?,
            ast::Stmt::While(cons) => cons.to_py_ast(py)?,
            ast::Stmt::If(cons) => cons.to_py_ast(py)?,
            ast::Stmt::With(cons) => cons.to_py_ast(py)?,
            ast::Stmt::AsyncWith(cons) => cons.to_py_ast(py)?,
            ast::Stmt::Match(cons) => cons.to_py_ast(py)?,
            ast::Stmt::Raise(cons) => cons.to_py_ast(py)?,
            ast::Stmt::Try(cons) => cons.to_py_ast(py)?,
            ast::Stmt::TryStar(cons) => cons.to_py_ast(py)?,
            ast::Stmt::Assert(cons) => cons.to_py_ast(py)?,
            ast::Stmt::Import(cons) => cons.to_py_ast(py)?,
            ast::Stmt::ImportFrom(cons) => cons.to_py_ast(py)?,
            ast::Stmt::Global(cons) => cons.to_py_ast(py)?,
            ast::Stmt::Nonlocal(cons) => cons.to_py_ast(py)?,
            ast::Stmt::Expr(cons) => cons.to_py_ast(py)?,
            ast::Stmt::Pass(cons) => cons.to_py_ast(py)?,
            ast::Stmt::Break(cons) => cons.to_py_ast(py)?,
            ast::Stmt::Continue(cons) => cons.to_py_ast(py)?,
        };
        Ok(instance)
    }
}

impl ToPyAst for ast::StmtFunctionDef<TextRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            name,
            args,
            body,
            decorator_list,
            returns,
            type_comment,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py).call1((
            name.to_py_ast(py)?,
            args.to_py_ast(py)?,
            body.to_py_ast(py)?,
            decorator_list.to_py_ast(py)?,
            returns.to_py_ast(py)?,
            type_comment.to_py_ast(py)?,
        ))?;

        Ok(instance)
    }
}

impl ToPyAst for ast::StmtAsyncFunctionDef<TextRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            name,
            args,
            body,
            decorator_list,
            returns,
            type_comment,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py).call1((
            name.to_py_ast(py)?,
            args.to_py_ast(py)?,
            body.to_py_ast(py)?,
            decorator_list.to_py_ast(py)?,
            returns.to_py_ast(py)?,
            type_comment.to_py_ast(py)?,
        ))?;

        Ok(instance)
    }
}

impl ToPyAst for ast::StmtClassDef<TextRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            name,
            bases,
            keywords,
            body,
            decorator_list,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py).call1((
            name.to_py_ast(py)?,
            bases.to_py_ast(py)?,
            keywords.to_py_ast(py)?,
            body.to_py_ast(py)?,
            decorator_list.to_py_ast(py)?,
        ))?;

        Ok(instance)
    }
}

impl ToPyAst for ast::StmtReturn<TextRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            value,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py).call1((value.to_py_ast(py)?,))?;

        Ok(instance)
    }
}

impl ToPyAst for ast::StmtDelete<TextRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            targets,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py).call1((targets.to_py_ast(py)?,))?;

        Ok(instance)
    }
}

impl ToPyAst for ast::StmtAssign<TextRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            targets,
            value,
            type_comment,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py).call1((
            targets.to_py_ast(py)?,
            value.to_py_ast(py)?,
            type_comment.to_py_ast(py)?,
        ))?;

        Ok(instance)
    }
}

impl ToPyAst for ast::StmtAugAssign<TextRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            target,
            op,
            value,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py).call1((
            target.to_py_ast(py)?,
            op.to_py_ast(py)?,
            value.to_py_ast(py)?,
        ))?;

        Ok(instance)
    }
}

impl ToPyAst for ast::StmtAnnAssign<TextRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            target,
            annotation,
            value,
            simple,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py).call1((
            target.to_py_ast(py)?,
            annotation.to_py_ast(py)?,
            value.to_py_ast(py)?,
            simple.to_py_ast(py)?,
        ))?;

        Ok(instance)
    }
}

impl ToPyAst for ast::StmtFor<TextRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            target,
            iter,
            body,
            orelse,
            type_comment,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py).call1((
            target.to_py_ast(py)?,
            iter.to_py_ast(py)?,
            body.to_py_ast(py)?,
            orelse.to_py_ast(py)?,
            type_comment.to_py_ast(py)?,
        ))?;

        Ok(instance)
    }
}

impl ToPyAst for ast::StmtAsyncFor<TextRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            target,
            iter,
            body,
            orelse,
            type_comment,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py).call1((
            target.to_py_ast(py)?,
            iter.to_py_ast(py)?,
            body.to_py_ast(py)?,
            orelse.to_py_ast(py)?,
            type_comment.to_py_ast(py)?,
        ))?;

        Ok(instance)
    }
}

impl ToPyAst for ast::StmtWhile<TextRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            test,
            body,
            orelse,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py).call1((
            test.to_py_ast(py)?,
            body.to_py_ast(py)?,
            orelse.to_py_ast(py)?,
        ))?;

        Ok(instance)
    }
}

impl ToPyAst for ast::StmtIf<TextRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            test,
            body,
            orelse,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py).call1((
            test.to_py_ast(py)?,
            body.to_py_ast(py)?,
            orelse.to_py_ast(py)?,
        ))?;

        Ok(instance)
    }
}

impl ToPyAst for ast::StmtWith<TextRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            items,
            body,
            type_comment,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py).call1((
            items.to_py_ast(py)?,
            body.to_py_ast(py)?,
            type_comment.to_py_ast(py)?,
        ))?;

        Ok(instance)
    }
}

impl ToPyAst for ast::StmtAsyncWith<TextRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            items,
            body,
            type_comment,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py).call1((
            items.to_py_ast(py)?,
            body.to_py_ast(py)?,
            type_comment.to_py_ast(py)?,
        ))?;

        Ok(instance)
    }
}

impl ToPyAst for ast::StmtMatch<TextRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            subject,
            cases,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py)
            .call1((subject.to_py_ast(py)?, cases.to_py_ast(py)?))?;

        Ok(instance)
    }
}

impl ToPyAst for ast::StmtRaise<TextRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            exc,
            cause,
            range: _range,
        } = self;

        let instance =
            Py::<PyAny>::as_ref(&cache.0, py).call1((exc.to_py_ast(py)?, cause.to_py_ast(py)?))?;

        Ok(instance)
    }
}

impl ToPyAst for ast::StmtTry<TextRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            body,
            handlers,
            orelse,
            finalbody,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py).call1((
            body.to_py_ast(py)?,
            handlers.to_py_ast(py)?,
            orelse.to_py_ast(py)?,
            finalbody.to_py_ast(py)?,
        ))?;

        Ok(instance)
    }
}

impl ToPyAst for ast::StmtTryStar<TextRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            body,
            handlers,
            orelse,
            finalbody,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py).call1((
            body.to_py_ast(py)?,
            handlers.to_py_ast(py)?,
            orelse.to_py_ast(py)?,
            finalbody.to_py_ast(py)?,
        ))?;

        Ok(instance)
    }
}

impl ToPyAst for ast::StmtAssert<TextRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            test,
            msg,
            range: _range,
        } = self;

        let instance =
            Py::<PyAny>::as_ref(&cache.0, py).call1((test.to_py_ast(py)?, msg.to_py_ast(py)?))?;

        Ok(instance)
    }
}

impl ToPyAst for ast::StmtImport<TextRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            names,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py).call1((names.to_py_ast(py)?,))?;

        Ok(instance)
    }
}

impl ToPyAst for ast::StmtImportFrom<TextRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            module,
            names,
            level,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py).call1((
            module.to_py_ast(py)?,
            names.to_py_ast(py)?,
            level.map_or_else(|| py.None(), |level| level.to_u32().to_object(py)),
        ))?;

        Ok(instance)
    }
}

impl ToPyAst for ast::StmtGlobal<TextRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            names,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py).call1((names.to_py_ast(py)?,))?;

        Ok(instance)
    }
}

impl ToPyAst for ast::StmtNonlocal<TextRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            names,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py).call1((names.to_py_ast(py)?,))?;

        Ok(instance)
    }
}

impl ToPyAst for ast::StmtExpr<TextRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            value,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py).call1((value.to_py_ast(py)?,))?;

        Ok(instance)
    }
}

impl ToPyAst for ast::StmtPass<TextRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self { range: _range } = self;
        let instance = Py::<PyAny>::as_ref(&cache.0, py).call0()?;

        Ok(instance)
    }
}

impl ToPyAst for ast::StmtBreak<TextRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self { range: _range } = self;
        let instance = Py::<PyAny>::as_ref(&cache.0, py).call0()?;

        Ok(instance)
    }
}

impl ToPyAst for ast::StmtContinue<TextRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self { range: _range } = self;
        let instance = Py::<PyAny>::as_ref(&cache.0, py).call0()?;

        Ok(instance)
    }
}

impl ToPyAst for ast::Expr<TextRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let instance = match &self {
            ast::Expr::BoolOp(cons) => cons.to_py_ast(py)?,
            ast::Expr::NamedExpr(cons) => cons.to_py_ast(py)?,
            ast::Expr::BinOp(cons) => cons.to_py_ast(py)?,
            ast::Expr::UnaryOp(cons) => cons.to_py_ast(py)?,
            ast::Expr::Lambda(cons) => cons.to_py_ast(py)?,
            ast::Expr::IfExp(cons) => cons.to_py_ast(py)?,
            ast::Expr::Dict(cons) => cons.to_py_ast(py)?,
            ast::Expr::Set(cons) => cons.to_py_ast(py)?,
            ast::Expr::ListComp(cons) => cons.to_py_ast(py)?,
            ast::Expr::SetComp(cons) => cons.to_py_ast(py)?,
            ast::Expr::DictComp(cons) => cons.to_py_ast(py)?,
            ast::Expr::GeneratorExp(cons) => cons.to_py_ast(py)?,
            ast::Expr::Await(cons) => cons.to_py_ast(py)?,
            ast::Expr::Yield(cons) => cons.to_py_ast(py)?,
            ast::Expr::YieldFrom(cons) => cons.to_py_ast(py)?,
            ast::Expr::Compare(cons) => cons.to_py_ast(py)?,
            ast::Expr::Call(cons) => cons.to_py_ast(py)?,
            ast::Expr::FormattedValue(cons) => cons.to_py_ast(py)?,
            ast::Expr::JoinedStr(cons) => cons.to_py_ast(py)?,
            ast::Expr::Constant(cons) => cons.to_py_ast(py)?,
            ast::Expr::Attribute(cons) => cons.to_py_ast(py)?,
            ast::Expr::Subscript(cons) => cons.to_py_ast(py)?,
            ast::Expr::Starred(cons) => cons.to_py_ast(py)?,
            ast::Expr::Name(cons) => cons.to_py_ast(py)?,
            ast::Expr::List(cons) => cons.to_py_ast(py)?,
            ast::Expr::Tuple(cons) => cons.to_py_ast(py)?,
            ast::Expr::Slice(cons) => cons.to_py_ast(py)?,
        };
        Ok(instance)
    }
}

impl ToPyAst for ast::ExprBoolOp<TextRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            op,
            values,
            range: _range,
        } = self;

        let instance =
            Py::<PyAny>::as_ref(&cache.0, py).call1((op.to_py_ast(py)?, values.to_py_ast(py)?))?;

        Ok(instance)
    }
}

impl ToPyAst for ast::ExprNamedExpr<TextRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            target,
            value,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py)
            .call1((target.to_py_ast(py)?, value.to_py_ast(py)?))?;

        Ok(instance)
    }
}

impl ToPyAst for ast::ExprBinOp<TextRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            left,
            op,
            right,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py).call1((
            left.to_py_ast(py)?,
            op.to_py_ast(py)?,
            right.to_py_ast(py)?,
        ))?;

        Ok(instance)
    }
}

impl ToPyAst for ast::ExprUnaryOp<TextRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            op,
            operand,
            range: _range,
        } = self;

        let instance =
            Py::<PyAny>::as_ref(&cache.0, py).call1((op.to_py_ast(py)?, operand.to_py_ast(py)?))?;

        Ok(instance)
    }
}

impl ToPyAst for ast::ExprLambda<TextRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            args,
            body,
            range: _range,
        } = self;

        let instance =
            Py::<PyAny>::as_ref(&cache.0, py).call1((args.to_py_ast(py)?, body.to_py_ast(py)?))?;

        Ok(instance)
    }
}

impl ToPyAst for ast::ExprIfExp<TextRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            test,
            body,
            orelse,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py).call1((
            test.to_py_ast(py)?,
            body.to_py_ast(py)?,
            orelse.to_py_ast(py)?,
        ))?;

        Ok(instance)
    }
}

impl ToPyAst for ast::ExprDict<TextRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            keys,
            values,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py)
            .call1((keys.to_py_ast(py)?, values.to_py_ast(py)?))?;

        Ok(instance)
    }
}

impl ToPyAst for ast::ExprSet<TextRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            elts,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py).call1((elts.to_py_ast(py)?,))?;

        Ok(instance)
    }
}

impl ToPyAst for ast::ExprListComp<TextRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            elt,
            generators,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py)
            .call1((elt.to_py_ast(py)?, generators.to_py_ast(py)?))?;

        Ok(instance)
    }
}

impl ToPyAst for ast::ExprSetComp<TextRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            elt,
            generators,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py)
            .call1((elt.to_py_ast(py)?, generators.to_py_ast(py)?))?;

        Ok(instance)
    }
}

impl ToPyAst for ast::ExprDictComp<TextRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            key,
            value,
            generators,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py).call1((
            key.to_py_ast(py)?,
            value.to_py_ast(py)?,
            generators.to_py_ast(py)?,
        ))?;

        Ok(instance)
    }
}

impl ToPyAst for ast::ExprGeneratorExp<TextRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            elt,
            generators,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py)
            .call1((elt.to_py_ast(py)?, generators.to_py_ast(py)?))?;

        Ok(instance)
    }
}

impl ToPyAst for ast::ExprAwait<TextRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            value,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py).call1((value.to_py_ast(py)?,))?;

        Ok(instance)
    }
}

impl ToPyAst for ast::ExprYield<TextRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            value,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py).call1((value.to_py_ast(py)?,))?;

        Ok(instance)
    }
}

impl ToPyAst for ast::ExprYieldFrom<TextRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            value,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py).call1((value.to_py_ast(py)?,))?;

        Ok(instance)
    }
}

impl ToPyAst for ast::ExprCompare<TextRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            left,
            ops,
            comparators,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py).call1((
            left.to_py_ast(py)?,
            ops.to_py_ast(py)?,
            comparators.to_py_ast(py)?,
        ))?;

        Ok(instance)
    }
}

impl ToPyAst for ast::ExprCall<TextRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            func,
            args,
            keywords,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py).call1((
            func.to_py_ast(py)?,
            args.to_py_ast(py)?,
            keywords.to_py_ast(py)?,
        ))?;

        Ok(instance)
    }
}

impl ToPyAst for ast::ExprFormattedValue<TextRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            value,
            conversion,
            format_spec,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py).call1((
            value.to_py_ast(py)?,
            conversion.to_py_ast(py)?,
            format_spec.to_py_ast(py)?,
        ))?;

        Ok(instance)
    }
}

impl ToPyAst for ast::ExprJoinedStr<TextRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            values,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py).call1((values.to_py_ast(py)?,))?;

        Ok(instance)
    }
}

impl ToPyAst for ast::ExprConstant<TextRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            value,
            kind,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py)
            .call1((constant_to_object(value, py), kind.to_py_ast(py)?))?;

        Ok(instance)
    }
}

impl ToPyAst for ast::ExprAttribute<TextRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            value,
            attr,
            ctx,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py).call1((
            value.to_py_ast(py)?,
            attr.to_py_ast(py)?,
            ctx.to_py_ast(py)?,
        ))?;

        Ok(instance)
    }
}

impl ToPyAst for ast::ExprSubscript<TextRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            value,
            slice,
            ctx,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py).call1((
            value.to_py_ast(py)?,
            slice.to_py_ast(py)?,
            ctx.to_py_ast(py)?,
        ))?;

        Ok(instance)
    }
}

impl ToPyAst for ast::ExprStarred<TextRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            value,
            ctx,
            range: _range,
        } = self;

        let instance =
            Py::<PyAny>::as_ref(&cache.0, py).call1((value.to_py_ast(py)?, ctx.to_py_ast(py)?))?;

        Ok(instance)
    }
}

impl ToPyAst for ast::ExprName<TextRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            id,
            ctx,
            range: _range,
        } = self;

        let instance =
            Py::<PyAny>::as_ref(&cache.0, py).call1((id.to_py_ast(py)?, ctx.to_py_ast(py)?))?;

        Ok(instance)
    }
}

impl ToPyAst for ast::ExprList<TextRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            elts,
            ctx,
            range: _range,
        } = self;

        let instance =
            Py::<PyAny>::as_ref(&cache.0, py).call1((elts.to_py_ast(py)?, ctx.to_py_ast(py)?))?;

        Ok(instance)
    }
}

impl ToPyAst for ast::ExprTuple<TextRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            elts,
            ctx,
            range: _range,
        } = self;

        let instance =
            Py::<PyAny>::as_ref(&cache.0, py).call1((elts.to_py_ast(py)?, ctx.to_py_ast(py)?))?;

        Ok(instance)
    }
}

impl ToPyAst for ast::ExprSlice<TextRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            lower,
            upper,
            step,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py).call1((
            lower.to_py_ast(py)?,
            upper.to_py_ast(py)?,
            step.to_py_ast(py)?,
        ))?;

        Ok(instance)
    }
}

impl ToPyAst for ast::Comprehension<TextRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            target,
            iter,
            ifs,
            is_async,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py).call1((
            target.to_py_ast(py)?,
            iter.to_py_ast(py)?,
            ifs.to_py_ast(py)?,
            is_async.to_py_ast(py)?,
        ))?;

        Ok(instance)
    }
}

impl ToPyAst for ast::ExceptHandler<TextRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let instance = match &self {
            ast::ExceptHandler::ExceptHandler(cons) => cons.to_py_ast(py)?,
        };
        Ok(instance)
    }
}

impl ToPyAst for ast::ExceptHandlerExceptHandler<TextRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            type_,
            name,
            body,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py).call1((
            type_.to_py_ast(py)?,
            name.to_py_ast(py)?,
            body.to_py_ast(py)?,
        ))?;

        Ok(instance)
    }
}

impl ToPyAst for ast::PythonArguments<TextRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            posonlyargs,
            args,
            vararg,
            kwonlyargs,
            kw_defaults,
            kwarg,
            defaults,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py).call1((
            posonlyargs.to_py_ast(py)?,
            args.to_py_ast(py)?,
            vararg.to_py_ast(py)?,
            kwonlyargs.to_py_ast(py)?,
            kw_defaults.to_py_ast(py)?,
            kwarg.to_py_ast(py)?,
            defaults.to_py_ast(py)?,
        ))?;

        Ok(instance)
    }
}

impl ToPyAst for ast::Arg<TextRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            arg,
            annotation,
            type_comment,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py).call1((
            arg.to_py_ast(py)?,
            annotation.to_py_ast(py)?,
            type_comment.to_py_ast(py)?,
        ))?;

        Ok(instance)
    }
}

impl ToPyAst for ast::Keyword<TextRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            arg,
            value,
            range: _range,
        } = self;

        let instance =
            Py::<PyAny>::as_ref(&cache.0, py).call1((arg.to_py_ast(py)?, value.to_py_ast(py)?))?;

        Ok(instance)
    }
}

impl ToPyAst for ast::Alias<TextRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            name,
            asname,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py)
            .call1((name.to_py_ast(py)?, asname.to_py_ast(py)?))?;

        Ok(instance)
    }
}

impl ToPyAst for ast::WithItem<TextRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            context_expr,
            optional_vars,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py)
            .call1((context_expr.to_py_ast(py)?, optional_vars.to_py_ast(py)?))?;

        Ok(instance)
    }
}

impl ToPyAst for ast::MatchCase<TextRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            pattern,
            guard,
            body,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py).call1((
            pattern.to_py_ast(py)?,
            guard.to_py_ast(py)?,
            body.to_py_ast(py)?,
        ))?;

        Ok(instance)
    }
}

impl ToPyAst for ast::Pattern<TextRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let instance = match &self {
            ast::Pattern::MatchValue(cons) => cons.to_py_ast(py)?,
            ast::Pattern::MatchSingleton(cons) => cons.to_py_ast(py)?,
            ast::Pattern::MatchSequence(cons) => cons.to_py_ast(py)?,
            ast::Pattern::MatchMapping(cons) => cons.to_py_ast(py)?,
            ast::Pattern::MatchClass(cons) => cons.to_py_ast(py)?,
            ast::Pattern::MatchStar(cons) => cons.to_py_ast(py)?,
            ast::Pattern::MatchAs(cons) => cons.to_py_ast(py)?,
            ast::Pattern::MatchOr(cons) => cons.to_py_ast(py)?,
        };
        Ok(instance)
    }
}

impl ToPyAst for ast::PatternMatchValue<TextRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            value,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py).call1((value.to_py_ast(py)?,))?;

        Ok(instance)
    }
}

impl ToPyAst for ast::PatternMatchSingleton<TextRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            value,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py).call1((constant_to_object(value, py),))?;

        Ok(instance)
    }
}

impl ToPyAst for ast::PatternMatchSequence<TextRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            patterns,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py).call1((patterns.to_py_ast(py)?,))?;

        Ok(instance)
    }
}

impl ToPyAst for ast::PatternMatchMapping<TextRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            keys,
            patterns,
            rest,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py).call1((
            keys.to_py_ast(py)?,
            patterns.to_py_ast(py)?,
            rest.to_py_ast(py)?,
        ))?;

        Ok(instance)
    }
}

impl ToPyAst for ast::PatternMatchClass<TextRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            cls,
            patterns,
            kwd_attrs,
            kwd_patterns,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py).call1((
            cls.to_py_ast(py)?,
            patterns.to_py_ast(py)?,
            kwd_attrs.to_py_ast(py)?,
            kwd_patterns.to_py_ast(py)?,
        ))?;

        Ok(instance)
    }
}

impl ToPyAst for ast::PatternMatchStar<TextRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            name,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py).call1((name.to_py_ast(py)?,))?;

        Ok(instance)
    }
}

impl ToPyAst for ast::PatternMatchAs<TextRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            pattern,
            name,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py)
            .call1((pattern.to_py_ast(py)?, name.to_py_ast(py)?))?;

        Ok(instance)
    }
}

impl ToPyAst for ast::PatternMatchOr<TextRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            patterns,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py).call1((patterns.to_py_ast(py)?,))?;

        Ok(instance)
    }
}

impl ToPyAst for ast::TypeIgnore<TextRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let instance = match &self {
            ast::TypeIgnore::TypeIgnore(cons) => cons.to_py_ast(py)?,
        };
        Ok(instance)
    }
}

impl ToPyAst for ast::TypeIgnoreTypeIgnore<TextRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            lineno,
            tag,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py)
            .call1((lineno.to_u32().to_object(py), tag.to_py_ast(py)?))?;

        Ok(instance)
    }
}

impl ToPyAst for ast::Mod<SourceRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let instance = match &self {
            ast::Mod::Module(cons) => cons.to_py_ast(py)?,
            ast::Mod::Interactive(cons) => cons.to_py_ast(py)?,
            ast::Mod::Expression(cons) => cons.to_py_ast(py)?,
            ast::Mod::FunctionType(cons) => cons.to_py_ast(py)?,
        };
        Ok(instance)
    }
}

impl ToPyAst for ast::ModModule<SourceRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            body,
            type_ignores,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py)
            .call1((body.to_py_ast(py)?, type_ignores.to_py_ast(py)?))?;

        Ok(instance)
    }
}

impl ToPyAst for ast::ModInteractive<SourceRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            body,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py).call1((body.to_py_ast(py)?,))?;

        Ok(instance)
    }
}

impl ToPyAst for ast::ModExpression<SourceRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            body,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py).call1((body.to_py_ast(py)?,))?;

        Ok(instance)
    }
}

impl ToPyAst for ast::ModFunctionType<SourceRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            argtypes,
            returns,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py)
            .call1((argtypes.to_py_ast(py)?, returns.to_py_ast(py)?))?;

        Ok(instance)
    }
}

impl ToPyAst for ast::Stmt<SourceRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let instance = match &self {
            ast::Stmt::FunctionDef(cons) => cons.to_py_ast(py)?,
            ast::Stmt::AsyncFunctionDef(cons) => cons.to_py_ast(py)?,
            ast::Stmt::ClassDef(cons) => cons.to_py_ast(py)?,
            ast::Stmt::Return(cons) => cons.to_py_ast(py)?,
            ast::Stmt::Delete(cons) => cons.to_py_ast(py)?,
            ast::Stmt::Assign(cons) => cons.to_py_ast(py)?,
            ast::Stmt::AugAssign(cons) => cons.to_py_ast(py)?,
            ast::Stmt::AnnAssign(cons) => cons.to_py_ast(py)?,
            ast::Stmt::For(cons) => cons.to_py_ast(py)?,
            ast::Stmt::AsyncFor(cons) => cons.to_py_ast(py)?,
            ast::Stmt::While(cons) => cons.to_py_ast(py)?,
            ast::Stmt::If(cons) => cons.to_py_ast(py)?,
            ast::Stmt::With(cons) => cons.to_py_ast(py)?,
            ast::Stmt::AsyncWith(cons) => cons.to_py_ast(py)?,
            ast::Stmt::Match(cons) => cons.to_py_ast(py)?,
            ast::Stmt::Raise(cons) => cons.to_py_ast(py)?,
            ast::Stmt::Try(cons) => cons.to_py_ast(py)?,
            ast::Stmt::TryStar(cons) => cons.to_py_ast(py)?,
            ast::Stmt::Assert(cons) => cons.to_py_ast(py)?,
            ast::Stmt::Import(cons) => cons.to_py_ast(py)?,
            ast::Stmt::ImportFrom(cons) => cons.to_py_ast(py)?,
            ast::Stmt::Global(cons) => cons.to_py_ast(py)?,
            ast::Stmt::Nonlocal(cons) => cons.to_py_ast(py)?,
            ast::Stmt::Expr(cons) => cons.to_py_ast(py)?,
            ast::Stmt::Pass(cons) => cons.to_py_ast(py)?,
            ast::Stmt::Break(cons) => cons.to_py_ast(py)?,
            ast::Stmt::Continue(cons) => cons.to_py_ast(py)?,
        };
        Ok(instance)
    }
}

impl ToPyAst for ast::StmtFunctionDef<SourceRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            name,
            args,
            body,
            decorator_list,
            returns,
            type_comment,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py).call1((
            name.to_py_ast(py)?,
            args.to_py_ast(py)?,
            body.to_py_ast(py)?,
            decorator_list.to_py_ast(py)?,
            returns.to_py_ast(py)?,
            type_comment.to_py_ast(py)?,
        ))?;

        let cache = ast_cache();
        instance.setattr(cache.lineno.as_ref(py), _range.start.row.get())?;
        instance.setattr(cache.col_offset.as_ref(py), _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(cache.end_lineno.as_ref(py), end.row.get())?;
            instance.setattr(cache.end_col_offset.as_ref(py), end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyAst for ast::StmtAsyncFunctionDef<SourceRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            name,
            args,
            body,
            decorator_list,
            returns,
            type_comment,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py).call1((
            name.to_py_ast(py)?,
            args.to_py_ast(py)?,
            body.to_py_ast(py)?,
            decorator_list.to_py_ast(py)?,
            returns.to_py_ast(py)?,
            type_comment.to_py_ast(py)?,
        ))?;

        let cache = ast_cache();
        instance.setattr(cache.lineno.as_ref(py), _range.start.row.get())?;
        instance.setattr(cache.col_offset.as_ref(py), _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(cache.end_lineno.as_ref(py), end.row.get())?;
            instance.setattr(cache.end_col_offset.as_ref(py), end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyAst for ast::StmtClassDef<SourceRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            name,
            bases,
            keywords,
            body,
            decorator_list,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py).call1((
            name.to_py_ast(py)?,
            bases.to_py_ast(py)?,
            keywords.to_py_ast(py)?,
            body.to_py_ast(py)?,
            decorator_list.to_py_ast(py)?,
        ))?;

        let cache = ast_cache();
        instance.setattr(cache.lineno.as_ref(py), _range.start.row.get())?;
        instance.setattr(cache.col_offset.as_ref(py), _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(cache.end_lineno.as_ref(py), end.row.get())?;
            instance.setattr(cache.end_col_offset.as_ref(py), end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyAst for ast::StmtReturn<SourceRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            value,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py).call1((value.to_py_ast(py)?,))?;

        let cache = ast_cache();
        instance.setattr(cache.lineno.as_ref(py), _range.start.row.get())?;
        instance.setattr(cache.col_offset.as_ref(py), _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(cache.end_lineno.as_ref(py), end.row.get())?;
            instance.setattr(cache.end_col_offset.as_ref(py), end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyAst for ast::StmtDelete<SourceRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            targets,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py).call1((targets.to_py_ast(py)?,))?;

        let cache = ast_cache();
        instance.setattr(cache.lineno.as_ref(py), _range.start.row.get())?;
        instance.setattr(cache.col_offset.as_ref(py), _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(cache.end_lineno.as_ref(py), end.row.get())?;
            instance.setattr(cache.end_col_offset.as_ref(py), end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyAst for ast::StmtAssign<SourceRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            targets,
            value,
            type_comment,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py).call1((
            targets.to_py_ast(py)?,
            value.to_py_ast(py)?,
            type_comment.to_py_ast(py)?,
        ))?;

        let cache = ast_cache();
        instance.setattr(cache.lineno.as_ref(py), _range.start.row.get())?;
        instance.setattr(cache.col_offset.as_ref(py), _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(cache.end_lineno.as_ref(py), end.row.get())?;
            instance.setattr(cache.end_col_offset.as_ref(py), end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyAst for ast::StmtAugAssign<SourceRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            target,
            op,
            value,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py).call1((
            target.to_py_ast(py)?,
            op.to_py_ast(py)?,
            value.to_py_ast(py)?,
        ))?;

        let cache = ast_cache();
        instance.setattr(cache.lineno.as_ref(py), _range.start.row.get())?;
        instance.setattr(cache.col_offset.as_ref(py), _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(cache.end_lineno.as_ref(py), end.row.get())?;
            instance.setattr(cache.end_col_offset.as_ref(py), end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyAst for ast::StmtAnnAssign<SourceRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            target,
            annotation,
            value,
            simple,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py).call1((
            target.to_py_ast(py)?,
            annotation.to_py_ast(py)?,
            value.to_py_ast(py)?,
            simple.to_py_ast(py)?,
        ))?;

        let cache = ast_cache();
        instance.setattr(cache.lineno.as_ref(py), _range.start.row.get())?;
        instance.setattr(cache.col_offset.as_ref(py), _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(cache.end_lineno.as_ref(py), end.row.get())?;
            instance.setattr(cache.end_col_offset.as_ref(py), end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyAst for ast::StmtFor<SourceRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            target,
            iter,
            body,
            orelse,
            type_comment,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py).call1((
            target.to_py_ast(py)?,
            iter.to_py_ast(py)?,
            body.to_py_ast(py)?,
            orelse.to_py_ast(py)?,
            type_comment.to_py_ast(py)?,
        ))?;

        let cache = ast_cache();
        instance.setattr(cache.lineno.as_ref(py), _range.start.row.get())?;
        instance.setattr(cache.col_offset.as_ref(py), _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(cache.end_lineno.as_ref(py), end.row.get())?;
            instance.setattr(cache.end_col_offset.as_ref(py), end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyAst for ast::StmtAsyncFor<SourceRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            target,
            iter,
            body,
            orelse,
            type_comment,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py).call1((
            target.to_py_ast(py)?,
            iter.to_py_ast(py)?,
            body.to_py_ast(py)?,
            orelse.to_py_ast(py)?,
            type_comment.to_py_ast(py)?,
        ))?;

        let cache = ast_cache();
        instance.setattr(cache.lineno.as_ref(py), _range.start.row.get())?;
        instance.setattr(cache.col_offset.as_ref(py), _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(cache.end_lineno.as_ref(py), end.row.get())?;
            instance.setattr(cache.end_col_offset.as_ref(py), end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyAst for ast::StmtWhile<SourceRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            test,
            body,
            orelse,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py).call1((
            test.to_py_ast(py)?,
            body.to_py_ast(py)?,
            orelse.to_py_ast(py)?,
        ))?;

        let cache = ast_cache();
        instance.setattr(cache.lineno.as_ref(py), _range.start.row.get())?;
        instance.setattr(cache.col_offset.as_ref(py), _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(cache.end_lineno.as_ref(py), end.row.get())?;
            instance.setattr(cache.end_col_offset.as_ref(py), end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyAst for ast::StmtIf<SourceRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            test,
            body,
            orelse,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py).call1((
            test.to_py_ast(py)?,
            body.to_py_ast(py)?,
            orelse.to_py_ast(py)?,
        ))?;

        let cache = ast_cache();
        instance.setattr(cache.lineno.as_ref(py), _range.start.row.get())?;
        instance.setattr(cache.col_offset.as_ref(py), _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(cache.end_lineno.as_ref(py), end.row.get())?;
            instance.setattr(cache.end_col_offset.as_ref(py), end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyAst for ast::StmtWith<SourceRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            items,
            body,
            type_comment,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py).call1((
            items.to_py_ast(py)?,
            body.to_py_ast(py)?,
            type_comment.to_py_ast(py)?,
        ))?;

        let cache = ast_cache();
        instance.setattr(cache.lineno.as_ref(py), _range.start.row.get())?;
        instance.setattr(cache.col_offset.as_ref(py), _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(cache.end_lineno.as_ref(py), end.row.get())?;
            instance.setattr(cache.end_col_offset.as_ref(py), end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyAst for ast::StmtAsyncWith<SourceRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            items,
            body,
            type_comment,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py).call1((
            items.to_py_ast(py)?,
            body.to_py_ast(py)?,
            type_comment.to_py_ast(py)?,
        ))?;

        let cache = ast_cache();
        instance.setattr(cache.lineno.as_ref(py), _range.start.row.get())?;
        instance.setattr(cache.col_offset.as_ref(py), _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(cache.end_lineno.as_ref(py), end.row.get())?;
            instance.setattr(cache.end_col_offset.as_ref(py), end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyAst for ast::StmtMatch<SourceRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            subject,
            cases,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py)
            .call1((subject.to_py_ast(py)?, cases.to_py_ast(py)?))?;

        let cache = ast_cache();
        instance.setattr(cache.lineno.as_ref(py), _range.start.row.get())?;
        instance.setattr(cache.col_offset.as_ref(py), _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(cache.end_lineno.as_ref(py), end.row.get())?;
            instance.setattr(cache.end_col_offset.as_ref(py), end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyAst for ast::StmtRaise<SourceRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            exc,
            cause,
            range: _range,
        } = self;

        let instance =
            Py::<PyAny>::as_ref(&cache.0, py).call1((exc.to_py_ast(py)?, cause.to_py_ast(py)?))?;

        let cache = ast_cache();
        instance.setattr(cache.lineno.as_ref(py), _range.start.row.get())?;
        instance.setattr(cache.col_offset.as_ref(py), _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(cache.end_lineno.as_ref(py), end.row.get())?;
            instance.setattr(cache.end_col_offset.as_ref(py), end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyAst for ast::StmtTry<SourceRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            body,
            handlers,
            orelse,
            finalbody,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py).call1((
            body.to_py_ast(py)?,
            handlers.to_py_ast(py)?,
            orelse.to_py_ast(py)?,
            finalbody.to_py_ast(py)?,
        ))?;

        let cache = ast_cache();
        instance.setattr(cache.lineno.as_ref(py), _range.start.row.get())?;
        instance.setattr(cache.col_offset.as_ref(py), _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(cache.end_lineno.as_ref(py), end.row.get())?;
            instance.setattr(cache.end_col_offset.as_ref(py), end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyAst for ast::StmtTryStar<SourceRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            body,
            handlers,
            orelse,
            finalbody,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py).call1((
            body.to_py_ast(py)?,
            handlers.to_py_ast(py)?,
            orelse.to_py_ast(py)?,
            finalbody.to_py_ast(py)?,
        ))?;

        let cache = ast_cache();
        instance.setattr(cache.lineno.as_ref(py), _range.start.row.get())?;
        instance.setattr(cache.col_offset.as_ref(py), _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(cache.end_lineno.as_ref(py), end.row.get())?;
            instance.setattr(cache.end_col_offset.as_ref(py), end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyAst for ast::StmtAssert<SourceRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            test,
            msg,
            range: _range,
        } = self;

        let instance =
            Py::<PyAny>::as_ref(&cache.0, py).call1((test.to_py_ast(py)?, msg.to_py_ast(py)?))?;

        let cache = ast_cache();
        instance.setattr(cache.lineno.as_ref(py), _range.start.row.get())?;
        instance.setattr(cache.col_offset.as_ref(py), _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(cache.end_lineno.as_ref(py), end.row.get())?;
            instance.setattr(cache.end_col_offset.as_ref(py), end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyAst for ast::StmtImport<SourceRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            names,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py).call1((names.to_py_ast(py)?,))?;

        let cache = ast_cache();
        instance.setattr(cache.lineno.as_ref(py), _range.start.row.get())?;
        instance.setattr(cache.col_offset.as_ref(py), _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(cache.end_lineno.as_ref(py), end.row.get())?;
            instance.setattr(cache.end_col_offset.as_ref(py), end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyAst for ast::StmtImportFrom<SourceRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            module,
            names,
            level,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py).call1((
            module.to_py_ast(py)?,
            names.to_py_ast(py)?,
            level.map_or_else(|| py.None(), |level| level.to_u32().to_object(py)),
        ))?;

        let cache = ast_cache();
        instance.setattr(cache.lineno.as_ref(py), _range.start.row.get())?;
        instance.setattr(cache.col_offset.as_ref(py), _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(cache.end_lineno.as_ref(py), end.row.get())?;
            instance.setattr(cache.end_col_offset.as_ref(py), end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyAst for ast::StmtGlobal<SourceRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            names,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py).call1((names.to_py_ast(py)?,))?;

        let cache = ast_cache();
        instance.setattr(cache.lineno.as_ref(py), _range.start.row.get())?;
        instance.setattr(cache.col_offset.as_ref(py), _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(cache.end_lineno.as_ref(py), end.row.get())?;
            instance.setattr(cache.end_col_offset.as_ref(py), end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyAst for ast::StmtNonlocal<SourceRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            names,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py).call1((names.to_py_ast(py)?,))?;

        let cache = ast_cache();
        instance.setattr(cache.lineno.as_ref(py), _range.start.row.get())?;
        instance.setattr(cache.col_offset.as_ref(py), _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(cache.end_lineno.as_ref(py), end.row.get())?;
            instance.setattr(cache.end_col_offset.as_ref(py), end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyAst for ast::StmtExpr<SourceRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            value,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py).call1((value.to_py_ast(py)?,))?;

        let cache = ast_cache();
        instance.setattr(cache.lineno.as_ref(py), _range.start.row.get())?;
        instance.setattr(cache.col_offset.as_ref(py), _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(cache.end_lineno.as_ref(py), end.row.get())?;
            instance.setattr(cache.end_col_offset.as_ref(py), end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyAst for ast::StmtPass<SourceRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self { range: _range } = self;
        let instance = Py::<PyAny>::as_ref(&cache.0, py).call0()?;

        let cache = ast_cache();
        instance.setattr(cache.lineno.as_ref(py), _range.start.row.get())?;
        instance.setattr(cache.col_offset.as_ref(py), _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(cache.end_lineno.as_ref(py), end.row.get())?;
            instance.setattr(cache.end_col_offset.as_ref(py), end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyAst for ast::StmtBreak<SourceRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self { range: _range } = self;
        let instance = Py::<PyAny>::as_ref(&cache.0, py).call0()?;

        let cache = ast_cache();
        instance.setattr(cache.lineno.as_ref(py), _range.start.row.get())?;
        instance.setattr(cache.col_offset.as_ref(py), _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(cache.end_lineno.as_ref(py), end.row.get())?;
            instance.setattr(cache.end_col_offset.as_ref(py), end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyAst for ast::StmtContinue<SourceRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self { range: _range } = self;
        let instance = Py::<PyAny>::as_ref(&cache.0, py).call0()?;

        let cache = ast_cache();
        instance.setattr(cache.lineno.as_ref(py), _range.start.row.get())?;
        instance.setattr(cache.col_offset.as_ref(py), _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(cache.end_lineno.as_ref(py), end.row.get())?;
            instance.setattr(cache.end_col_offset.as_ref(py), end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyAst for ast::Expr<SourceRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let instance = match &self {
            ast::Expr::BoolOp(cons) => cons.to_py_ast(py)?,
            ast::Expr::NamedExpr(cons) => cons.to_py_ast(py)?,
            ast::Expr::BinOp(cons) => cons.to_py_ast(py)?,
            ast::Expr::UnaryOp(cons) => cons.to_py_ast(py)?,
            ast::Expr::Lambda(cons) => cons.to_py_ast(py)?,
            ast::Expr::IfExp(cons) => cons.to_py_ast(py)?,
            ast::Expr::Dict(cons) => cons.to_py_ast(py)?,
            ast::Expr::Set(cons) => cons.to_py_ast(py)?,
            ast::Expr::ListComp(cons) => cons.to_py_ast(py)?,
            ast::Expr::SetComp(cons) => cons.to_py_ast(py)?,
            ast::Expr::DictComp(cons) => cons.to_py_ast(py)?,
            ast::Expr::GeneratorExp(cons) => cons.to_py_ast(py)?,
            ast::Expr::Await(cons) => cons.to_py_ast(py)?,
            ast::Expr::Yield(cons) => cons.to_py_ast(py)?,
            ast::Expr::YieldFrom(cons) => cons.to_py_ast(py)?,
            ast::Expr::Compare(cons) => cons.to_py_ast(py)?,
            ast::Expr::Call(cons) => cons.to_py_ast(py)?,
            ast::Expr::FormattedValue(cons) => cons.to_py_ast(py)?,
            ast::Expr::JoinedStr(cons) => cons.to_py_ast(py)?,
            ast::Expr::Constant(cons) => cons.to_py_ast(py)?,
            ast::Expr::Attribute(cons) => cons.to_py_ast(py)?,
            ast::Expr::Subscript(cons) => cons.to_py_ast(py)?,
            ast::Expr::Starred(cons) => cons.to_py_ast(py)?,
            ast::Expr::Name(cons) => cons.to_py_ast(py)?,
            ast::Expr::List(cons) => cons.to_py_ast(py)?,
            ast::Expr::Tuple(cons) => cons.to_py_ast(py)?,
            ast::Expr::Slice(cons) => cons.to_py_ast(py)?,
        };
        Ok(instance)
    }
}

impl ToPyAst for ast::ExprBoolOp<SourceRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            op,
            values,
            range: _range,
        } = self;

        let instance =
            Py::<PyAny>::as_ref(&cache.0, py).call1((op.to_py_ast(py)?, values.to_py_ast(py)?))?;

        let cache = ast_cache();
        instance.setattr(cache.lineno.as_ref(py), _range.start.row.get())?;
        instance.setattr(cache.col_offset.as_ref(py), _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(cache.end_lineno.as_ref(py), end.row.get())?;
            instance.setattr(cache.end_col_offset.as_ref(py), end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyAst for ast::ExprNamedExpr<SourceRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            target,
            value,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py)
            .call1((target.to_py_ast(py)?, value.to_py_ast(py)?))?;

        let cache = ast_cache();
        instance.setattr(cache.lineno.as_ref(py), _range.start.row.get())?;
        instance.setattr(cache.col_offset.as_ref(py), _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(cache.end_lineno.as_ref(py), end.row.get())?;
            instance.setattr(cache.end_col_offset.as_ref(py), end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyAst for ast::ExprBinOp<SourceRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            left,
            op,
            right,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py).call1((
            left.to_py_ast(py)?,
            op.to_py_ast(py)?,
            right.to_py_ast(py)?,
        ))?;

        let cache = ast_cache();
        instance.setattr(cache.lineno.as_ref(py), _range.start.row.get())?;
        instance.setattr(cache.col_offset.as_ref(py), _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(cache.end_lineno.as_ref(py), end.row.get())?;
            instance.setattr(cache.end_col_offset.as_ref(py), end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyAst for ast::ExprUnaryOp<SourceRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            op,
            operand,
            range: _range,
        } = self;

        let instance =
            Py::<PyAny>::as_ref(&cache.0, py).call1((op.to_py_ast(py)?, operand.to_py_ast(py)?))?;

        let cache = ast_cache();
        instance.setattr(cache.lineno.as_ref(py), _range.start.row.get())?;
        instance.setattr(cache.col_offset.as_ref(py), _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(cache.end_lineno.as_ref(py), end.row.get())?;
            instance.setattr(cache.end_col_offset.as_ref(py), end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyAst for ast::ExprLambda<SourceRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            args,
            body,
            range: _range,
        } = self;

        let instance =
            Py::<PyAny>::as_ref(&cache.0, py).call1((args.to_py_ast(py)?, body.to_py_ast(py)?))?;

        let cache = ast_cache();
        instance.setattr(cache.lineno.as_ref(py), _range.start.row.get())?;
        instance.setattr(cache.col_offset.as_ref(py), _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(cache.end_lineno.as_ref(py), end.row.get())?;
            instance.setattr(cache.end_col_offset.as_ref(py), end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyAst for ast::ExprIfExp<SourceRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            test,
            body,
            orelse,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py).call1((
            test.to_py_ast(py)?,
            body.to_py_ast(py)?,
            orelse.to_py_ast(py)?,
        ))?;

        let cache = ast_cache();
        instance.setattr(cache.lineno.as_ref(py), _range.start.row.get())?;
        instance.setattr(cache.col_offset.as_ref(py), _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(cache.end_lineno.as_ref(py), end.row.get())?;
            instance.setattr(cache.end_col_offset.as_ref(py), end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyAst for ast::ExprDict<SourceRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            keys,
            values,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py)
            .call1((keys.to_py_ast(py)?, values.to_py_ast(py)?))?;

        let cache = ast_cache();
        instance.setattr(cache.lineno.as_ref(py), _range.start.row.get())?;
        instance.setattr(cache.col_offset.as_ref(py), _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(cache.end_lineno.as_ref(py), end.row.get())?;
            instance.setattr(cache.end_col_offset.as_ref(py), end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyAst for ast::ExprSet<SourceRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            elts,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py).call1((elts.to_py_ast(py)?,))?;

        let cache = ast_cache();
        instance.setattr(cache.lineno.as_ref(py), _range.start.row.get())?;
        instance.setattr(cache.col_offset.as_ref(py), _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(cache.end_lineno.as_ref(py), end.row.get())?;
            instance.setattr(cache.end_col_offset.as_ref(py), end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyAst for ast::ExprListComp<SourceRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            elt,
            generators,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py)
            .call1((elt.to_py_ast(py)?, generators.to_py_ast(py)?))?;

        let cache = ast_cache();
        instance.setattr(cache.lineno.as_ref(py), _range.start.row.get())?;
        instance.setattr(cache.col_offset.as_ref(py), _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(cache.end_lineno.as_ref(py), end.row.get())?;
            instance.setattr(cache.end_col_offset.as_ref(py), end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyAst for ast::ExprSetComp<SourceRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            elt,
            generators,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py)
            .call1((elt.to_py_ast(py)?, generators.to_py_ast(py)?))?;

        let cache = ast_cache();
        instance.setattr(cache.lineno.as_ref(py), _range.start.row.get())?;
        instance.setattr(cache.col_offset.as_ref(py), _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(cache.end_lineno.as_ref(py), end.row.get())?;
            instance.setattr(cache.end_col_offset.as_ref(py), end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyAst for ast::ExprDictComp<SourceRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            key,
            value,
            generators,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py).call1((
            key.to_py_ast(py)?,
            value.to_py_ast(py)?,
            generators.to_py_ast(py)?,
        ))?;

        let cache = ast_cache();
        instance.setattr(cache.lineno.as_ref(py), _range.start.row.get())?;
        instance.setattr(cache.col_offset.as_ref(py), _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(cache.end_lineno.as_ref(py), end.row.get())?;
            instance.setattr(cache.end_col_offset.as_ref(py), end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyAst for ast::ExprGeneratorExp<SourceRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            elt,
            generators,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py)
            .call1((elt.to_py_ast(py)?, generators.to_py_ast(py)?))?;

        let cache = ast_cache();
        instance.setattr(cache.lineno.as_ref(py), _range.start.row.get())?;
        instance.setattr(cache.col_offset.as_ref(py), _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(cache.end_lineno.as_ref(py), end.row.get())?;
            instance.setattr(cache.end_col_offset.as_ref(py), end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyAst for ast::ExprAwait<SourceRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            value,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py).call1((value.to_py_ast(py)?,))?;

        let cache = ast_cache();
        instance.setattr(cache.lineno.as_ref(py), _range.start.row.get())?;
        instance.setattr(cache.col_offset.as_ref(py), _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(cache.end_lineno.as_ref(py), end.row.get())?;
            instance.setattr(cache.end_col_offset.as_ref(py), end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyAst for ast::ExprYield<SourceRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            value,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py).call1((value.to_py_ast(py)?,))?;

        let cache = ast_cache();
        instance.setattr(cache.lineno.as_ref(py), _range.start.row.get())?;
        instance.setattr(cache.col_offset.as_ref(py), _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(cache.end_lineno.as_ref(py), end.row.get())?;
            instance.setattr(cache.end_col_offset.as_ref(py), end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyAst for ast::ExprYieldFrom<SourceRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            value,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py).call1((value.to_py_ast(py)?,))?;

        let cache = ast_cache();
        instance.setattr(cache.lineno.as_ref(py), _range.start.row.get())?;
        instance.setattr(cache.col_offset.as_ref(py), _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(cache.end_lineno.as_ref(py), end.row.get())?;
            instance.setattr(cache.end_col_offset.as_ref(py), end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyAst for ast::ExprCompare<SourceRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            left,
            ops,
            comparators,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py).call1((
            left.to_py_ast(py)?,
            ops.to_py_ast(py)?,
            comparators.to_py_ast(py)?,
        ))?;

        let cache = ast_cache();
        instance.setattr(cache.lineno.as_ref(py), _range.start.row.get())?;
        instance.setattr(cache.col_offset.as_ref(py), _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(cache.end_lineno.as_ref(py), end.row.get())?;
            instance.setattr(cache.end_col_offset.as_ref(py), end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyAst for ast::ExprCall<SourceRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            func,
            args,
            keywords,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py).call1((
            func.to_py_ast(py)?,
            args.to_py_ast(py)?,
            keywords.to_py_ast(py)?,
        ))?;

        let cache = ast_cache();
        instance.setattr(cache.lineno.as_ref(py), _range.start.row.get())?;
        instance.setattr(cache.col_offset.as_ref(py), _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(cache.end_lineno.as_ref(py), end.row.get())?;
            instance.setattr(cache.end_col_offset.as_ref(py), end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyAst for ast::ExprFormattedValue<SourceRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            value,
            conversion,
            format_spec,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py).call1((
            value.to_py_ast(py)?,
            conversion.to_py_ast(py)?,
            format_spec.to_py_ast(py)?,
        ))?;

        let cache = ast_cache();
        instance.setattr(cache.lineno.as_ref(py), _range.start.row.get())?;
        instance.setattr(cache.col_offset.as_ref(py), _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(cache.end_lineno.as_ref(py), end.row.get())?;
            instance.setattr(cache.end_col_offset.as_ref(py), end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyAst for ast::ExprJoinedStr<SourceRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            values,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py).call1((values.to_py_ast(py)?,))?;

        let cache = ast_cache();
        instance.setattr(cache.lineno.as_ref(py), _range.start.row.get())?;
        instance.setattr(cache.col_offset.as_ref(py), _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(cache.end_lineno.as_ref(py), end.row.get())?;
            instance.setattr(cache.end_col_offset.as_ref(py), end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyAst for ast::ExprConstant<SourceRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            value,
            kind,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py)
            .call1((constant_to_object(value, py), kind.to_py_ast(py)?))?;

        let cache = ast_cache();
        instance.setattr(cache.lineno.as_ref(py), _range.start.row.get())?;
        instance.setattr(cache.col_offset.as_ref(py), _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(cache.end_lineno.as_ref(py), end.row.get())?;
            instance.setattr(cache.end_col_offset.as_ref(py), end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyAst for ast::ExprAttribute<SourceRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            value,
            attr,
            ctx,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py).call1((
            value.to_py_ast(py)?,
            attr.to_py_ast(py)?,
            ctx.to_py_ast(py)?,
        ))?;

        let cache = ast_cache();
        instance.setattr(cache.lineno.as_ref(py), _range.start.row.get())?;
        instance.setattr(cache.col_offset.as_ref(py), _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(cache.end_lineno.as_ref(py), end.row.get())?;
            instance.setattr(cache.end_col_offset.as_ref(py), end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyAst for ast::ExprSubscript<SourceRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            value,
            slice,
            ctx,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py).call1((
            value.to_py_ast(py)?,
            slice.to_py_ast(py)?,
            ctx.to_py_ast(py)?,
        ))?;

        let cache = ast_cache();
        instance.setattr(cache.lineno.as_ref(py), _range.start.row.get())?;
        instance.setattr(cache.col_offset.as_ref(py), _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(cache.end_lineno.as_ref(py), end.row.get())?;
            instance.setattr(cache.end_col_offset.as_ref(py), end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyAst for ast::ExprStarred<SourceRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            value,
            ctx,
            range: _range,
        } = self;

        let instance =
            Py::<PyAny>::as_ref(&cache.0, py).call1((value.to_py_ast(py)?, ctx.to_py_ast(py)?))?;

        let cache = ast_cache();
        instance.setattr(cache.lineno.as_ref(py), _range.start.row.get())?;
        instance.setattr(cache.col_offset.as_ref(py), _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(cache.end_lineno.as_ref(py), end.row.get())?;
            instance.setattr(cache.end_col_offset.as_ref(py), end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyAst for ast::ExprName<SourceRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            id,
            ctx,
            range: _range,
        } = self;

        let instance =
            Py::<PyAny>::as_ref(&cache.0, py).call1((id.to_py_ast(py)?, ctx.to_py_ast(py)?))?;

        let cache = ast_cache();
        instance.setattr(cache.lineno.as_ref(py), _range.start.row.get())?;
        instance.setattr(cache.col_offset.as_ref(py), _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(cache.end_lineno.as_ref(py), end.row.get())?;
            instance.setattr(cache.end_col_offset.as_ref(py), end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyAst for ast::ExprList<SourceRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            elts,
            ctx,
            range: _range,
        } = self;

        let instance =
            Py::<PyAny>::as_ref(&cache.0, py).call1((elts.to_py_ast(py)?, ctx.to_py_ast(py)?))?;

        let cache = ast_cache();
        instance.setattr(cache.lineno.as_ref(py), _range.start.row.get())?;
        instance.setattr(cache.col_offset.as_ref(py), _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(cache.end_lineno.as_ref(py), end.row.get())?;
            instance.setattr(cache.end_col_offset.as_ref(py), end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyAst for ast::ExprTuple<SourceRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            elts,
            ctx,
            range: _range,
        } = self;

        let instance =
            Py::<PyAny>::as_ref(&cache.0, py).call1((elts.to_py_ast(py)?, ctx.to_py_ast(py)?))?;

        let cache = ast_cache();
        instance.setattr(cache.lineno.as_ref(py), _range.start.row.get())?;
        instance.setattr(cache.col_offset.as_ref(py), _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(cache.end_lineno.as_ref(py), end.row.get())?;
            instance.setattr(cache.end_col_offset.as_ref(py), end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyAst for ast::ExprSlice<SourceRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            lower,
            upper,
            step,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py).call1((
            lower.to_py_ast(py)?,
            upper.to_py_ast(py)?,
            step.to_py_ast(py)?,
        ))?;

        let cache = ast_cache();
        instance.setattr(cache.lineno.as_ref(py), _range.start.row.get())?;
        instance.setattr(cache.col_offset.as_ref(py), _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(cache.end_lineno.as_ref(py), end.row.get())?;
            instance.setattr(cache.end_col_offset.as_ref(py), end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyAst for ast::Comprehension<SourceRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            target,
            iter,
            ifs,
            is_async,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py).call1((
            target.to_py_ast(py)?,
            iter.to_py_ast(py)?,
            ifs.to_py_ast(py)?,
            is_async.to_py_ast(py)?,
        ))?;

        Ok(instance)
    }
}

impl ToPyAst for ast::ExceptHandler<SourceRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let instance = match &self {
            ast::ExceptHandler::ExceptHandler(cons) => cons.to_py_ast(py)?,
        };
        Ok(instance)
    }
}

impl ToPyAst for ast::ExceptHandlerExceptHandler<SourceRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            type_,
            name,
            body,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py).call1((
            type_.to_py_ast(py)?,
            name.to_py_ast(py)?,
            body.to_py_ast(py)?,
        ))?;

        let cache = ast_cache();
        instance.setattr(cache.lineno.as_ref(py), _range.start.row.get())?;
        instance.setattr(cache.col_offset.as_ref(py), _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(cache.end_lineno.as_ref(py), end.row.get())?;
            instance.setattr(cache.end_col_offset.as_ref(py), end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyAst for ast::PythonArguments<SourceRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            posonlyargs,
            args,
            vararg,
            kwonlyargs,
            kw_defaults,
            kwarg,
            defaults,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py).call1((
            posonlyargs.to_py_ast(py)?,
            args.to_py_ast(py)?,
            vararg.to_py_ast(py)?,
            kwonlyargs.to_py_ast(py)?,
            kw_defaults.to_py_ast(py)?,
            kwarg.to_py_ast(py)?,
            defaults.to_py_ast(py)?,
        ))?;

        Ok(instance)
    }
}

impl ToPyAst for ast::Arg<SourceRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            arg,
            annotation,
            type_comment,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py).call1((
            arg.to_py_ast(py)?,
            annotation.to_py_ast(py)?,
            type_comment.to_py_ast(py)?,
        ))?;

        let cache = ast_cache();
        instance.setattr(cache.lineno.as_ref(py), _range.start.row.get())?;
        instance.setattr(cache.col_offset.as_ref(py), _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(cache.end_lineno.as_ref(py), end.row.get())?;
            instance.setattr(cache.end_col_offset.as_ref(py), end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyAst for ast::Keyword<SourceRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            arg,
            value,
            range: _range,
        } = self;

        let instance =
            Py::<PyAny>::as_ref(&cache.0, py).call1((arg.to_py_ast(py)?, value.to_py_ast(py)?))?;

        let cache = ast_cache();
        instance.setattr(cache.lineno.as_ref(py), _range.start.row.get())?;
        instance.setattr(cache.col_offset.as_ref(py), _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(cache.end_lineno.as_ref(py), end.row.get())?;
            instance.setattr(cache.end_col_offset.as_ref(py), end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyAst for ast::Alias<SourceRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            name,
            asname,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py)
            .call1((name.to_py_ast(py)?, asname.to_py_ast(py)?))?;

        let cache = ast_cache();
        instance.setattr(cache.lineno.as_ref(py), _range.start.row.get())?;
        instance.setattr(cache.col_offset.as_ref(py), _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(cache.end_lineno.as_ref(py), end.row.get())?;
            instance.setattr(cache.end_col_offset.as_ref(py), end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyAst for ast::WithItem<SourceRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            context_expr,
            optional_vars,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py)
            .call1((context_expr.to_py_ast(py)?, optional_vars.to_py_ast(py)?))?;

        Ok(instance)
    }
}

impl ToPyAst for ast::MatchCase<SourceRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            pattern,
            guard,
            body,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py).call1((
            pattern.to_py_ast(py)?,
            guard.to_py_ast(py)?,
            body.to_py_ast(py)?,
        ))?;

        Ok(instance)
    }
}

impl ToPyAst for ast::Pattern<SourceRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let instance = match &self {
            ast::Pattern::MatchValue(cons) => cons.to_py_ast(py)?,
            ast::Pattern::MatchSingleton(cons) => cons.to_py_ast(py)?,
            ast::Pattern::MatchSequence(cons) => cons.to_py_ast(py)?,
            ast::Pattern::MatchMapping(cons) => cons.to_py_ast(py)?,
            ast::Pattern::MatchClass(cons) => cons.to_py_ast(py)?,
            ast::Pattern::MatchStar(cons) => cons.to_py_ast(py)?,
            ast::Pattern::MatchAs(cons) => cons.to_py_ast(py)?,
            ast::Pattern::MatchOr(cons) => cons.to_py_ast(py)?,
        };
        Ok(instance)
    }
}

impl ToPyAst for ast::PatternMatchValue<SourceRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            value,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py).call1((value.to_py_ast(py)?,))?;

        let cache = ast_cache();
        instance.setattr(cache.lineno.as_ref(py), _range.start.row.get())?;
        instance.setattr(cache.col_offset.as_ref(py), _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(cache.end_lineno.as_ref(py), end.row.get())?;
            instance.setattr(cache.end_col_offset.as_ref(py), end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyAst for ast::PatternMatchSingleton<SourceRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            value,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py).call1((constant_to_object(value, py),))?;

        let cache = ast_cache();
        instance.setattr(cache.lineno.as_ref(py), _range.start.row.get())?;
        instance.setattr(cache.col_offset.as_ref(py), _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(cache.end_lineno.as_ref(py), end.row.get())?;
            instance.setattr(cache.end_col_offset.as_ref(py), end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyAst for ast::PatternMatchSequence<SourceRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            patterns,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py).call1((patterns.to_py_ast(py)?,))?;

        let cache = ast_cache();
        instance.setattr(cache.lineno.as_ref(py), _range.start.row.get())?;
        instance.setattr(cache.col_offset.as_ref(py), _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(cache.end_lineno.as_ref(py), end.row.get())?;
            instance.setattr(cache.end_col_offset.as_ref(py), end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyAst for ast::PatternMatchMapping<SourceRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            keys,
            patterns,
            rest,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py).call1((
            keys.to_py_ast(py)?,
            patterns.to_py_ast(py)?,
            rest.to_py_ast(py)?,
        ))?;

        let cache = ast_cache();
        instance.setattr(cache.lineno.as_ref(py), _range.start.row.get())?;
        instance.setattr(cache.col_offset.as_ref(py), _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(cache.end_lineno.as_ref(py), end.row.get())?;
            instance.setattr(cache.end_col_offset.as_ref(py), end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyAst for ast::PatternMatchClass<SourceRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            cls,
            patterns,
            kwd_attrs,
            kwd_patterns,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py).call1((
            cls.to_py_ast(py)?,
            patterns.to_py_ast(py)?,
            kwd_attrs.to_py_ast(py)?,
            kwd_patterns.to_py_ast(py)?,
        ))?;

        let cache = ast_cache();
        instance.setattr(cache.lineno.as_ref(py), _range.start.row.get())?;
        instance.setattr(cache.col_offset.as_ref(py), _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(cache.end_lineno.as_ref(py), end.row.get())?;
            instance.setattr(cache.end_col_offset.as_ref(py), end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyAst for ast::PatternMatchStar<SourceRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            name,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py).call1((name.to_py_ast(py)?,))?;

        let cache = ast_cache();
        instance.setattr(cache.lineno.as_ref(py), _range.start.row.get())?;
        instance.setattr(cache.col_offset.as_ref(py), _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(cache.end_lineno.as_ref(py), end.row.get())?;
            instance.setattr(cache.end_col_offset.as_ref(py), end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyAst for ast::PatternMatchAs<SourceRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            pattern,
            name,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py)
            .call1((pattern.to_py_ast(py)?, name.to_py_ast(py)?))?;

        let cache = ast_cache();
        instance.setattr(cache.lineno.as_ref(py), _range.start.row.get())?;
        instance.setattr(cache.col_offset.as_ref(py), _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(cache.end_lineno.as_ref(py), end.row.get())?;
            instance.setattr(cache.end_col_offset.as_ref(py), end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyAst for ast::PatternMatchOr<SourceRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            patterns,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py).call1((patterns.to_py_ast(py)?,))?;

        let cache = ast_cache();
        instance.setattr(cache.lineno.as_ref(py), _range.start.row.get())?;
        instance.setattr(cache.col_offset.as_ref(py), _range.start.column.get())?;
        if let Some(end) = _range.end {
            instance.setattr(cache.end_lineno.as_ref(py), end.row.get())?;
            instance.setattr(cache.end_col_offset.as_ref(py), end.column.get())?;
        }

        Ok(instance)
    }
}

impl ToPyAst for ast::TypeIgnore<SourceRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let instance = match &self {
            ast::TypeIgnore::TypeIgnore(cons) => cons.to_py_ast(py)?,
        };
        Ok(instance)
    }
}

impl ToPyAst for ast::TypeIgnoreTypeIgnore<SourceRange> {
    #[inline]
    fn to_py_ast<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {
        let cache = Self::py_type_cache().get().unwrap();

        let Self {
            lineno,
            tag,
            range: _range,
        } = self;

        let instance = Py::<PyAny>::as_ref(&cache.0, py)
            .call1((lineno.to_u32().to_object(py), tag.to_py_ast(py)?))?;

        Ok(instance)
    }
}

fn init_types(py: Python) -> PyResult<()> {
    let ast_module = PyModule::import(py, "_ast")?;
    cache_py_type::<ast::Mod>(ast_module)?;
    cache_py_type::<ast::ModModule>(ast_module)?;
    cache_py_type::<ast::ModInteractive>(ast_module)?;
    cache_py_type::<ast::ModExpression>(ast_module)?;
    cache_py_type::<ast::ModFunctionType>(ast_module)?;
    cache_py_type::<ast::Stmt>(ast_module)?;
    cache_py_type::<ast::StmtFunctionDef>(ast_module)?;
    cache_py_type::<ast::StmtAsyncFunctionDef>(ast_module)?;
    cache_py_type::<ast::StmtClassDef>(ast_module)?;
    cache_py_type::<ast::StmtReturn>(ast_module)?;
    cache_py_type::<ast::StmtDelete>(ast_module)?;
    cache_py_type::<ast::StmtAssign>(ast_module)?;
    cache_py_type::<ast::StmtAugAssign>(ast_module)?;
    cache_py_type::<ast::StmtAnnAssign>(ast_module)?;
    cache_py_type::<ast::StmtFor>(ast_module)?;
    cache_py_type::<ast::StmtAsyncFor>(ast_module)?;
    cache_py_type::<ast::StmtWhile>(ast_module)?;
    cache_py_type::<ast::StmtIf>(ast_module)?;
    cache_py_type::<ast::StmtWith>(ast_module)?;
    cache_py_type::<ast::StmtAsyncWith>(ast_module)?;
    cache_py_type::<ast::StmtMatch>(ast_module)?;
    cache_py_type::<ast::StmtRaise>(ast_module)?;
    cache_py_type::<ast::StmtTry>(ast_module)?;
    cache_py_type::<ast::StmtTryStar>(ast_module)?;
    cache_py_type::<ast::StmtAssert>(ast_module)?;
    cache_py_type::<ast::StmtImport>(ast_module)?;
    cache_py_type::<ast::StmtImportFrom>(ast_module)?;
    cache_py_type::<ast::StmtGlobal>(ast_module)?;
    cache_py_type::<ast::StmtNonlocal>(ast_module)?;
    cache_py_type::<ast::StmtExpr>(ast_module)?;
    cache_py_type::<ast::StmtPass>(ast_module)?;
    cache_py_type::<ast::StmtBreak>(ast_module)?;
    cache_py_type::<ast::StmtContinue>(ast_module)?;
    cache_py_type::<ast::Expr>(ast_module)?;
    cache_py_type::<ast::ExprBoolOp>(ast_module)?;
    cache_py_type::<ast::ExprNamedExpr>(ast_module)?;
    cache_py_type::<ast::ExprBinOp>(ast_module)?;
    cache_py_type::<ast::ExprUnaryOp>(ast_module)?;
    cache_py_type::<ast::ExprLambda>(ast_module)?;
    cache_py_type::<ast::ExprIfExp>(ast_module)?;
    cache_py_type::<ast::ExprDict>(ast_module)?;
    cache_py_type::<ast::ExprSet>(ast_module)?;
    cache_py_type::<ast::ExprListComp>(ast_module)?;
    cache_py_type::<ast::ExprSetComp>(ast_module)?;
    cache_py_type::<ast::ExprDictComp>(ast_module)?;
    cache_py_type::<ast::ExprGeneratorExp>(ast_module)?;
    cache_py_type::<ast::ExprAwait>(ast_module)?;
    cache_py_type::<ast::ExprYield>(ast_module)?;
    cache_py_type::<ast::ExprYieldFrom>(ast_module)?;
    cache_py_type::<ast::ExprCompare>(ast_module)?;
    cache_py_type::<ast::ExprCall>(ast_module)?;
    cache_py_type::<ast::ExprFormattedValue>(ast_module)?;
    cache_py_type::<ast::ExprJoinedStr>(ast_module)?;
    cache_py_type::<ast::ExprConstant>(ast_module)?;
    cache_py_type::<ast::ExprAttribute>(ast_module)?;
    cache_py_type::<ast::ExprSubscript>(ast_module)?;
    cache_py_type::<ast::ExprStarred>(ast_module)?;
    cache_py_type::<ast::ExprName>(ast_module)?;
    cache_py_type::<ast::ExprList>(ast_module)?;
    cache_py_type::<ast::ExprTuple>(ast_module)?;
    cache_py_type::<ast::ExprSlice>(ast_module)?;
    cache_py_type::<ast::ExprContext>(ast_module)?;
    cache_py_type::<ast::ExprContextLoad>(ast_module)?;
    cache_py_type::<ast::ExprContextStore>(ast_module)?;
    cache_py_type::<ast::ExprContextDel>(ast_module)?;
    cache_py_type::<ast::BoolOp>(ast_module)?;
    cache_py_type::<ast::BoolOpAnd>(ast_module)?;
    cache_py_type::<ast::BoolOpOr>(ast_module)?;
    cache_py_type::<ast::Operator>(ast_module)?;
    cache_py_type::<ast::OperatorAdd>(ast_module)?;
    cache_py_type::<ast::OperatorSub>(ast_module)?;
    cache_py_type::<ast::OperatorMult>(ast_module)?;
    cache_py_type::<ast::OperatorMatMult>(ast_module)?;
    cache_py_type::<ast::OperatorDiv>(ast_module)?;
    cache_py_type::<ast::OperatorMod>(ast_module)?;
    cache_py_type::<ast::OperatorPow>(ast_module)?;
    cache_py_type::<ast::OperatorLShift>(ast_module)?;
    cache_py_type::<ast::OperatorRShift>(ast_module)?;
    cache_py_type::<ast::OperatorBitOr>(ast_module)?;
    cache_py_type::<ast::OperatorBitXor>(ast_module)?;
    cache_py_type::<ast::OperatorBitAnd>(ast_module)?;
    cache_py_type::<ast::OperatorFloorDiv>(ast_module)?;
    cache_py_type::<ast::UnaryOp>(ast_module)?;
    cache_py_type::<ast::UnaryOpInvert>(ast_module)?;
    cache_py_type::<ast::UnaryOpNot>(ast_module)?;
    cache_py_type::<ast::UnaryOpUAdd>(ast_module)?;
    cache_py_type::<ast::UnaryOpUSub>(ast_module)?;
    cache_py_type::<ast::CmpOp>(ast_module)?;
    cache_py_type::<ast::CmpOpEq>(ast_module)?;
    cache_py_type::<ast::CmpOpNotEq>(ast_module)?;
    cache_py_type::<ast::CmpOpLt>(ast_module)?;
    cache_py_type::<ast::CmpOpLtE>(ast_module)?;
    cache_py_type::<ast::CmpOpGt>(ast_module)?;
    cache_py_type::<ast::CmpOpGtE>(ast_module)?;
    cache_py_type::<ast::CmpOpIs>(ast_module)?;
    cache_py_type::<ast::CmpOpIsNot>(ast_module)?;
    cache_py_type::<ast::CmpOpIn>(ast_module)?;
    cache_py_type::<ast::CmpOpNotIn>(ast_module)?;
    cache_py_type::<ast::Comprehension>(ast_module)?;
    cache_py_type::<ast::ExceptHandler>(ast_module)?;
    cache_py_type::<ast::ExceptHandlerExceptHandler>(ast_module)?;
    cache_py_type::<ast::PythonArguments>(ast_module)?;
    cache_py_type::<ast::Arg>(ast_module)?;
    cache_py_type::<ast::Keyword>(ast_module)?;
    cache_py_type::<ast::Alias>(ast_module)?;
    cache_py_type::<ast::WithItem>(ast_module)?;
    cache_py_type::<ast::MatchCase>(ast_module)?;
    cache_py_type::<ast::Pattern>(ast_module)?;
    cache_py_type::<ast::PatternMatchValue>(ast_module)?;
    cache_py_type::<ast::PatternMatchSingleton>(ast_module)?;
    cache_py_type::<ast::PatternMatchSequence>(ast_module)?;
    cache_py_type::<ast::PatternMatchMapping>(ast_module)?;
    cache_py_type::<ast::PatternMatchClass>(ast_module)?;
    cache_py_type::<ast::PatternMatchStar>(ast_module)?;
    cache_py_type::<ast::PatternMatchAs>(ast_module)?;
    cache_py_type::<ast::PatternMatchOr>(ast_module)?;
    cache_py_type::<ast::TypeIgnore>(ast_module)?;
    cache_py_type::<ast::TypeIgnoreTypeIgnore>(ast_module)?;
    Ok(())
}
